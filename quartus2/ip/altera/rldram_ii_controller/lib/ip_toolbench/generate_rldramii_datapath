#! /usr/bin/perl
#! /usr/local/bin/perl
# Simulation run script
#
# (c) Copyright 2001, Altera
#     All Rights Reserved
# $Revision: #1 $
#
#use Env;
#use File::Copy;
use write_rldramii_controller;
#use write_example_instance;

sub usage {
    print <<USAGE;
Usage:Genarates DDR datapath files from a list of generics.
options:
   -s <file_name>          XX file to be read
   -o <output_directory_name> file output directory
   -f <file_name>          reads the command line options from the file
   -gxyz=1234              sets the generic(parameter) 'xyz' to value '1234'
   <test_name>             runs the <test_name> simulation
   -h                      Prints this help
Supported Generics
------------------
Name                       values
===============================================
FAMILY                              : in string  := Cyclone;
LOCAL_DATA_BITS                     : in integer := 32;
LOCAL_DATA_MODE                     : in string  := narrow;
MEM_DQ_PER_DQS                      : integer    := 8;         -- no. of DQ bits per DQS/DM, generally 8 or 32
MEM_CHIP_BITS                       : in integer := 0;
LOCAL_AVALON_IF                     : in string  := "false";
MEMORY_DEVICE                       : in string  := "false";
ADDR_CMD_CLK                        : in string  := "system_clk";
MEM_CHIPSELS                        : in integer := 1;
MEM_BANK_BITS                       : in integer := 2;
MEM_ROW_BITS                        : in integer := 12;
MEM_COL_BITS                        : in integer := 10;
MEM_ADDR_BITS                       : in integer := 20;
NUMBER_MEMORY_DEVICES               : in integer := 1; 
RLDRAMII_TYPE                       : in string  := "cio";
ADDR_SHIT_BITS                      : in integer := 1;
RLDRAMII_CONFIGURATION              : in integer := 1;
MEM_TRC_CYCLES                      : in integer := 1;
MEM_TWL_CYCLES                      : in integer := 1;
LOCAL_BURST_LEN                     : in integer := 1;
LOCAL_BURST_LEN_BITS                : in integer := 1;
WR_RD_IDLE_INSERT                   : in string  := "true";
RD_WR_IDLE_INSERT                   : in string  := "true";
USE_DENALI_MEMORY_MODELS            : in string  := "false";
INSERT_ADDR_CMD_NEGEDGE_REG         : in string  := "false";
NUMBER_PIPELNE_ADDR_CMD_STAGES      : in integer := 1;
NUMBER_PIPELINE_WDATA_STAGES        : in integer := 1;
NUMBER_PIPELINE_RDATA_STAGES        : in integer := 1;
NUMBER_PIPELINE_QVLD_STAGES         : in integer := 1;
ENABLE_ADDR_CMD_CLK                 : in string  := "false";   -- new used for RLDRAM II
ADDR_CMD_NEGEDGE                    : in string  := "false";   -- new used for RLDRAM II 
USER_REFRESH                        : in string  := "single";
REFRESH_COMMAND			    : in string  := "single";
REFRESH_COUNT                       : in string  := "92";      -- new used for RLDRAM II example driver
ENABLE_CAPTURE_CLK                  : string     := "false";   -- Whether or not to use an external capture clock
ENABLE_RESYNCH_CLK                  : string     := "true";    -- Whether or not to use an external resynch clock
CHOSEN_RESYNCH_EDGE                 : string     := "rising";  -- rising, falling
CHOSEN_POSTAMBLE_EDGE               : string     := "rising";  -- rising, falling
CHOSEN_POSTAMBLE_CYCLE              : integer    := 0;         -- 0,1,2
INTER_RESYNCH                       : string     := "false";   -- Insert extra negedge sys_clk resynch register in the data path
INTER_POSTAMBLE                     : string     := "false";   -- Insert extra negedge sys_clk postamble register in the data path
PIPELINE_READDATA                   : string     := "false";   -- Insert pipeline registers to reclock the output of the resynch registers to the posedge
ENABLE_POSTAMBLE_LOGIC              : string     := "true";    -- Whether or not to insert the logic to control the capture registers, particularly important during the DQS postamble
POSTAMBLE_REGS                      : integer    := 2          -- Number of regs feeding the inclocken of the capture registers
STRATIX_UNDELAYEDDQSOUT_INSERT_BUFFERS  : integer := 0
CONNECT_RESYNCH_CLK_TO              : in string  := "clk";
CONNECT_POSTAMBLE_CLK_TO            : in string  := "clk"
CLOCK_FREQ_IN_MHZ		    : integer    := 300;
CLOCK_PERIOD_IN_PS                  : integer    := 10000;
NUM_CLOCK_PAIRS                     : in integer := 1;
DQS_PHASE_SHIFT                     : integer    := 90;
RTL_ROUNDTRIP_CLOCKS                : integer    := 0;
TOPLEVEL_NAME                       : string     := "stratixii_verilog";
WRAPPER_NAME                        : string     := "wrapper";
DDR_PREFIX_NAME                     : string     := "ddr_";
BUFFER_DLL_DELAY_OUTPUT             : string     := "false";
CLOCK_POS_PIN_NAME 		    : string     := "clk";
CLOCK_NEG_PIN_NAME 		    : string     := "clk_n";
FEDBACK_CLOCK_NAME                  : string     := "fb_clk";
CLOCKFEEDBACK_PHASE_SHIFT           : integer    := 2500;
UPDATE_TOPLEVEL			    : in strung  := "false";
ENABLE_DM_PINS			    : string     := "true";
NUMBER_ADDR_CMD_BUSES               : integer    := 1;
PROJECT_PATH			    : string     := "c:/";
WRAPPER_PATH			    : string     := "c:/";
ODT                                 : string     := "false";
IME                                 : string     := "false";
DLLE                                : string     := "true";
DDIO_MEMORY_CLOCKS                  : string     := "true";
INIT_TIME                           : integer    := 16;
USAGE
    exit(1);
}



#Usage: $0 [-d -sn -den -cov -cm -gui -f <test_list_file>] <test_name>

sub handler {
        local ($sig) = @_;
        print "Caught a SIG$sig -- shutting down\n";
        close(LOG);
        exit($sig);
}



#sub system_trap {
#    local(@args) = @_;  # List of arguments
#    $rc = system(@args);
#    if ($rc!=0) {
#      $where = `pwd`;
#      if ($rc==512) {
#        die "command @args was interrupted - quitting";
#      } elsif ($rc==256) {
#        die "command @args exited with an error in $where";
#      } else {
#        die "command @args failed to run in $where : $?";
#      }
#    }
#};

$SIG{INT}= 'handler';
$SIG{QUIT}= 'handler';
$tool = "run_sim";
$command = $tool;
#$work_base =`pwd`;
$work_base = "/dummy_path/";
chomp ($work_base);

$::language               = "vhdl";
$::quartus_version        = "4.1";
$::update_toplevel         = "false";    #-- rldramii parameter
$::gMEM_TYPE               = "ddr_sdram";
$::gFAMILY                 = "Stratix";  #-- Stratix, Stratix GX and Cyclone
$::gFAMILYlc               = "stratix";  #-- Stratix, Stratix GX and Cyclone
$::gLOCAL_DATA_BITS        = 32;         #-- local data bus width
$::gLOCAL_DATA_MODE        = narrow;     #-- narrow, wide
$::gMEM_DQ_PER_DQS         = 8;          #-- no. of DQ bits per DQS/DM, generally 8 or 32
$::gMEM_CHIP_BITS          = 1;          #
$::gLEGAL_MEM_CHIP_BITS    = 1;          #
$::gENABLE_ADDR_CMD_CLK    = "false";    #-- NEW FOR RLDRAM II
$::gADDR_CMD_NEGEDGE       = "true";     #-- NEW FOR RLDRAM II
$::gENABLE_CAPTURE_CLK    = "false";    #-- Whether or not to use an external capture clock
$::gENABLE_DM_PINS         = "true";    #-- Whether or not to use an external capture clock
#$::gENABLE_RESYNCH_CLK    = "true";     #-- Whether or not to use an external resynch clock
$::gRESYNCH_EDGE           = "rising";   #-- rising, falling
$::gPOSTAMBLE_EDGE         = "rising";   #-- rising, falling
$::gMEMORY_DEVICE          = "false";   #-- rising, falling
$::gPOSTAMBLE_CYCLE        = 0;          #-- 0,1,2
$::gINTER_RESYNCH          = "false";    #-- Insert extra negedge sys_clk resynch register in the data path
$::gINTER_POSTAMBLE        = "false";    #-- Insert extra negedge sys_clk postamble register in the data path
$::gPIPELINE_READDATA      = "false";    #-- Insert pipeline registers to reclock the output of the resynch registers to the posedge
$::gREG_DIMM               = "false";    #-- Registered DIMM mode for testbench
$::gENABLE_POSTAMBLE_LOGIC = "true";     #-- Whether or not to insert the logic to control the capture registers, particularly important during the DQS postamble
$::gPOSTAMBLE_REGS         = 1;          #-- Number of regs feeding the inclocken of the capture registers
$::gSTRATIX_UNDELAYEDDQSOUT_INSERT_BUFFERS = 0;
$::gDLL_REF_CLOCK__SWITCHED_OFF_DURING_READS = "false";
$::gSTRATIXII_DQS_PHASE_SHIFT = 6750;
$::gSTRATIXII_DLL_DELAY_BUFFER_MODE = "low";
$::gSTRATIXII_DQS_OUT_MODE  = "delay_chain3";
$::gSTRATIXII_DLL_DELAY_CHAIN_LENGTH = 16;
$::gLOCAL_AVALON_IF           = "false";
$::gMEM_CHIPSELS              = 1;
$::gMEM_BANK_BITS             = 2;
$::gMEM_ROW_BITS              = 12;
$::gMEM_COL_BITS              = 10;
$::gMEM_ADDR_BITS             = 10;
$::gMEM_NUM_DEVICES           = 1;
$::gRLDRAMII_TYPE             = "cio";
$::gADDR_SHIFT_BITS           = 1;
$::gRLDRAMII_CONFIGURATION    = 1;
$::gMEM_TRC_CYCLES            = 1;
$::gMEM_TWL_CYCLES            = 1;
$::gWR_RD_IDLE_INSERT         = "true";
$::gRD_WR_IDLE_INSERT         = "true";
$::gREFRESH_COMMAND           = "single";
$::gREFRESH_COUNT             = "92";
$::gLOCAL_BURST_LEN           = 1;
$::gLOCAL_BURST_LEN_BITS      = 1;
$::gNUM_PIPELINE_ADDR_CMD_STAGES = 1;
$::gNUM_PIPELINE_WDATA_STAGES = 1;
$::gNUM_PIPELINE_RDATA_STAGES = 1;
$::gNUM_PIPELINE_QVLD_STAGES  = 1;
$::gUSER_REFRESH              = "false";
$::gCONNECT_RESYNCH_CLK_TO    = "clk";
$::gCONNECT_POSTAMBLE_CLK_TO  = "clk";
$::gCLOCK_FREQ_IN_MHZ         = 300;
$::gCLOCK_PERIOD_IN_PS        = 10000;
$::gTINIT_CLOCKS              = 100;
$::gNUM_CLOCK_PAIRS           = 1;
$::gDQS_PHASE_SHIFT           = 90;  #degrees
$::gTPD_CLOCK_TRACE_NOM       = 500;
$::gTPD_CLOCKFEEDBACK_TRACE_NOM = 1000;
$::gTPD_DQS_TRACE_TOTAL_NOM   = 500;
$::gRTL_ROUNDTRIP_CLOCKS      = 0.0;
$::gBUFFER_DLL_DELAY_OUTPUT   = "false";
$::gFEDBACK_CLOCK_MODE = "false";
$::gFEDBACK_CLOCK_NAME = "fb_clk";
$::gTOPLEVEL_NAME = "example_top";
$::gWRAPPER_NAME = "wrapper";
$::gDDR_PREFIX_NAME = "ddr_";
$::gREGTEST_ADD_DLL_PORTS = 0;
$::gNUMBER_ADDR_CMD_BUSES = 1;
$::gWIZARD_VERSION = "2.2.0";
$::output_directory = "";
$::gFEDBACK_PHASE_SHIFT = 2500;
$::gUSE_DENALI_MEMORY_MODELS = "false";
$::gINSERT_ADDR_CMD_NEGEDGE_REG = "false";
$::gADDR_CMD_CLK = "system_clk";
$::gPROJECT_PATH	      = "c:/";
$::gWRAPPER_PATH              = "c:/";
$::gODT = "false";
$::gIME = "false";
$::gDLLE = "true";
$::gINIT_TIME = 16;
$::gDDIO_MEMORY_CLOCKS = "false"; 
#

# Parse the command line, returning the final command line
$debug = 0;
$error = 0;
print "pwd = $work_base\n" if $debug;
&usage if ($#ARGV == -1);
@args = &parse_args($work_base, @ARGV);
print @args, "\n";

#&process_soma();
&ddr_sdram();
&mw_wrapper();
&example_instance();
&test_bench();
&example_driver();
&datapath();
&byte_group();
#&write_example_testbench();
exit(-$error) if $error;
#
# Remove ".."'s in pathnames
#@tmp = ();
#foreach $arg (@args) {
#    $arg =~ s#[^/]\+/\.\.##g;
#    push(@tmp, $arg);
#}
#@args = @tmp;
exit(0);
#

# Parse an array of command-line arguments, returning
# an array of expanded command-line arguments



sub parse_args {
    local($cwd,         # Current working directory
    @args) = @_;  # List of arguments
    local ($arg) = "";
    $parse_count++;
    local($arg, @final,$pwd);
    readargs: while ($arg = shift(@args)) {
    chomp($arg);
    #print "ARG=", $arg, "\n";
    # Is this an option with a filename argument
    # that requires relocation?
    if ($arg =~ m/^-([fF])(.*)$/) {
        $opt = $1;
        $arg = $2;
        # Was it specified using the "-O arg" syntax?
        $arg = shift(@args) unless $arg;
        # Prepend the CWD if the argument is relative

# Not needed - relative paths not supported
#        $arg = "$cwd/$arg" unless $arg =~ m|^/|;
        # If this was a '-f' or '-F' option, read the file
        # and parse it as a sequence of options
        if ($opt =~ m/[fF]/) {
            print "Opening $arg file for reading\n" if $debug;
            if (!open(MFT, "< $arg")) {
                print STDERR "ERROR: Cannot open $arg for reading: $!\n";
                $error++;
                next;
            }

            local(@subargs, $_, @myargs) = ();
            while ($_ = <MFT>) {
                chomp;

# original argument splitting
#                @myargs = /\s*(\S+)/g;
                @myargs = ();
#                while ( /\s*(\S+)/g ) {
                # Now expect "XXX    =  YYY" format only
#                while ( /\s*(\S+)\s*=\s*(\S+)/g ) {
                while ( /\s*(\S+)\s*=(.*)/g ) {
                    $store_1 = $1;
                    if ($2 =~ /\s*(\S+)/ ) {
                        $store_2 = $1;
                    } else {
                        $store_2 = "";
                        print "Found Null Arg" if $debug;
                    }

                    # if we find a // then ignore the rest of the line
                    if (($store_1 =~ m#//#) || ($store_1 =~ m#--#)){
                        #print "\n\n Found Comment ! \n\n";
                        last;
                    } else {
                           #push(@myargs, $1);
                           push(@myargs, "-g" . $store_1."=".$store_2);
                       }
                }
                print "My Args=" if $debug;
                print join "|", @myargs, "\n" if $debug;
                push(@subargs, @myargs);
                #push(@subargs, $_);
            }
            close(MFT);
            # If the option was '-F', change the cwd to the directory
            # containing the argument file
            $newcwd = $cwd;

            # Not needed any more (should use -f instead)
            #if ($opt eq "F") {
            #    $arg =~ m#^(.*)/[^/]+$#;
            #    $newcwd = $1;
            #    chdir($newcwd) or die "Can't chdir to $newcwd";
            #    print "Changed dir -F to $newcwd\n" if $debug;
            #}
            push(@final, &parse_args($newcwd, @subargs));
            #Not needed any more
            #chdir($cwd) or die "Can't chdir to $cwd";
            #print "Changed dir back to $cwd\n" if $debug;
        } else {
            push(@final, "-$opt", $arg);
        }
    }

    # Get the generics
    elsif ($arg =~ m/^-(g|g)(.*)$/) {
        $opt = $1;
        $arg = $2;
        # Was it specified using the "-O arg" syntax?
        $arg = shift(@args) unless $arg;
 #       print $opt, "=====", $arg, "\n";
        $arg =~ m/^(.*)=(.*)$/;
        $generic = uc $1;
        $generic_val = $2;
#        print $generic, "+++++", $generic_val, "\n";
#$gINTER_POSTAMBLE        = "false";   #-- Insert extra negedge sys_clk postamble register in the data path
#$gPIPELINE_READDATA      = "false";   #-- Insert pipeline registers to reclock the output of the resynch registers to the posedge
#$gENABLE_POSTAMBLE_LOGIC = "true";    #-- Whether or not to insert the logic to control the capture registers, particularly important during the DQS postamble
#$gPOSTAMBLE_REGS         = 2          #-- Number of regs feeding the inclocken of the capture registers
        if ($generic eq "FAMILY") {
            $gFAMILY = $generic_val;
            if ($gFAMILY  eq "stratixii") {
                $gFAMILY = "Stratix II";
                $gFAMILYlc = "stratixii";
            }
            elsif ($gFAMILY  eq "stratixiigx") {
                $gFAMILY = "Stratix II GX";
                $gFAMILYlc = "stratixiigx";
           }
            elsif ($gFAMILY  eq "hardcopyii") {
                $gFAMILY = "HardCopy II";
                $gFAMILYlc = "hardcopyii";
            }
            else {
                $gFAMILYlc = lc $gFAMILY;
            }
            print "gFAMILY=",$gFAMILY, "\n";
        }
        elsif ($generic eq "MEMORY_TYPE") {
            $gMEM_TYPE = $generic_val;
            print "gMEM_TYPE=",$gMEM_TYPE, "\n";
        }
        elsif ($generic eq "RLDRAMII_DEVICE") {
            $gMEMORY_DEVICE = $generic_val;
            print "gMEMORY_DEVICE=",$gMEMORY_DEVICE, "\n";
        }
        elsif ($generic eq "DDIO_MEMORY_CLOCKS") {
            $gDDIO_MEMORY_CLOCKS = $generic_val;
            print "gDDIO_MEMORY_CLOCKS=",$gDDIO_MEMORY_CLOCKS, "\n";
        }
	elsif ($generic eq "UPDATE_TOPLEVEL") {
            $update_toplevel = $generic_val;
            print "update_toplevel=",$update_toplevel, "\n";
        }
	elsif ($generic eq "ENABLE_ON_DIE_TERMINATION") {
            $gODT = $generic_val;
            print "ODT=",$gODT, "\n";
        }
	elsif ($generic eq "ENABLE_EXTERNAL_IMPEDANCE_MATCHING") {
            $gIME = $generic_val;
            print "IME=",$gIME, "\n";
        }
	elsif ($generic eq "ENABLE_DLL") {
            $gDLLE = $generic_val;
            print "DLLE=",$gDLLE, "\n";
        }
	elsif ($generic eq "INITIALISATION_TIME") {
            $gINIT_TIME = $generic_val;
            print "INIT_TIME=",$gINIT_TIME, "\n";
        }
	elsif ($generic eq "USE_DENALI_MEMORY_MODELS") {
            $gUSE_DENALI_MEMORY_MODELS = $generic_val;
            print "use_denali_memory_models=",$gUSE_DENALI_MEMORY_MODELS, "\n";
        }
	elsif ($generic eq "ENABLE_DM_PINS") {
            $gENABLE_DM_PINS = $generic_val;
            print "ENABLE_DM_PINS=",$gENABLE_DM_PINS, "\n";
        }
	elsif ($generic eq "NUMBER_ADDR_CMD_BUSES") {
            $gNUMBER_ADDR_CMD_BUSES = $generic_val;
            print "NUMBER_ADDR_CMD_BUSES=",$gNUMBER_ADDR_CMD_BUSES, "\n";
        }
	elsif ($generic eq "INSERT_ADDR_CMD_NEGEDGE_REG") {
            $gINSERT_ADDR_CMD_NEGEDGE_REG = $generic_val;
            print "INSERT_ADDR_CMD_NEGEDGE_REG=",$gINSERT_ADDR_CMD_NEGEDGE_REG, "\n";
        }
	elsif ($generic eq "ADDR_CMD_CLK") {
            $gADDR_CMD_CLK = $generic_val;
            print "ADDR_CMD_CLK=",$gADDR_CMD_CLK, "\n";
        }
	elsif ($generic eq "LOCAL_DATA_BITS") {
            $gLOCAL_DATA_BITS = $generic_val;
            print "gLOCAL_DATA_BITS=",$gLOCAL_DATA_BITS, "\n";
        }
	elsif ($generic eq "CLOCKFEEDBACK_PHASE_SHIFT") {
            $gFEDBACK_PHASE_SHIFT = $generic_val;
            print "gFEDBACK_PHASE_SHIFT=",$gFEDBACK_PHASE_SHIFT, "\n";
        }
        elsif ($generic eq "LOCAL_DATA_WIDTH_MODE") {
            $gLOCAL_DATA_MODE = $generic_val;	    
            print "gDATA_MODE=",$LOCAL_gDATA_MODE, "\n";
        }	
        elsif ($generic eq "MEM_DQ_PER_DQS") {
            $gMEM_DQ_PER_DQS = $generic_val;
            print "gMEM_DQ_PER_DQS=",$gMEM_DQ_PER_DQS, "\n";
        }
        elsif ($generic eq "MEM_CHIP_BITS") {
            $gMEM_CHIP_BITS = $generic_val;
            if ($gMEM_CHIP_BITS > 0) {
                $gLEGAL_MEM_CHIP_BITS = $gMEM_CHIP_BITS;
           }
            print "gMEM_CHIP_BITS=",$gMEM_CHIP_BITS, "\n";
        }
        elsif ($generic eq "ENABLE_ADDR_CMD_CLK") {
            $gENABLE_ADDR_CMD_CLK = $generic_val;
            print "gENABLE_ADDR_CDM_CLK=",$gENABLE_ADDR_CMD_CLK, "\n";
        }
        elsif ($generic eq "ADDR_CMD_NEGEDGE") {
            $gADDR_CMD_NEGEDGE = $generic_val;
            print "gADDR_CMD_NEGEDGE=",$gADDR_CMD_NEGEDGE, "\n";
        }
	elsif ($generic eq "CLOCKFEEDBACK_IN_PIN_NAME") {
            $gFEDBACK_CLOCK_NAME = $generic_val;
            print "gFEDBACK_CLOCK_NAME=",$gFEDBACK_CLOCK_NAME, "\n";
        }
	elsif ($generic eq "RLDRAMII_CONFIGURATION") {
            $gRLDRAMII_CONFIGURATION = $generic_val;
            print "gRLDRAMII_CONFIGURATION=",$gRLDRAMII_CONFIGURATION, "\n";
        }
	elsif ($generic eq "NUMBER_TRC_CYCLES") {
            $gMEM_TRC_CYCLES = $generic_val;
            print "gMEM_TRC_CYCLES=",$gMEM_TRC_CYCLES, "\n";
        }
	elsif ($generic eq "NUMBER_TWL_CYCLES") {
            $gMEM_TWL_CYCLES = $generic_val;
            print "gMEM_TWL_CYCLES=",$gMEM_TWL_CYCLES, "\n";
        }
	elsif ($generic eq "WR_RD_IDLE_INSERT") {
            $gWR_RD_IDLE_INSERT = $generic_val;
            print "gWR_RD_IDLE_INSERT=",$gWR_RD_IDLE_INSERT, "\n";
        }
	elsif ($generic eq "RD_WR_IDLE_INSERT") {
            $gRD_WR_IDLE_INSERT = $generic_val;
            print "gRD_WR_IDLE_INSERT=",$gRD_WR_IDLE_INSERT, "\n";
        }
	elsif ($generic eq "CLOCK_POS_PIN_NAME") {
	    $gCLOCK_POS_PIN_NAME_TMP = $generic_val;
	    print "$gCLOCK_POS_PIN_NAME_TMP\n";
	    if ($gCLOCK_POS_PIN_NAME_TMP =~ s/\[*\d]//) {
	    #if ($gCLOCK_POS_PIN_NAME_TMP =~ m/\[*\d]/) {
	    	print "FOUND [] IN CLOCK PIN NAME\n";
		$gCLOCK_POS_PIN_NAME = $gCLOCK_POS_PIN_NAME_TMP;
	    }
	    else
	    {
	    	$gCLOCK_POS_PIN_NAME = $gCLOCK_POS_PIN_NAME_TMP;
	    }
            print "gCLOCK_POS_PIN_NAME=",$gCLOCK_POS_PIN_NAME, "\n";
        }
	elsif ($generic eq "CLOCK_NEG_PIN_NAME") {
	    $gCLOCK_NEG_PIN_NAME_TMP = $generic_val;
	    print "$gCLOCK_NEG_PIN_NAME_TMP\n";
	    if ($gCLOCK_NEG_PIN_NAME_TMP =~ s/\[*\d]//) {
	    #if ($gCLOCK_NEG_PIN_NAME_TMP =~ m/\[*\d]/) {
	    	print "FOUND [] IN CLOCK PIN NAME\n";
		$gCLOCK_NEG_PIN_NAME = $gCLOCK_NEG_PIN_NAME_TMP;
	    }
	    else
	    {
	    	$gCLOCK_NEG_PIN_NAME = $gCLOCK_NEG_PIN_NAME_TMP;
	    }
            print "gCLOCK_NEG_PIN_NAME=",$gCLOCK_NEG_PIN_NAME, "\n";
        }	
        elsif ($generic eq "ENABLE_CAPTURE_CLK") {
            $gENABLE_CAPTURE_CLK = $generic_val;
            print "gENABLE_CAPTURE_CLK=",$gENABLE_CAPTURE_CLK, "\n";
        }
#        elsif ($generic eq "ENABLE_RESYNCH_CLK") {
#            $gENABLE_RESYNCH_CLK = $generic_val;
#            print "gENABLE_RESYNCH_CLK=",$gENABLE_RESYNCH_CLK, "\n";
#        }
        elsif ($generic eq "CHOSEN_RESYNCH_EDGE") {
            $gRESYNCH_EDGE = $generic_val;
          print "gRESYNCH_EDGE=",$gRESYNCH_EDGE, "\n";
        }
        elsif ($generic eq "CHOSEN_POSTAMBLE_EDGE") {
            $gPOSTAMBLE_EDGE = $generic_val;
            print "gPOSTAMBLE_EDGE=",$gPOSTAMBLE_EDGE, "\n";
        }
        elsif ($generic eq "CHOSEN_POSTAMBLE_CYCLE") {
            $gPOSTAMBLE_CYCLE = $generic_val;
            print "gPOSTAMBLE_CYCLE=",$gPOSTAMBLE_CYCLE, "\n";
        }
        elsif ($generic eq "INTER_RESYNCH") {
            $gINTER_RESYNCH = $generic_val;
            print "gINTER_RESYNCH=",$gINTER_RESYNCH, "\n";
        }
        elsif ($generic eq "INTER_POSTAMBLE") {
            $gINTER_POSTAMBLE = $generic_val;
            print "gINTER_POSTAMBLE=",$gINTER_POSTAMBLE, "\n";
        }
        elsif ($generic eq "PIPELINE_READDATA") {
            $gPIPELINE_READDATA = $generic_val;
            print "gPIPELINE_READDATA=",$gPIPELINE_READDATA, "\n";
        }
        elsif ($generic eq "REG_DIMM") {
            $gREG_DIMM = $generic_val;
            print "gREG_DIMM=",$gREG_DIMM, "\n";
        }
        elsif ($generic eq "ENABLE_POSTAMBLE") {
            $gENABLE_POSTAMBLE_LOGIC = $generic_val;
            print "gENABLE_POSTAMBLE_LOGIC=",$gENABLE_POSTAMBLE_LOGIC, "\n";
        }
        elsif ($generic eq "POSTAMBLE_REGS") {
            $gPOSTAMBLE_REGS = $generic_val;
            print "gPOSTAMBLE_REGS=",$gPOSTAMBLE_REGS, "\n";
        }
        elsif ($generic eq "STRATIX_UNDELAYEDDQSOUT_INSERT_BUFFERS") {
            $gSTRATIX_UNDELAYEDDQSOUT_INSERT_BUFFERS = $generic_val;
            print "gSTRATIX_UNDELAYEDDQSOUT_INSERT_BUFFERS=",$gSTRATIX_UNDELAYEDDQSOUT_INSERT_BUFFERS, "\n";
        }
        elsif ($generic eq "LOCAL_AVALON_IF") {
            $gLOCAL_AVALON_IF = $generic_val;
          print "gLOCAL_AVALON_IF=",$gLOCAL_AVALON_IF, "\n";
        }
        elsif ($generic eq "MEM_CHIPSELS") {
            $gMEM_CHIPSELS = $generic_val;
           print "gMEM_CHIPSELS=",$gMEM_CHIPSELS, "\n";
        }
        elsif ($generic eq "MEM_BANK_BITS") {
            $gMEM_BANK_BITS = $generic_val;
            print "gMEM_BANK_BITS=",$gMEM_BANK_BITS, "\n";
        }
       elsif ($generic eq "MEM_ROW_BITS") {
            $gMEM_ROW_BITS = $generic_val;
            print "gMEM_ROW_BITS=",$gMEM_ROW_BITS, "\n";
        }
       elsif ($generic eq "MEM_ADDR_BITS") {
            $gMEM_ADDR_BITS = $generic_val;
            print "gMEM_ADDR_BITS=",$gMEM_ADDR_BITS, "\n";
        }
	elsif ($generic eq "NUMBER_MEMORY_DEVICES") {
            $gMEM_NUM_DEVICES = $generic_val;
           print "gMEM_NUM_DEVICES=",$gMEM_NUM_DEVICES, "\n";
       }
       	elsif ($generic eq "PROJECT_PATH") {
            $gPROJECT_PATH = $generic_val;
           print "gPROJECT_PATH=",$gPROJECT_PATH, "\n";
       }
       	elsif ($generic eq "WRAPPER_PATH") {
            $gWRAPPER_PATH = $generic_val;
           print "gWRAPPER_PATH=",$gWRAPPER_PATH, "\n";
       }
       elsif ($generic eq "TYPE") {
            $gRLDRAMII_TYPE = $generic_val;
            print "gRLDRAMII_TYPE=",$gRLDRAMII_TYPE, "\n";
        }
	elsif ($generic eq "ADDR_SHIFT_BITS") {
            $gADDR_SHIFT_BITS = $generic_val;
            print "gADDR_SHIFT_BITS=",$gADDR_SHIFT_BITS, "\n";
        }
	elsif ($generic eq "REFRESH_COMMAND") {
            $gREFRESH_COMMAND = $generic_val;
            print "gREFRESH_COMMAND=",$gREFRESH_COMMAND, "\n";
        }
	elsif ($generic eq "REFRESH_COUNT") {
            $gREFRESH_COUNT = $generic_val;
            print "gREFRESH_COUNT=",$gREFRESH_COUNT, "\n";
        }
	elsif ($generic eq "MEM_ADDR_BITS") {
            $gMEM_COL_BITS = $generic_val;
            print "gMEM_COL_BITS=",$gMEM_COL_BITS, "\n";
        }	
        elsif ($generic eq "LOCAL_BURST_LEN") {
           $gLOCAL_BURST_LEN = $generic_val;
            print "gLOCAL_BURST_LEN=",$gLOCAL_BURST_LEN, "\n";
        }
        elsif ($generic eq "LOCAL_BURST_LEN_BITS") {
            $gLOCAL_BURST_LEN_BITS = $generic_val;
            print "gLOCAL_BURST_LEN_BITS=",$gLOCAL_BURST_LEN_BITS, "\n";
        }
	elsif ($generic eq "NUMBER_PIPELINE_ADDR_CMD_STAGES") {
            $gNUM_PIPELINE_ADDR_CMD_STAGES = $generic_val;
            print "gNUM_PIPELINE_ADDR_CMD_STAGES=",$gNUM_PIPELINE_ADDR_CMD_STAGES, "\n";
        }
##
	elsif ($generic eq "NUMBER_PIPELINE_WDATA_STAGES") {
            $gNUM_PIPELINE_WDATA_STAGES = $generic_val;
            print "gNUM_PIPELINE_WDATA_STAGES=",$gNUM_PIPELINE_WDATA_STAGES, "\n";
        }
##
	elsif ($generic eq "NUMBER_PIPELINE_RDATA_STAGES") {
            $gNUM_PIPELINE_RDATA_STAGES = $generic_val;
            print "gNUM_PIPELINE_RDATA_STAGES=",$gNUM_PIPELINE_RDATA_STAGES, "\n";
        }
##
	elsif ($generic eq "NUMBER_PIPELINE_QVLD_STAGES") {
            $gNUM_PIPELINE_QVLD_STAGES = $generic_val;
            print "gNUM_PIPELINE_QVLD_STAGES=",$gNUM_PIPELINE_QVLD_STAGES, "\n";
        }
        elsif ($generic eq "USER_REFRESH") {
            $gUSER_REFRESH = $generic_val;
            print "gUSER_REFRESH=",$gUSER_REFRESH, "\n";
        }
        elsif ($generic eq "BUFFER_DLL_DELAY_OUTPUT") {
            $gBUFFER_DLL_DELAY_OUTPUT = $generic_val;
            print "gBUFFER_DLL_DELAY_OUTPUT=",$gBUFFER_DLL_DELAY_OUTPUT, "\n";
        }
        elsif ($generic eq "FEDBACK_CLOCK_MODE") {
            $gFEDBACK_CLOCK_MODE = $generic_val;
            print "gFEDBACK_CLOCK_MODE=",$gFEDBACK_CLOCK_MODE, "\n";
        }
        elsif ($generic eq "CHOSEN_RESYNCH_CLK") {
            $gCONNECT_RESYNCH_CLK_TO = $generic_val;
            print "gCONNECT_RESYNCH_CLK_TO=",$gCONNECT_RESYNCH_CLK_TO, "\n";
        }
        elsif ($generic eq "CHOSEN_RESYNCH_CYCLE") {
            $gRESYNCH_CYCLE = $generic_val;
            print "gRESYNCH_CYCLE=",$gRESYNCH_CYCLE, "\n";
        }
        elsif ($generic eq "CHOSEN_POSTAMBLE_CLK") {

            $gCONNECT_POSTAMBLE_CLK_TO = $generic_val;

            print "gCONNECT_POSTAMBLE_CLK_TO=",$gCONNECT_POSTAMBLE_CLK_TO, "\n";

        }

        elsif ($generic eq "CLOCK_PERIOD_IN_PS") {

            $gCLOCK_PERIOD_IN_PS = $generic_val;

            print "gCLOCK_PERIOD_IN_PS=",$gCLOCK_PERIOD_IN_PS, "\n";

        }

	elsif ($generic eq "CLOCK_FREQ_IN_MHZ") {
            $gCLOCK_FREQ_IN_MHZ = $generic_val;
            print "gCLOCK_FREQ_IN_MHZ=",$gCLOCK_FREQ_IN_MHZ, "\n";
        }
	
        elsif ($generic eq "DQS_PHASE") {

            $gDQS_PHASE_SHIFT = $generic_val;

            print "gDQS_PHASE_SHIFT=",$gDQS_PHASE_SHIFT, "\n";

        }

        elsif ($generic eq "STRATIXII_DQS_PHASE") {

            $gSTRATIXII_DQS_PHASE_SHIFT = $generic_val;

            print "gSTRATIXII_DQS_PHASE_SHIFT=",$gSTRATIXII_DQS_PHASE_SHIFT, "\n";

        }

        elsif ($generic eq "STRATIXII_DLL_DELAY_BUFFER_MODE") {

            $gSTRATIXII_DLL_DELAY_BUFFER_MODE = $generic_val;

            print "gSTRATIXII_DLL_DELAY_BUFFER_MODE=",$gSTRATIXII_DLL_DELAY_BUFFER_MODE, "\n";

        }

        elsif ($generic eq "STRATIXII_DQS_OUT_MODE") {

            $gSTRATIXII_DQS_OUT_MODE = $generic_val;

            print "gSTRATIXII_DQS_OUT_MODE=",$gSTRATIXII_DQS_OUT_MODE, "\n";

        }

        elsif ($generic eq "STRATIXII_DELAY_CHAIN_LENGTH") {

            $gSTRATIXII_DLL_DELAY_CHAIN_LENGTH = $generic_val;

            print "gSTRATIXII_DLL_DELAY_CHAIN_LENGTH=",$gSTRATIXII_DLL_DELAY_CHAIN_LENGTH, "\n";

        }

        elsif ($generic eq "DLL_REF_CLOCK__SWITCHED_OFF_DURING_READS") {

            $gDLL_REF_CLOCK__SWITCHED_OFF_DURING_READS = $generic_val;

            print "gDLL_REF_CLOCK__SWITCHED_OFF_DURING_READS=",$gDLL_REF_CLOCK__SWITCHED_OFF_DURING_READS, "\n";

        }

        elsif ($generic eq "TINIT_CLOCKS") {

            $gTINIT_CLOCKS = $generic_val;

            print "gTINIT_CLOCKS=",$gTINIT_CLOCKS, "\n";

        }

        elsif ($generic eq "NUM_OUTPUT_CLOCKS") {

            $gNUM_CLOCK_PAIRS = $generic_val;

            print "gNUM_CLOCK_PAIRS=",$gNUM_CLOCK_PAIRS, "\n";

        }

        elsif ($generic eq "RTL_ROUNDTRIP_CLOCKS") {

            $gRTL_ROUNDTRIP_CLOCKS = $generic_val;

            print "gRTL_ROUNDTRIP_CLOCKS=",$gRTL_ROUNDTRIP_CLOCKS, "\n";

        }

        elsif ($generic eq "TPD_CLOCK_TRACE_NOM") {

            $gTPD_CLOCK_TRACE_NOM = $generic_val;

            print "gTPD_CLOCK_TRACE_NOM=",$gTPD_CLOCK_TRACE_NOM, "\n";

        }

        elsif ($generic eq "TPD_CLOCKFEEDBACK_TRACE_NOM") {

            $gTPD_CLOCKFEEDBACK_TRACE_NOM = $generic_val;

            print "gTPD_CLOCKFEEDBACK_TRACE_NOM=",$gTPD_CLOCKFEEDBACK_TRACE_NOM, "\n";

        }

        elsif ($generic eq "TPD_DQS_TRACE_TOTAL_NOM") {

            $gTPD_DQS_TRACE_TOTAL_NOM = $generic_val;

            print "gTPD_DQS_TRACE_TOTAL_NOM=",$gTPD_DQS_TRACE_TOTAL_NOM, "\n";

        }

        elsif ($generic eq "TOPLEVEL_NAME") {

            $gTOPLEVEL_NAME = $generic_val;

            print "gTOPLEVEL_NAME=",$gTOPLEVEL_NAME, "\n";

        }

        elsif ($generic eq "WRAPPER_NAME") {

            $gWRAPPER_NAME = $generic_val;

            print "gWRAPPER_NAME=",$gWRAPPER_NAME, "\n";

        }

        elsif ($generic eq "DDR_PIN_PREFIX") {

            $gDDR_PREFIX_NAME = $generic_val;

            print "gDDR_PREFIX_NAME=",$gDDR_PREFIX_NAME, "\n";

        }

        elsif ($generic eq "LANGUAGE") {

            $language = $generic_val;

            if ($language ne "vhdl") {

                $language = "verilog";

            }

            print "language=",$language, "\n";

        }

        elsif ($generic eq "QUARTUS_VERSION") {

            $quartus_version = $generic_val;

            if ($quartus_version ne "4.0") {

                $quartus_version = "4.1";

            }

            print "quartus_version=",$quartus_version, "\n";

        }

        elsif ($generic eq "MEGAWIZARD_VERSION") {

            $gWIZARD_VERSION = $generic_val;

            print "WIZARD_VERSION=",$gWIZARD_VERSION, "\n";

        }

        elsif ($generic eq "REGTEST_ADD_DLL_PORTS") {

            $gREGTEST_ADD_DLL_PORTS = $generic_val;

            print "REGTEST_ADD_DLL_PORTS=",$gREGTEST_ADD_DLL_PORTS, "\n";

        }

        else {

            print $generic, " - Unrecognised Generic !!!\n";

        }

#        print "cas=",$gcaslatency," col=",$gcolbits," row=",$growbits, "\n";

#        $arg =~ tr/A-Z/a-z/;

#        print $opt, "=====", $arg, "\n";

        $generic = $arg;

        push(@final, "-$opt", $arg);

    }

    # Get the soma in file name

    elsif ($arg =~ m/^-(s|S)(.*)$/) {

        $opt = $1;

        $arg = $2;

        # Was it specified using the "-O arg" syntax?

        $arg = shift(@args) unless $arg;

        print $opt, "=====", $arg, "\n";

#        $arg =~ tr/A-Z/a-z/;

#        print $opt, "=====", $arg, "\n";

        $soma_file = $arg;

        push(@final, "-$opt", $arg);

    }

    

    # Get the soma out file name

    elsif ($arg =~ m/^-(o|O)(.*)$/) {

        $opt = $1;

        $arg = $2;

        # Was it specified using the "-O arg" syntax?

        $arg = shift(@args) unless $arg;

        print $opt, "=====", $arg, "\n";

#        $arg =~ tr/A-Z/a-z/;

#        print $opt, "=====", $arg, "\n";

        $output_directory = $arg . "/";

	my $s1 = '/';

        $output_directory =~ s/\\/$s1/g;

	

	#print("\n\n\n\n\n", $output_directory, "\n\n\n\n\n");

        

	push(@final, "-$opt", $arg);

    }

    

    

    # Get debug option

    elsif ($arg =~ m/^-(d|d)(.*)$/) {

        $debug = 1;

    }

    elsif ($arg =~ m/^-(h|H)(.*)$/) {

        $opt = $1;

        &usage;

    }

    # Anything else is a test to run

    else {

    }

    }

    #print join " ", @final, "\n";

    @args = @final;

    return @final;

#    return @args;

}



sub byte_group{

#&init_controller3();



}



sub datapath{
	&init_controller2();
}



sub ddr_sdram {



#&init_controller();
}

sub test_bench{

sub example_driver{

	&init_controller4();

}

	&init_controller6();

}


sub example_instance{
	&init_controller5();
}

sub mw_wrapper{
	&init_controller3();
}

sub init_vars{



#	my @files = ("${gWRAPPER_NAME}_auk_ddr_dqs_group","${gWRAPPER_NAME}_auk_ddr_datapath","${gWRAPPER_NAME}_auk_ddr_sdram","${gWRAPPER_NAME}_example_driver","$gTOPLEVEL_NAME");



#	if($language eq "verilog")



#	{



#		$ext = ".v";



#	}elsif($language eq "vhdl")



#	{



#		$ext = ".vhd";



#	}



#	&init_controller();



#



#	foreach my $file(@files)



#	{



#		$in_test = $file.$ext;



#		open(IN, "< $in_test") or die "Error! Couldn't open $in_test. $!";



#		$out_test = $output_directory.$file.$ext;



#		open(OUT, "> $out_test") or die "Error! Couldn't open $out_test. $!";



#	



#		while ($_ = <IN>) {



#               	print OUT $_;



#		};



#	}



}



sub write_example_testbench{



    if ($language eq "vhdl") {



        $file_ext = ".vhd"



    } else {



        $file_ext = ".v"



    }



#    $gTOPLEVEL_NAME = "stratixii_verilog";



#    $gWRAPPER_NAME = "wrapper";



#    $gDDR_PREFIX_NAME = "ddr_";



    $example_testbench_file_out = $output_directory . $gTOPLEVEL_NAME . "_tb" . $file_ext;



    open(ETB_OUT, "> ${example_testbench_file_out}.tmp") or die "Error! Couldn't open ${example_testbench_file_out}.tmp . $!";



    if ($language eq "vhdl") {



        ###HEADER



        vhdl_write_etb_header();



        ### PORTLIST







        vhdl_write_etb_portlist();



        ### SIGNAL DECLARATIONS







#        vhdl_write_bg_signaldec();



        ### BODY



#        vhdl_write_bg_bodystart();



        ###BYTE GROUP GENERATE



#        vhdl_write_dp_bg();



        ### BODY END







#        vhdl_write_dp_bodyend();



    } else {







        ###HEADER



        verilog_write_etb_header();



        ### PORTLIST



        verilog_write_etb_portlist();



        ### SIGNAL DECLARATIONS



#        verilog_write_bg_signaldec();



        ### BODY



#        verilog_write_bg_bodystart();



        ###BYTE GROUP GENERATE



#        verilog_write_dp_bg();



        ### BODY END



#        verilog_write_dp_bodyend();



    }



    close ETB_OUT;



    %insert_hash = ();







    if (-e $example_testbench_file_out) {



        # Parse file for special comments







        print "\n Parsing Generated Example Testbench File ! \n" if $debug;               # debug



        open(ETB_IN, "< ${example_testbench_file_out}.tmp") or die "Error! Couldn't open ${example_testbench_file_out}.tmp. $!";



        while ($_ = <ETB_IN>) {



            $preserve_text="";



            if ( /\.* << START MEGAWIZARD INSERT (\w+)/ ) {



                $preserve_type = $1;







                print "\n Found Insert $preserve_type ! \n" if $debug;       # debug



                $_ = <ETB_IN>;







                until ( /\.* << END MEGAWIZARD INSERT $preserve_type/ || eof ETB_IN) {



                    $preserve_text .= $_;



                    $_ = <ETB_IN>;



                }



                #chomp($preserve_text);



                $insert_hash{$preserve_type}=$preserve_text;          # Add to hash



                print "\n Found END Insert $preserve_type ! \n" if $debug;      # debug



            }



        }



        open(ETB_IN, "< ${example_testbench_file_out}") or die "Error! Couldn't open ${example_testbench_file_out}. $!";



        open(ETB_OUT, "> ${example_testbench_file_out}.tmp2") or die "Error! Couldn't open ${example_testbench_file_out}.tmp2 . $!";



        print "\n Parsing Existing Example Testbench File ! \n";               # debug



        $allowed_to_parse_file = 0;



        while ($_ = <ETB_IN>) {



            $preserve_text="";



            print ETB_OUT;



            if ( /\.* << START MEGAWIZARD INSERT (\w+)/ ) {



                $preserve_type = $1;



                print "\n Found Insert $preserve_type ! \n" if $debug;       # debug



                print ETB_OUT $insert_hash{$preserve_type};



#                $_ = <ETB_IN>;



                until ( /\.* << END MEGAWIZARD INSERT $preserve_type/ || eof ETB_IN) {



                    $_ = <ETB_IN>;



                }



                print ETB_OUT;



                print "\n Found END Insert $preserve_type ! \n" if $debug;      # debug



            }



            if ( /\.* << MEGAWIZARD PARSE FILE DDR(\S+)/ ) {



                print "\n Found PARSE FILE DDR${1} ! \n" if $debug;      # debug



                if ($1 eq $gWIZARD_VERSION) {



                    print "\n Version number matches - parsing file! \n" if $debug;      # debug







                    $allowed_to_parse_file = 1;



                } else {







                    print "\n Version number $1 does not match $gWIZARD_VERSION  \n" if $debug;      # debug



                    $allowed_to_parse_file = 0;



                }



            }



        }



#        system_trap("copy ${example_testbench_file_out}.tmp2 ${example_testbench_file_out}");



#        copy(${example_testbench_file_out}.tmp2, ${example_testbench_file_out});



        if ($allowed_to_parse_file) {







            open(ETB_IN, "< ${example_testbench_file_out}.tmp2") or die "Error! Couldn't open ${example_testbench_file_out}.tmp2 $!";



        } else {







            print "\n Parsed Example Testbench File does not match - generating new file! \n" if $debug;               # debug



            open(ETB_IN, "< ${example_testbench_file_out}") or die "Error! Couldn't open ${example_testbench_file_out} $!";



            open(ETB_OUT, "> ${example_testbench_file_out}.old") or die "Error! Couldn't open ${example_testbench_file_out}.old . $!";



            while ($_ = <ETB_IN>) {



                print ETB_OUT $_;



            };



            open(ETB_IN, "< ${example_testbench_file_out}.tmp") or die "Error! Couldn't open ${example_testbench_file_out}.tmp $!";



        }



        open(ETB_OUT, "> ${example_testbench_file_out}") or die "Error! Couldn't open ${example_testbench_file_out} . $!";



        while ($_ = <ETB_IN>) {



            print ETB_OUT $_;



        };



    } else {



#        system_trap("copy ${example_testbench_file_out}.tmp ${example_testbench_file_out}");







#        copy(${example_testbench_file_out}.tmp, ${example_testbench_file_out});



        open(ETB_IN, "< ${example_testbench_file_out}.tmp") or die "Error! Couldn't open ${example_testbench_file_out}.tmp $!";







        open(ETB_OUT, "> ${example_testbench_file_out}") or die "Error! Couldn't open ${example_testbench_file_out} . $!";



        while ($_ = <ETB_IN>) {



            print ETB_OUT $_;



        };



    };



# MegaWizard - Quartus perl doesn't have this



#    unlink <${example_testbench_file_out}.tmp>, <${example_testbench_file_out}.tmp2> unless $debug;







### END



}







sub vhdl_write_etb_header {



### HEADER



$header_title = "Example top level testbench for $gWRAPPER_NAME DDR SDRAM Controller";



$header_filename = $gTOPLEVEL_NAME . "_tb" . $file_ext;



$header_revision = "V" . $gWIZARD_VERSION;



print ETB_OUT  <<HEADERZZ;



--------------------------------------------------------------------------------



-- This confidential and proprietary software may be used only as authorized by



-- a licensing agreement from Altera Corporation.



--



-- (C) COPYRIGHT 2004 ALTERA CORPORATION



-- ALL RIGHTS RESERVED



--



-- The entire notice above must be reproduced on all authorized copies and any



-- such reproduction must be pursuant to a licensing agreement from Altera.



--



-- Title        : $header_title



-- Project      : DDR SDRAM Controller



--



-- File         : $header_filename



--



-- Revision     : $header_revision



--



-- Abstract:



-- Automatically generated testbench for the 'Example' top level design to allow



-- functional and timing simulation.



--



--------------------------------------------------------------------------------



--



-- *************** This is a MegaWizard generated file ****************



--



-- If you need to edit this file make sure the edits are not inside any 'MEGAWIZARD'



-- text insertion areas.



-- (between "<< START MEGAWIZARD INSERT" and "<< END MEGAWIZARD INSERT" comments)



--



-- Any edits inside these delimiters will be overwritten by the megawizard if you



-- re-run it.



--



-- If you really need to make changes inside these delimiters then delete



-- both 'START' and 'END' delimiters.  This will stop the megawizard updating this



-- section again.



--



------------------------------------------------------------------------------------



-- << START MEGAWIZARD INSERT PARAMETER_LIST



-- Parameters:



--



-- Device Family                      : $gFAMILY



-- local Interface Data Width         : $gLOCAL_DATA_BITS



-- MEM_CHIPSELS                       : $gMEM_CHIPSELS



-- MEM_BANK_BITS                      : $gMEM_BANK_BITS



-- MEM_ROW_BITS                       : $gMEM_ROW_BITS



-- MEM_COL_BITS                       : $gMEM_COL_BITS



-- LOCAL_DATA_BITS                    : $gLOCAL_DATA_BITS



-- NUM_CLOCK_PAIRS                    : $gNUM_CLOCK_PAIRS



-- RTL_ROUNDTRIP_CLOCKS               : $gRTL_ROUNDTRIP_CLOCKS



-- CLOCK_TICK_IN_PS                   : $gCLOCK_PERIOD_IN_PS



-- REGISTERED_DIMM                    : $gREG_DIMM



-- BOARD_DQS_DELAY                    : $gTPD_DQS_TRACE_TOTAL_NOM



-- BOARD_CLK_DELAY                    : $gTPD_CLOCK_TRACE_NOM



-- TINIT_CLOCKS                       : $gTINIT_CLOCKS



-- << END MEGAWIZARD INSERT PARAMETER_LIST



------------------------------------------------------------------------------------



-- << MEGAWIZARD PARSE FILE DDR${gWIZARD_VERSION}



HEADERZZ



}



sub vhdl_write_etb_portlist {



### DATAPATH PORTS ETC



if (($gFAMILY eq "Stratix") & ($gENABLE_CAPTURE_CLK ne "true")) {



$vhdl_etb_stratix_ref_clock=<<vhdl_etb_stratix_ref_clock



-- Stratix Only



        stratix_dqs_ref_clk   =>  stratix_dqs_ref_clk,      --Feeds the Straix "DQS phase Shift Reference Circuit"



                                                            --This port does not drive any logic inside the design.



        stratix_dqs_ref_clk_out   =>  stratix_dqs_ref_clk,



vhdl_etb_stratix_ref_clock



}



if ($gMEM_TYPE eq "ddr2_sdram") {



$vhdl_etb_ddr2_port_map=<<vhdl_etb_ddr2_port_map;



        ${gDDR_PREFIX_NAME}odt             => odt,



vhdl_etb_ddr2_port_map



$vhdl_dimm_ddr2_mode="TRUE";



} else {



$vhdl_dimm_ddr2_mode="FALSE";



}



if ($gFEDBACK_CLOCK_MODE eq "true") {



$vhdl_etb_fclk_port_map=<<vhdl_etb_fclk_port_map;



        fedback_clk   => fedback_clk,



vhdl_etb_fclk_port_map



$vhdl_etb_fclk_delay=<<vhdl_etb_fclk_delay;



    fedback_clk      <= transport clk_to_sdram($gNUM_CLOCK_PAIRS-1) after GATE_BOARD_FEDBACKCLK_DELAY * 1 ps;



vhdl_etb_fclk_delay



}



print ETB_OUT  <<PORTSZZ;



library ieee;



use ieee.std_logic_1164.all;



use ieee.std_logic_unsigned.all;



use ieee.numeric_std.all;



use std.textio.all;



library auk_ddr_user_lib;



use auk_ddr_user_lib.auk_ddr_tb_functions.all;



use auk_ddr_user_lib.all;



-- << START MEGAWIZARD INSERT ENTITY



entity ${gTOPLEVEL_NAME}_tb is



-- << END MEGAWIZARD INSERT ENTITY



    generic (



-- << START MEGAWIZARD INSERT GENERICS



        gMEM_CHIPSELS           : in integer := $gMEM_CHIPSELS;



        gMEM_BANK_BITS        : in integer := $gMEM_BANK_BITS;



        gMEM_ROW_BITS         : in integer := $gMEM_ROW_BITS;



        gMEM_COL_BITS         : in integer := $gMEM_COL_BITS;



        gLOCAL_DATA_BITS           : in integer := $gLOCAL_DATA_BITS;



        gNUM_CLOCK_PAIRS         : in integer := $gNUM_CLOCK_PAIRS;



        RTL_ROUNDTRIP_CLOCKS        : in real := $gRTL_ROUNDTRIP_CLOCKS;



        CLOCK_TICK_IN_PS            : in integer := $gCLOCK_PERIOD_IN_PS;



        REGISTERED_DIMM             : in boolean := $gREG_DIMM;



        BOARD_DQS_DELAY        : in integer := $gTPD_DQS_TRACE_TOTAL_NOM;



        BOARD_CLK_DELAY        : in integer := $gTPD_CLOCK_TRACE_NOM;



        BOARD_FEDBACKCLK_DELAY : in integer := $gTPD_CLOCKFEEDBACK_TRACE_NOM;



        TINIT_CLOCKS            : in integer := $gTINIT_CLOCKS;



-- << END MEGAWIZARD INSERT GENERICS



        RTL_DELAYS                : in integer := 1;  -- set to zero for Gatelevel



        USE_GENERIC_MEMORY_MODEL    : in boolean := FALSE;



        REF_CLOCK_TICK_IN_PS        : in integer := 30000



    );



end;



-- << START MEGAWIZARD INSERT ARCHITECTURE



architecture rtl of ${gTOPLEVEL_NAME}_tb is



-- << END MEGAWIZARD INSERT ARCHITECTURE



    -- delay the incoming DQ & DQS to mimick the SDRAM round trip delay



    --



    constant SAMPLE_DELAY : integer := integer( RTL_ROUNDTRIP_CLOCKS * real(CLOCK_TICK_IN_PS) * real(RTL_DELAYS) );  -- RTL only



    constant GATE_BOARD_DQS_DELAY  : integer := BOARD_DQS_DELAY * abs(RTL_DELAYS-1);            -- Gate level timing only



    constant GATE_BOARD_CLK_DELAY  : integer := BOARD_CLK_DELAY * abs(RTL_DELAYS-1);            -- Gate level timing only



    constant GATE_BOARD_FEDBACKCLK_DELAY  : integer := BOARD_FEDBACKCLK_DELAY * abs(RTL_DELAYS-1);            -- Gate level timing only



    signal cmd_bus_watcher_enabled  : std_logic := '0';



    signal   clk         : std_logic := '0';



    signal   clk_n       : std_logic := '1';



    signal   clk_shifted    : std_logic := '0';



    signal   reset_n        : std_logic;



    signal   a              : std_logic_vector(gMEM_ROW_BITS - 1 downto 0);



    signal   ba             : std_logic_vector(gMEM_BANK_BITS - 1 downto 0);



    signal   cs_n           : std_logic_vector(gMEM_CHIPSELS - 1 downto 0);



    signal   cke            : std_logic_vector(gMEM_CHIPSELS - 1 downto 0);



    signal   odt            : std_logic_vector(gMEM_CHIPSELS - 1 downto 0);



    signal   ras_n          : std_logic;



    signal   cas_n          : std_logic;



    signal   we_n           : std_logic;



    signal   dm             : std_logic_vector(gLOCAL_DATA_BITS/16-1 downto 0);



    signal   dqs            : std_logic_vector(gLOCAL_DATA_BITS/16-1 downto 0);



    signal   dq             : std_logic_vector(gLOCAL_DATA_BITS/2-1 downto 0);



    signal   datain         : std_logic_vector(gLOCAL_DATA_BITS-1 downto 0);



    signal   dataout        : std_logic_vector(gLOCAL_DATA_BITS-1 downto 0);



    -- override the "=" function because it doesn't work very well when comparing 'Z's



    function "=" (a, b : std_logic_vector) return boolean is



        variable a_bit, b_bit : std_logic;



        variable result : boolean;



    begin



        result := true;



        for i in a'reverse_range loop



            a_bit := a(i);



            b_bit := b(i);



            if (a_bit /= b_bit) then



                result := false;



            end if;



        end loop;



        return result;



    end; -- overridden "=" function



    signal stratix_dqs_ref_clk    : std_logic;  -- only used on stratix to provide external dll reference clock



    signal fedback_clk            : std_logic;  -- only used in fedback clock mode



    signal clk_to_sdram    : std_logic_vector(gNUM_CLOCK_PAIRS-1 downto 0);



    signal clk_to_sdram_n  : std_logic_vector(gNUM_CLOCK_PAIRS-1 downto 0);



    signal clk_to_ram      : std_logic;



    signal clk_to_ram_n    : std_logic;



    signal a_delayed       : std_logic_vector(gMEM_ROW_BITS - 1 downto 0);



    signal ba_delayed      : std_logic_vector(gMEM_BANK_BITS - 1 downto 0);



    signal cke_delayed     : std_logic_vector(gMEM_CHIPSELS - 1 downto 0);



    signal odt_delayed     : std_logic_vector(gMEM_CHIPSELS - 1 downto 0);



    signal cs_n_delayed    : std_logic_vector(gMEM_CHIPSELS - 1 downto 0);



    signal ras_n_delayed   : std_logic;



    signal cas_n_delayed   : std_logic;



    signal we_n_delayed    : std_logic;



    signal dm_delayed      : std_logic_vector(gLOCAL_DATA_BITS / 16 - 1 downto 0);



    signal fpga_dq        : std_logic_vector(gLOCAL_DATA_BITS / 2 - 1 downto 0) := (others => 'Z');



    signal mem_dq         : std_logic_vector(gLOCAL_DATA_BITS / 2 - 1 downto 0) := (others => 'Z');



    signal fpga_dqs       : std_logic_vector(gLOCAL_DATA_BITS / 16 - 1 downto 0) := (others => 'Z');



    signal mem_dqs        : std_logic_vector(gLOCAL_DATA_BITS / 16 - 1 downto 0) := (others => 'Z');



    signal dq_lock         : std_logic := 'Z';



    signal dqs_lock        : std_logic := 'Z';



    signal all_dq_z        : std_logic_vector(gLOCAL_DATA_BITS / 2 - 1 downto 0) := (others => 'Z');



    signal all_dqs_z       : std_logic_vector(gLOCAL_DATA_BITS / 16 - 1 downto 0) := (others => 'Z');



    signal zero_one        : std_logic_vector(gMEM_BANK_BITS - 1 downto 0) := (0 => '1', others => '0'); --"01";



    signal test_complete   : std_logic;



    -- counter to count the number of sucessful read and write loops



    signal test_complete_count : integer;



    signal pnf             : std_logic;



    signal pnf_per_byte    : std_logic_vector(gLOCAL_DATA_BITS/8 - 1 downto 0);



    signal clk_to_buf       : std_logic;



    signal clk_from_buf     : std_logic;



begin



-- << START MEGAWIZARD INSERT DUT_INSTANCE_NAME



dut : entity ${gTOPLEVEL_NAME}



-- << END MEGAWIZARD INSERT DUT_INSTANCE_NAME



    port map



    (



        -- clocks and reset



        clock_source    =>  clk,          -- (All..)              PLD input clock source from which all clocks are derived.



        clk_to_sdram    =>  clk_to_sdram, --                                           --



        clk_to_sdram_n  =>  clk_to_sdram_n,



        reset_n         => reset_n,



-- << START MEGAWIZARD INSERT PORT_MAP



$vhdl_etb_stratix_ref_clock



$vhdl_etb_fclk_port_map



        -- ddr sdram interface



$vhdl_etb_ddr2_port_map



        ${gDDR_PREFIX_NAME}cke             => cke,



        ${gDDR_PREFIX_NAME}cs_n            => cs_n,



        ${gDDR_PREFIX_NAME}ras_n           => ras_n,



        ${gDDR_PREFIX_NAME}cas_n           => cas_n,



        ${gDDR_PREFIX_NAME}we_n            => we_n,



        ${gDDR_PREFIX_NAME}ba              => ba,



        ${gDDR_PREFIX_NAME}a               => a,



        ${gDDR_PREFIX_NAME}dq              => fpga_dq,



        ${gDDR_PREFIX_NAME}dqs             => fpga_dqs,



        ${gDDR_PREFIX_NAME}dm              => dm,



-- << END MEGAWIZARD INSERT PORT_MAP



        test_complete   => test_complete,



        pnf_per_byte    => pnf_per_byte,



        pnf             => pnf



    );



--generic dimm model



    memory : entity generic_ddr_dimm_model



        generic map



        (



            DIMM_ADDR_BITS => gMEM_ROW_BITS,



            DIMM_DATA_BITS => gLOCAL_DATA_BITS / 2,



            DIMM_COL_BITS  => gMEM_COL_BITS,



            DIMM_BANK_BITS => gMEM_BANK_BITS,



            DIMM_CHIP_SELS => gMEM_CHIPSELS,



            DENALI  => FALSE,



            DDR2    => $vhdl_dimm_ddr2_mode,



            DISABLE_TIMING_CHECK => TRUE,



            GENERIC_MODEL   => USE_GENERIC_MEMORY_MODEL,



            registered     => REGISTERED_DIMM,



            memory_spec    => "./generic_ddr_sdram.soma"  -- .e.g



        )



        port map



        (



            clk      => clk_to_ram,



            clk_n    => clk_to_ram_n,



            dq       => mem_dq,



            dqs      => mem_dqs,



            dm       => dm,



            addr     => a_delayed,



            ba       => ba_delayed,



            cke      => cke_delayed,



            odt      => odt_delayed,  -- ddr2 only



            cs_n     => cs_n_delayed,



            ras_n    => ras_n_delayed,



            cas_n    => cas_n_delayed,



            we_n     => we_n_delayed



        );



    process



    begin



       clk <= '0';



       clk_n <= '1';



       while (true) loop



           --wait for 10 ns;



           wait for (REF_CLOCK_TICK_IN_PS/2) * 1 ps;







           clk <= not clk;



           clk_n <= not clk_n;







       end loop;



       wait;



    end process;



    clk_shifted     <=   transport clk_to_sdram(0)   after (CLOCK_TICK_IN_PS/4) * 3 * 1 ps;



    clk_to_ram      <= transport clk_to_sdram(0)   after GATE_BOARD_CLK_DELAY * 1 ps;



    clk_to_ram_n    <= NOT clk_to_ram;      -- mem model ignores clk_n ?







    -- << START MEGAWIZARD INSERT FEDBACK_CLOCK_DELAY



$vhdl_etb_fclk_delay







    -- << END MEGAWIZARD INSERT FEDBACK_CLOCK_DELAY



    process



    begin



        reset_n <= '0';



        wait until (clk_to_sdram(0)'event and clk_to_sdram(0) = '1');



        wait until (clk_to_sdram(0)'event and clk_to_sdram(0) = '1');



        wait until (clk_to_sdram(0)'event and clk_to_sdram(0) = '1');



        wait until (clk_to_sdram(0)'event and clk_to_sdram(0) = '1');



        wait until (clk_to_sdram(0)'event and clk_to_sdram(0) = '1');



        reset_n <= '1';



        wait;



    end process;



    -- control and data lines = 3 inches



    a_delayed       <=   transport a      after GATE_BOARD_CLK_DELAY * 1 ps + 1 ps;



    ba_delayed      <=   transport ba     after GATE_BOARD_CLK_DELAY * 1 ps + 1 ps;



    cke_delayed     <=   transport cke    after GATE_BOARD_CLK_DELAY * 1 ps + 1 ps;



    odt_delayed     <=   transport odt    after GATE_BOARD_CLK_DELAY * 1 ps + 1 ps;  -- ddr2 only



    cs_n_delayed    <=   transport cs_n   after GATE_BOARD_CLK_DELAY * 1 ps + 1 ps;



    ras_n_delayed   <=   transport ras_n  after GATE_BOARD_CLK_DELAY * 1 ps + 1 ps;







    cas_n_delayed   <=   transport cas_n  after GATE_BOARD_CLK_DELAY * 1 ps + 1 ps;



    we_n_delayed    <=   transport we_n   after GATE_BOARD_CLK_DELAY * 1 ps + 1 ps;







    dm_delayed      <=   transport dm     after GATE_BOARD_CLK_DELAY * 1 ps + 1 ps;



-- ---------------------------------------------------------------



    endit : process



    variable count          : integer := 0;



    variable ln : line;



    begin







        -- Stop simulation after test_complete or TINIT + 2000 clocks



        while ((count < (TINIT_CLOCKS+2000) ) and (test_complete /= '1')) loop







            count := count + 1;



            wait until clk_to_sdram(0)'event and clk_to_sdram(0) = '0';



        end loop;



        if (test_complete = '1') then



            if (pnf = '1') then



                write(ln, now);



                write(ln, string'("          --- SIMULATION PASSED --- "));



                writeline(output, ln);



                ASSERT false REPORT "--- SIMULATION PASSED ---" SEVERITY FAILURE ;



            else



                write(ln, now);



                write(ln, string'("          --- SIMULATION FAILED --- "));



                writeline(output, ln);



                ASSERT false REPORT "--- SIMULATION FAILED ---" SEVERITY FAILURE ;



            end if;



        else



                write(ln, now);



                write(ln, string'("          --- SIMULATION FAILED, DID NOT COMPLETE --- "));



                writeline(output, ln);



                ASSERT false REPORT "--- SIMULATION FAILED, DID NOT COMPLETE ---" SEVERITY FAILURE ;



        end if;



        wait;



    end process;



    process(clk_to_sdram(0), reset_n)



    begin



        if (reset_n = '0') then



            test_complete_count <= 0;



        elsif (clk_to_sdram(0)'event and clk_to_sdram(0) = '1') then



                if (test_complete = '1') then



                    test_complete_count <= test_complete_count + 1;



                end if;



        end if;



    end process;



-- ---------------------------------------------------------------



--******************************* DQ  ****************************







    process(mem_dq, dq_lock)



    begin







        if (dq_lock = '0') then



            fpga_dq <= transport mem_dq after (GATE_BOARD_DQS_DELAY + SAMPLE_DELAY)* 1 ps + 1 ps;



        end if;



    end process;



    process(fpga_dq, dq_lock)



    begin







        if (dq_lock = '1') then



            mem_dq <= transport fpga_dq after GATE_BOARD_DQS_DELAY * 1 ps + 1 ps;







        end if;



    end process;



    process(mem_dq, fpga_dq, dq_lock)



    begin



         if (mem_dq /= all_dq_z) and (fpga_dq = all_dq_z) and (dq_lock = 'Z') then



            dq_lock <= '0';



         elsif (mem_dq = all_dq_z) and (fpga_dq /= all_dq_z) and (dq_lock = 'Z') then



            dq_lock <= '1';



         elsif (mem_dq = all_dq_z) and (fpga_dq = all_dq_z) then



            dq_lock <= 'Z';



         end if;



    end process;



--******************************* DQ  ****************************



--******************************* DQS ****************************



    process(mem_dqs, dqs_lock)



    begin



        if (dqs_lock = '0') then



            fpga_dqs <= transport mem_dqs after ((GATE_BOARD_DQS_DELAY )+ SAMPLE_DELAY) * 1 ps + 1 ps;







        end if;



    end process;



    process(fpga_dqs, dqs_lock)



    begin



        if (dqs_lock = '1') then



            mem_dqs <= transport fpga_dqs after ((GATE_BOARD_DQS_DELAY)) * 1 ps + 1 ps;



        end if;



    end process;







    process(mem_dqs, fpga_dqs, dqs_lock)



    begin



         if (mem_dqs /= all_dqs_z) and (fpga_dqs = all_dqs_z) and (dqs_lock = 'Z') then







            dqs_lock <= '0';



         elsif (mem_dqs = all_dqs_z) and (fpga_dqs /= all_dqs_z) and (dqs_lock = 'Z') then



            dqs_lock <= '1';



         elsif (mem_dqs = all_dqs_z) and (fpga_dqs = all_dqs_z) then



            dqs_lock <= 'Z';



         end if;



    end process;



--******************************* DQS ****************************



    -- Watch the SDRAM command bus



    process (clk_to_ram)



        variable cmd_bus : std_logic_vector(2 downto 0);



        variable ln : line;



    begin



    if (clk_to_ram'event and clk_to_ram = '1') then



        if (TRUE) then



            cmd_bus := (ras_n_delayed, cas_n_delayed, we_n_delayed);



            case cmd_bus is



                when "000" =>       -- LMR command



                    write(ln, now);



                    if (ba_delayed = zero_one) then



                        write(ln, string'("          ELMR     settings = "));



                        if (a_delayed(0) = '0') then



                            write(ln, string'("DLL enable"));



                        end if;



                    else



                        write(ln, string'("          LMR      settings = "));



                        case a_delayed(2 downto 0) is



                            when "001" => write(ln, string'("BL = 2,"));



                            when "010" => write(ln, string'("BL = 4,"));



                            when "011" => write(ln, string'("BL = 8,"));



                            when others => write(ln, string'("BL = ??,"));



                        end case;



                        case a_delayed(6 downto 4) is



                            when "010" => write(ln, string'(" CL = 2.0,"));



                            when "110" => write(ln, string'(" CL = 2.5,"));



                            when "011" => write(ln, string'(" CL = 3.0,"));



                            when "100" => write(ln, string'(" CL = 4.0,"));



                            when "101" => write(ln, string'(" CL = 5.0,"));



                            when others => write(ln, string'(" CL = ??,"));



                        end case;



                        if (a_delayed(8) = '1') then



                            write(ln, string'(" DLL reset"));



                        end if;



                    end if;



                    writeline(output, ln);



                when "001" =>       -- ARF command



                    write(ln, now);



                    write(ln, string'("          ARF "));



                    writeline(output, ln);



                when "010" =>       -- PCH command



                    write(ln, now);



                    write(ln, string'("          PCH"));



                    if (a_delayed(10) = '1') then



                        write(ln, string'(" all banks "));



                    else



                        write(ln, string'(" bank "));



                        write(ln, auk_to_string(ba_delayed,16,gMEM_BANK_BITS));



                    end if;



                    writeline(output, ln);



                when "011" =>       -- ACT command



                    write(ln, now);



                    write(ln, string'("          ACT     row address "));



                    write(ln, auk_to_string(a_delayed,16,gMEM_ROW_BITS));



                    write(ln, string'(                               " bank "));







                    write(ln, auk_to_string(ba_delayed,16,gMEM_BANK_BITS));



                    writeline(output, ln);







                when "100" =>       -- WR command



                    write(ln, now);



                    write(ln, string'("          WR to   col address "));



                    write(ln, auk_to_string(a_delayed,16,gMEM_ROW_BITS));



                    write(ln, string'(                               " bank "));



                    write(ln, auk_to_string(ba_delayed,16,gMEM_BANK_BITS));



                    writeline(output, ln);







                when "101" =>       -- RD command



                    write(ln, now);



                    write(ln, string'("          RD from col address "));







                    write(ln, auk_to_string(a_delayed,16,gMEM_ROW_BITS));



                    write(ln, string'(                               " bank "));



                    write(ln, auk_to_string(ba_delayed,16,gMEM_BANK_BITS));



                    writeline(output, ln);



                when "110" =>       -- BT command



                    write(ln, now);



                    write(ln, string'("          BT "));



                    writeline(output, ln);



                when "111" => null; -- NOP command



                when others => null;



            end case;



        else



        end if; -- if enabled



    end if;



    end process;



end rtl;



PORTSZZ



}







sub verilog_write_etb_header {



### HEADER







$header_title = "Example top level testbench for $gWRAPPER_NAME DDR SDRAM Controller";



$header_filename = $gTOPLEVEL_NAME . "_tb" . $file_ext;



$header_revision = "V" . $gWIZARD_VERSION;



print ETB_OUT  <<HEADERZZ;



//------------------------------------------------------------------------------



// This confidential and proprietary software may be used only as authorized by







// a licensing agreement from Altera Corporation.



//







// (C) COPYRIGHT 2004 ALTERA CORPORATION



// ALL RIGHTS RESERVED



//



// The entire notice above must be reproduced on all authorized copies and any



// such reproduction must be pursuant to a licensing agreement from Altera.



//



// Title        : $header_title



// Project      : DDR SDRAM Controller



//



// File         : $header_filename



//



// Revision     : $header_revision



//



// Abstract:



// Automatically generated testbench for the 'Example' top level design to allow



// functional and timing simulation.



//



//------------------------------------------------------------------------------



//



// *************** This is a MegaWizard generated file ****************



//



// If you need to edit this file make sure the edits are not inside any 'MEGAWIZARD'



// text insertion areas.



// (between "<< START MEGAWIZARD INSERT" and "<< END MEGAWIZARD INSERT" comments)



//



// Any edits inside these delimiters will be overwritten by the megawizard if you



// re-run it.



//



// If you really need to make changes inside these delimiters then delete



// both 'START' and 'END' delimiters.  This will stop the megawizard updating this



// section again.



//



//----------------------------------------------------------------------------------



// << START MEGAWIZARD INSERT PARAMETER_LIST



// Parameters:



//



// Device Family                      : $gFAMILY







// local Interface Data Width         : $gLOCAL_DATA_BITS



// MEM_CHIPSELS                       : $gMEM_CHIPSELS







// MEM_BANK_BITS                      : $gMEM_BANK_BITS



// MEM_ROW_BITS                       : $gMEM_ROW_BITS



// MEM_COL_BITS                       : $gMEM_COL_BITS



// LOCAL_DATA_BITS                    : $gLOCAL_DATA_BITS



// NUM_CLOCK_PAIRS                    : $gNUM_CLOCK_PAIRS



// RTL_ROUNDTRIP_CLOCKS               : $gRTL_ROUNDTRIP_CLOCKS







// CLOCK_TICK_IN_PS                   : $gCLOCK_PERIOD_IN_PS



// REGISTERED_DIMM                    : $gREG_DIMM







// BOARD_DQS_DELAY                    : $gTPD_DQS_TRACE_TOTAL_NOM



// BOARD_CLK_DELAY                    : $gTPD_CLOCK_TRACE_NOM



// TINIT_CLOCKS                       : $gTINIT_CLOCKS



// << END MEGAWIZARD INSERT PARAMETER_LIST



//----------------------------------------------------------------------------------



// << MEGAWIZARD PARSE FILE DDR${gWIZARD_VERSION}



`timescale 1 ps/1 ps



HEADERZZ



}



sub verilog_write_etb_portlist {



### DATAPATH PORTS ETC



if (($gFAMILY eq "Stratix") & ($gENABLE_CAPTURE_CLK ne "true")) {



$verilog_etb_stratix_ref_clock=<<verilog_etb_stratix_ref_clock



        .stratix_dqs_ref_clk(stratix_dqs_ref_clk),







        .stratix_dqs_ref_clk_out(stratix_dqs_ref_clk),



verilog_etb_stratix_ref_clock







}



if ($gMEM_TYPE eq "ddr2_sdram") {



$verilog_etb_ddr2_port_map=<<verilog_etb_ddr2_port_map;



        .${gDDR_PREFIX_NAME}odt(odt),



verilog_etb_ddr2_port_map



}







if ($gFEDBACK_CLOCK_MODE eq "true") {



$verilog_etb_fclk_port_map=<<verilog_etb_fclk_port_map;







        .fedback_clk(fedback_clk),



verilog_etb_fclk_port_map



$verilog_etb_fclk_delay=<<verilog_etb_fclk_delay;



    assign fedback_clk = clk_to_sdram[$gNUM_CLOCK_PAIRS-1];



verilog_etb_fclk_delay



}



$RTL_ROUNDTRIP_90DEGS=0;



$RTL_ROUNDTRIP_90DEGS = $gRTL_ROUNDTRIP_CLOCKS * 4;



print ETB_OUT  <<PORTSZZ;



// << START MEGAWIZARD INSERT MODULE



module ${gTOPLEVEL_NAME}_tb ();



// << END MEGAWIZARD INSERT MODULE



    // << START MEGAWIZARD INSERT PARAMS



    parameter gMEM_CHIPSELS  = $gMEM_CHIPSELS;



    parameter gMEM_BANK_BITS  = $gMEM_BANK_BITS;



    parameter gMEM_ROW_BITS  = $gMEM_ROW_BITS;



    parameter gMEM_COL_BITS  = $gMEM_COL_BITS;



    parameter gLOCAL_DATA_BITS  = $gLOCAL_DATA_BITS;



    parameter gNUM_CLOCK_PAIRS  = $gNUM_CLOCK_PAIRS;



    parameter RTL_ROUNDTRIP_CLOCKS  = $gRTL_ROUNDTRIP_CLOCKS;



    parameter CLOCK_TICK_IN_PS  = $gCLOCK_PERIOD_IN_PS;



    parameter REGISTERED_DIMM  = 1'b0;



    parameter BOARD_DQS_DELAY  = $gTPD_DQS_TRACE_TOTAL_NOM;



    parameter BOARD_CLK_DELAY  = $gTPD_CLOCK_TRACE_NOM;



    parameter BOARD_FEDBACKCLK_DELAY  = $gTPD_CLOCKFEEDBACK_TRACE_NOM;



    parameter TINIT_CLOCKS  = $gTINIT_CLOCKS;



    // << END MEGAWIZARD INSERT PARAMS



    // set to zero for Gatelevel



    parameter RTL_DELAYS = 1;



    parameter USE_GENERIC_MEMORY_MODEL  = 1'b0;



    parameter REF_CLOCK_TICK_IN_PS  = 30000;



    // delay the incoming DQ & DQS to mimick the SDRAM round trip delay



    //



    parameter D90_DEG_DELAY = CLOCK_TICK_IN_PS / 4; // RTL only



    parameter GATE_BOARD_DQS_DELAY = BOARD_DQS_DELAY * (RTL_DELAYS ? 0 : 1); // Gate level timing only



    parameter GATE_BOARD_CLK_DELAY = BOARD_CLK_DELAY * (RTL_DELAYS ? 0 : 1); // Gate level timing only



    parameter GATE_BOARD_FEDBACKCLK_DELAY = BOARD_FEDBACKCLK_DELAY * (RTL_DELAYS ? 0 : 1); // Gate level timing only



    wire cmd_bus_watcher_enabled;



    reg clk;



    reg clk_n;



    wire #((CLOCK_TICK_IN_PS / 4) * 3 * 1) clk_shifted;



    reg reset_n;



    wire[gMEM_ROW_BITS - 1:0] a;



    wire[gMEM_BANK_BITS - 1:0] ba;



    wire[gMEM_CHIPSELS - 1:0] cs_n;



    wire[gMEM_CHIPSELS - 1:0] cke;



    wire[gMEM_CHIPSELS - 1:0] odt;       //DDR2 only



    wire ras_n;



    wire cas_n;



    wire we_n;



    wire[gLOCAL_DATA_BITS / 16 - 1:0] dm;



    wire[gLOCAL_DATA_BITS / 16 - 1:0] dqs;



    wire[gLOCAL_DATA_BITS / 2 - 1:0] dq;



    wire[gLOCAL_DATA_BITS - 1:0] datain;



    wire[gLOCAL_DATA_BITS - 1:0] dataout;



    wire stratix_dqs_ref_clk;   // only used on stratix to provide external dll reference clock



    wire #(GATE_BOARD_FEDBACKCLK_DELAY * 1) fedback_clk;           // only used in fedback clock mode



    wire[gNUM_CLOCK_PAIRS - 1:0] clk_to_sdram;



    wire[gNUM_CLOCK_PAIRS - 1:0] clk_to_sdram_n;



    wire #(GATE_BOARD_CLK_DELAY * 1) clk_to_ram;



    wire clk_to_ram_n;



    wire[gMEM_ROW_BITS - 1:0] #(GATE_BOARD_CLK_DELAY * 1 + 1) a_delayed;



    wire[gMEM_BANK_BITS - 1:0] #(GATE_BOARD_CLK_DELAY * 1 + 1) ba_delayed;



    wire[gMEM_CHIPSELS - 1:0] #(GATE_BOARD_CLK_DELAY * 1 + 1) cke_delayed;



    wire[gMEM_CHIPSELS - 1:0] #(GATE_BOARD_CLK_DELAY * 1 + 1) odt_delayed;  //DDR2 only



    wire[gMEM_CHIPSELS - 1:0] #(GATE_BOARD_CLK_DELAY * 1 + 1) cs_n_delayed;



    wire #(GATE_BOARD_CLK_DELAY * 1 + 1) ras_n_delayed;



    wire #(GATE_BOARD_CLK_DELAY * 1 + 1) cas_n_delayed;



    wire #(GATE_BOARD_CLK_DELAY * 1 + 1) we_n_delayed;



    wire[gLOCAL_DATA_BITS / 16 - 1:0] #(GATE_BOARD_CLK_DELAY * 1 + 1) dm_delayed;



    tri [gLOCAL_DATA_BITS / 2 - 1:0] fpga_dq = 100'bz;



    wire [gLOCAL_DATA_BITS / 2 - 1:0] fpga_dq_int = 100'bz;



    wire [gLOCAL_DATA_BITS / 2 - 1:0] fpga_dq_int0 = 100'bz;



    wire [gLOCAL_DATA_BITS / 2 - 1:0] fpga_dq_int1 = 100'bz;



    wire [gLOCAL_DATA_BITS / 2 - 1:0] fpga_dq_int2 = 100'bz;



    wire [gLOCAL_DATA_BITS / 2 - 1:0] fpga_dq_int3 = 100'bz;



    wire [gLOCAL_DATA_BITS / 2 - 1:0] fpga_dq_int4 = 100'bz;



    wire [gLOCAL_DATA_BITS / 2 - 1:0] fpga_dq_int5 = 100'bz;



    tri [gLOCAL_DATA_BITS / 16 - 1:0] fpga_dqs = 100'bz;



    wire [gLOCAL_DATA_BITS / 16 - 1:0] fpga_dqs_int = 100'bz;



    wire [gLOCAL_DATA_BITS / 16 - 1:0] fpga_dqs_int0 = 100'bz;



    wire [gLOCAL_DATA_BITS / 16 - 1:0] fpga_dqs_int1 = 100'bz;



    wire [gLOCAL_DATA_BITS / 16 - 1:0] fpga_dqs_int2 = 100'bz;



    wire [gLOCAL_DATA_BITS / 16 - 1:0] fpga_dqs_int3 = 100'bz;



    wire [gLOCAL_DATA_BITS / 16 - 1:0] fpga_dqs_int4 = 100'bz;



    wire [gLOCAL_DATA_BITS / 16 - 1:0] fpga_dqs_int5 = 100'bz;



    tri [gLOCAL_DATA_BITS / 2 - 1:0] mem_dq = 100'bz;



    tri [gLOCAL_DATA_BITS / 16 - 1:0] mem_dqs = 100'bz;



    reg dqs_oe = 1'b0;



    reg dqs_active = 1'b0;



    reg dq_oe = 1'b0;



    reg dq_active = 1'b0;



    reg dq_lock;



    reg dqs_lock;



    wire[gLOCAL_DATA_BITS / 2 - 1:0] all_dq_z = 100'bz;



    wire[gLOCAL_DATA_BITS / 16 - 1:0] all_dqs_z = 100'bz;



    wire[gMEM_BANK_BITS - 1:0] zero_one; //"01";



    wire test_complete;



    // counter to count the number of sucessful read and write loops



    integer test_complete_count;



    wire pnf;



    wire[gLOCAL_DATA_BITS / 8 - 1:0] pnf_per_byte;



    wire clk_to_buf;



    wire clk_from_buf;



    assign cmd_bus_watcher_enabled = 1'b0;



   // ddr sdram interface



    // << START MEGAWIZARD INSERT ENTITY



    ${gTOPLEVEL_NAME} dut (



    // << END MEGAWIZARD INSERT ENTITY



        .clock_source(clk),



        .clk_to_sdram(clk_to_sdram),



        .clk_to_sdram_n(clk_to_sdram_n),



        .reset_n(reset_n),



        // << START MEGAWIZARD INSERT PORT_MAP



$verilog_etb_stratix_ref_clock



$verilog_etb_fclk_port_map



$verilog_etb_ddr2_port_map



        .${gDDR_PREFIX_NAME}cke(cke),



        .${gDDR_PREFIX_NAME}cs_n(cs_n),



        .${gDDR_PREFIX_NAME}ras_n(ras_n),



        .${gDDR_PREFIX_NAME}cas_n(cas_n),



        .${gDDR_PREFIX_NAME}we_n(we_n),



        .${gDDR_PREFIX_NAME}ba(ba),



        .${gDDR_PREFIX_NAME}a(a),



        .${gDDR_PREFIX_NAME}dq(fpga_dq),



        .${gDDR_PREFIX_NAME}dqs(fpga_dqs),



        .${gDDR_PREFIX_NAME}dm(dm),







        // << END MEGAWIZARD INSERT PORT_MAP



        .test_complete(test_complete),







        .pnf_per_byte(pnf_per_byte),



        .pnf(pnf));



    // << START MEGAWIZARD INSERT MEMORY_ARRAY



    // Instantiate an array of 8-bit DDR memories to match the datawidth & chipselect requirements



    // This will need updating to match the memory models you are using.



PORTSZZ







for ($i=0; $i < $gMEM_CHIPSELS; $i++) {



    for ($j=0; $j < $gLOCAL_DATA_BITS / 2 / $gMEM_DQ_PER_DQS ; $j++) {







if ($gMEM_TYPE eq "ddr2_sdram") {



print ETB_OUT  <<PORTSZZ;



    generic_ddr2_sdram_rtl memory_${i}_${j} (



        .DQ    (mem_dq[8* ($j+1) - 1 : 8 * $j]),



        .DQS   (mem_dqs[$j]),



        .ADDR  (a_delayed[$gMEM_ROW_BITS-1: 0]),



//        .ADDR  (a_delayed[11: 0]),



        .BA    (ba_delayed),



        .CLK   (clk_to_ram),



        .CLK_N (clk_to_ram_n),



        .CKE   (cke_delayed[$i]),



        .CS_N  (cs_n_delayed[$i]),



        .RAS_N (ras_n_delayed),



        .CAS_N (cas_n_delayed),







        .WE_N  (we_n_delayed),



        .DM_RDQS    (dm_delayed[$j]),







        .ODT    (odt_delayed)



//        .RDQS_N(),



//        .DQS_N  (1'b0)



    );



    defparam memory_${i}_${j}.BANKBITS = gMEM_BANK_BITS;



    defparam memory_${i}_${j}.ROWBITS = gMEM_ROW_BITS;







    defparam memory_${i}_${j}.COLBITS = gMEM_COL_BITS;



    defparam memory_${i}_${j}.DATABITS = 8;







PORTSZZ



} else {



print ETB_OUT  <<PORTSZZ;



    generic_ddr_sdram_rtl memory_${i}_${j} (



        .Dq    (mem_dq[8* ($j+1) - 1 : 8 * $j]),



        .Dqs   (mem_dqs[$j]),



//        .Addr  (a_delayed[$gMEM_ROW_BITS-1: 0]),



        .Addr  (a_delayed[11: 0]),



        .Ba    (ba_delayed),



        .Clk   (clk_to_ram),



        .Clk_n (clk_to_ram_n),



        .Cke   (cke_delayed[$i]),



        .Cs_n  (cs_n_delayed[$i]),



        .Ras_n (ras_n_delayed),



        .Cas_n (cas_n_delayed),



        .We_n  (we_n_delayed),



        .Dm    (dm_delayed[$j])



    );



PORTSZZ



}



    }



}



print ETB_OUT  <<PORTSZZ;



    // << END MEGAWIZARD INSERT MEMORY_ARRAY



    always



    begin



        clk <= 1'b0 ;



        clk_n <= 1'b1 ;



        while (1'b1)



        begin



            #((REF_CLOCK_TICK_IN_PS / 2) * 1);







            clk <= ~clk ;



            clk_n <= ~clk_n ;







        end



    end



    assign clk_shifted = clk_to_sdram[0] ;



    assign clk_to_ram = clk_to_sdram[0] ;



    assign clk_to_ram_n = ~clk_to_ram ; // mem model ignores clk_n ?



    // << START MEGAWIZARD INSERT FEDBACK_CLOCK_DELAY







$verilog_etb_fclk_delay



    // << END MEGAWIZARD INSERT FEDBACK_CLOCK_DELAY







    initial



    begin



        reset_n <= 1'b0 ;



        @(clk_to_sdram[0]);



        @(clk_to_sdram[0]);



        @(clk_to_sdram[0]);



        @(clk_to_sdram[0]);



        @(clk_to_sdram[0]);



        reset_n <= 1'b1 ;



    end



    // control and data lines = 3 inches



    assign a_delayed = a ;



    assign ba_delayed = ba ;



    assign cke_delayed = cke ;



    assign odt_delayed = odt ;



    assign cs_n_delayed = cs_n ;



    assign ras_n_delayed = ras_n ;



    assign cas_n_delayed = cas_n ;



    assign we_n_delayed = we_n ;







    assign dm_delayed = dm ;



    // ---------------------------------------------------------------







    initial



    begin : endit



        integer count;



        reg ln;



        count = 0;



        // Stop simulation after test_complete or TINIT + 2000 clocks







        while ((count < (TINIT_CLOCKS + 2000)) & (test_complete !== 1))



        begin







            count = count + 1;



            @(negedge clk_to_sdram[0]);



        end



        if (test_complete === 1)



        begin



            if (pnf)



            begin



                \$write(\$time);



                \$write("          --- SIMULATION PASSED --- ");



                \$stop;



            end



            else



            begin



                \$write(\$time);



                \$write("          --- SIMULATION FAILED --- ");



                \$stop;



            end



        end



        else



        begin



            \$write(\$time);



            \$write("          --- SIMULATION FAILED, DID NOT COMPLETE --- ");



            \$stop;



        end



    end



    always @(clk_to_sdram[0] or reset_n)



    begin



        if (!reset_n)



        begin



            test_complete_count <= 0 ;



        end



        else if ((clk_to_sdram[0]))



        begin



            if (test_complete)



            begin



                test_complete_count <= test_complete_count + 1 ;



            end



        end



    end



    assign #((GATE_BOARD_DQS_DELAY) + 1) fpga_dq_int = (dq_oe) ? mem_dq : all_dq_z;   // This is effectively the read dir so it should have 90 deg added



    assign                  fpga_dq_int0 = fpga_dq_int;



    assign #(D90_DEG_DELAY) fpga_dq_int1 = fpga_dq_int;



    assign #(D90_DEG_DELAY) fpga_dq_int2 = fpga_dq_int1;



    assign #(D90_DEG_DELAY) fpga_dq_int3 = fpga_dq_int2;



    assign #(D90_DEG_DELAY) fpga_dq_int4 = fpga_dq_int3;



    assign #(D90_DEG_DELAY) fpga_dq_int5 = fpga_dq_int4;



    assign #(D90_DEG_DELAY) fpga_dq_int6 = fpga_dq_int5;



    assign #(D90_DEG_DELAY) fpga_dq_int7 = fpga_dq_int6;



    // << START MEGAWIZARD INSERT DQ_DELAYS



    assign fpga_dq = RTL_DELAYS ? fpga_dq_int${RTL_ROUNDTRIP_90DEGS} : fpga_dq_int;



    // << END MEGAWIZARD INSERT DQ_DELAYS



    assign #((GATE_BOARD_DQS_DELAY * 1 + 1)) mem_dq = (~dq_oe) ? fpga_dq: all_dq_z;



    always@(mem_dq or fpga_dq or dq_active)



    begin



        if ((mem_dq !== all_dq_z) && (dq_active == 1'b0) )



        begin



            dq_active = 1'b1;



            dq_oe = 1'b1;



        end



        if ((fpga_dq !== all_dq_z) && (dq_active == 1'b0))



        begin



            dq_active = 1'b1;



            dq_oe = 1'b0;



        end



        if ((mem_dq === all_dq_z) && (fpga_dq === all_dq_z))



        begin



            dq_active = 1'b0;



        end



    end



    assign #(GATE_BOARD_DQS_DELAY + 1) fpga_dqs_int = (dqs_oe) ? mem_dqs : all_dqs_z;   // This is effectively the read dir so it should have 90 deg added



    assign                  fpga_dqs_int0 = fpga_dqs_int;



    assign #(D90_DEG_DELAY) fpga_dqs_int1 = fpga_dqs_int;



    assign #(D90_DEG_DELAY) fpga_dqs_int2 = fpga_dqs_int1;







    assign #(D90_DEG_DELAY) fpga_dqs_int3 = fpga_dqs_int2;



    assign #(D90_DEG_DELAY) fpga_dqs_int4 = fpga_dqs_int3;







    assign #(D90_DEG_DELAY) fpga_dqs_int5 = fpga_dqs_int4;



    assign #(D90_DEG_DELAY) fpga_dqs_int6 = fpga_dqs_int5;



    assign #(D90_DEG_DELAY) fpga_dqs_int7 = fpga_dqs_int6;



    // << START MEGAWIZARD INSERT DQS_DELAYS



    assign fpga_dqs = RTL_DELAYS ? fpga_dqs_int${RTL_ROUNDTRIP_90DEGS} : fpga_dqs_int;



    // << END MEGAWIZARD INSERT DQS_DELAYS







    assign #(((GATE_BOARD_DQS_DELAY)) * 1 + 1) mem_dqs = (~dqs_oe) ? fpga_dqs: all_dqs_z;



    always@(mem_dqs or fpga_dqs or dqs_active)







    begin



        if ((mem_dqs !== all_dqs_z) && (dqs_active == 1'b0) )



        begin



            dqs_active = 1'b1;



            dqs_oe = 1'b1;



        end



        if ((fpga_dqs !== all_dqs_z) && (dqs_active == 1'b0))



        begin



            dqs_active = 1'b1;



            dqs_oe = 1'b0;



        end



        if ((mem_dqs === all_dqs_z) && (fpga_dqs === all_dqs_z))



        begin



            dqs_active = 1'b0;



        end



    end



    reg[2:0] cmd_bus;



    reg ln_;



    //******************************* DQS ****************************



    // Watch the SDRAM command bus







    always @(clk_to_ram)



    begin







        if (clk_to_ram)



        begin



            if (1'b1)



            begin



                cmd_bus = {ras_n_delayed, cas_n_delayed, we_n_delayed};



                case (cmd_bus)







                    3'b000 :



                        begin







                            // LMR command



                            \$write(\$time);



                            if (ba_delayed == zero_one)



                            begin



                                \$write("          ELMR     settings = ");



                                if (!(a_delayed[0]))



                                begin



                                    \$write("DLL enable");



                                end



                            end



                            else



                            begin



                                \$write("          LMR      settings = ");



                                case (a_delayed[2:0])



                                    3'b001 :



                                        begin



                                            \$write("BL = 2,");



                                        end



                                    3'b010 :



                                        begin



                                            \$write("BL = 4,");



                                        end



                                    3'b011 :



                                        begin



                                            \$write("BL = 8,");



                                        end



                                    default :



                                        begin



                                            \$write("BL = ??,");



                                        end



                                endcase







                                case (a_delayed[6:4])



                                    3'b010 :







                                        begin



                                            \$write(" CL = 2.0,");



                                        end



                                    3'b110 :



                                        begin



                                            \$write(" CL = 2.5,");







                                        end



                                    3'b011 :







                                        begin



                                            \$write(" CL = 3.0,");



                                        end



                                    3'b100 :



                                        begin



                                            \$write(" CL = 4.0,");



                                        end



                                    3'b101 :



                                        begin



                                            \$write(" CL = 5.0,");



                                        end



                                    default :



                                        begin



                                            \$write(" CL = ??,");



                                        end



                                endcase



                                if ((a_delayed[8]))



                                begin



                                    \$write(" DLL reset");







                                end



                            end







                            \$write("\\n");



                        end



                    3'b001 :



                        begin



                            // ARF command



                            \$write(\$time);







                            \$write("          ARF\\n");



                        end



                    3'b010 :







                        begin



                            // PCH command



                            \$write(\$time);



                            \$write("          PCH");



                            if ((a_delayed[10]))



                            begin



                                \$write(" all banks \\n");



                            end



                            else



                            begin



                                \$write(" bank ");



                                \$write("%H\\n", ba_delayed);



                            end



                        end



                    3'b011 :



                        begin



                            // ACT command



                            \$write(\$time);



                            \$write("          ACT     row address ");



                            \$write("%H", a_delayed);



                            \$write(" bank ");



                            \$write("%H\\n", ba_delayed);



                        end



                   3'b100 :



                        begin



                            // WR command



                            \$write(\$time);



                            \$write("          WR to   col address ");



                            \$write("%H", a_delayed);



                            \$write(" bank ");



                            \$write("%H\\n", ba_delayed);



                        end



                   3'b101 :



                        begin



                            // RD command



                            \$write(\$time);



                            \$write("          RD from col address ");



                            \$write("%H", a_delayed);



                            \$write(" bank ");



                            \$write("%H\\n", ba_delayed);



                        end



                   3'b110 :



                        begin



                            // BT command



                            \$write(\$time);



                            \$write("          BT ");



                        end



                   3'b111 :



                        begin



                            // NOP command



                        end



                endcase



            end



            else



            begin



            end // if enabled



        end



    end



endmodule



PORTSZZ



}



