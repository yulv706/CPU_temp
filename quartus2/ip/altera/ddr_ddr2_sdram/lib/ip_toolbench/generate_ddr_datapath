#! /usr/bin/perl
#! /usr/local/bin/perl

#
# Simulation run script
#
# (c) Copyright 2006, Altera
#     All Rights Reserved
#
#
# $Revision: #1 $
#

#use Env;
#use File::Copy;

use write_ddr_sdram_controller;
use write_example_instance;
sub usage {
    print <<USAGE;
Usage:
   Genarates DDR datapath files from a list of generics.
Options:
   -s <file_name>          XX file to be read
   -o <output_directory_name> file output directory
   -f <file_name>          reads the command line options from the file
   -gxyz=1234              sets the generic(parameter) 'xyz' to value '1234'
   <test_name>             runs the <test_name> simulation
   -h                      Prints this help
Supported Generics

------------------
Name                       values

===============================================
FAMILY                              : in string := Cyclone;
LOCAL_DATA_BITS                     : in integer := 32;
MEM_DQ_PER_DQS                      : integer := 8;         -- no. of DQ bits per DQS/DM, generally 8 or 32
MEM_CHIP_BITS                       : in integer := 0;
LOCAL_AVALON_IF                     : string := "false";

MEM_CHIPSELS                        : in integer := 1;
MEM_BANK_BITS                       : in integer := 2;

MEM_ROW_BITS                        : in integer := 12;
MEM_COL_BITS                        : in integer := 10;
MEM_PCH_BIT                         : in integer := 10;
MEM_ODT_RANKS                       : in integer := 0;
LOCAL_BURST_LEN                     : in integer := 1;
LOCAL_BURST_LEN_BITS                : in integer := 1;
USER_REFRESH                        : in string := "false";
ENABLE_CAPTURE_CLK                  : string  := "false";   -- Whether or not to use an external capture clock
ENABLE_RESYNCH_CLK                  : string  := "true";    -- Whether or not to use an external resynch clock
CHOSEN_RESYNCH_EDGE                        : string  := "rising";  -- rising, falling
CHOSEN_POSTAMBLE_EDGE                      : string  := "rising";  -- rising, falling
CHOSEN_POSTAMBLE_CYCLE                     : integer := 0;         -- 0,1,2
INTER_RESYNCH                       : string  := "false";   -- Insert extra negedge sys_clk resynch register in the data path
INTER_POSTAMBLE                     : string  := "false";   -- Insert extra negedge sys_clk postamble register in the data path
PIPELINE_READDATA                   : string  := "false";   -- Insert pipeline registers to reclock the output of the resynch registers to the posedge
ENABLE_POSTAMBLE_LOGIC              : string  := "true";    -- Whether or not to insert the logic to control the capture registers, particularly important during the DQS postamble
POSTAMBLE_REGS                      : integer := 2          -- Number of regs feeding the inclocken of the capture registers
STRATIX_UNDELAYEDDQSOUT_INSERT_BUFFERS  : integer := 0
CONNECT_RESYNCH_CLK_TO              : in string := "clk";
CONNECT_POSTAMBLE_CLK_TO            : in string := "clk"
CONNECT_CAPTURE_CLK_TO		    : in string := "clk";
CLOCK_PERIOD_IN_PS                  : integer := 10000;
NUM_CLOCK_PAIRS                     : in integer := 1;
DQS_PHASE_SHIFT                     : integer := 90;
RTL_ROUNDTRIP_CLOCKS                : integer := 0;
TOPLEVEL_NAME                       : string := "stratixii_verilog";
WRAPPER_NAME                        : string := "wrapper";
DDR_PREFIX_NAME                     : string := "ddr_";
BUFFER_DLL_DELAY_OUTPUT             : string := "false";
PARSE_EXAMPLE_DESIGN                : string := "true";
TESTBENCH_USE_VECTOR	            : string := "true";
DQS_CRAM_CYCLONE		    : integer := 0;
CLOCKFEEDBACK_IN_PIN_NAME	    : string := "fedback_clock_in";
CLOCK_POS_PIN_NAME		    : string := "clk_to_sdram[0]";
CLOCK_NEG_PIN_NAME		    : string := "clk_to_sdram_n[0]";
EXTRA_PL_REG			    : string := "true";
NEGEDGE_ADDRCMD			    : string := "true";

USAGE
    exit(1);
}
#Usage: $0 [-d -sn -den -cov -cm -gui -f <test_list_file>] <test_name>

sub handler {
        local ($sig) = @_;

        print "Caught a SIG$sig -- shutting down\n";
        close(LOG);
        exit($sig);
}
#sub system_trap {
#    local(@args) = @_;  # List of arguments

#    $rc = system(@args);
#    if ($rc!=0) {

#      $where = `pwd`;
#      if ($rc==512) {
#        die "command @args was interrupted - quitting";
#      } elsif ($rc==256) {
#        die "command @args exited with an error in $where";
#      } else {
#        die "command @args failed to run in $where : $?";
#      }
#    }
#};
$SIG{INT}= 'handler';
$SIG{QUIT}= 'handler';
$tool = "run_sim";
$command = $tool;

#$work_base =`pwd`;
$work_base = "/dummy_path/";

chomp ($work_base);
$::language               = "vhdl";
$::quartus_version        = "4.1";
$::gMEM_TYPE               = "ddr_sdram";
$::gFAMILY                 = "Stratix";  #-- Stratix, Stratix GX and Cyclone
$::gFAMILYlc               = "stratix";  #-- Stratix, Stratix GX and Cyclone
$::gpllFAMILY              = "stratix";  #-- Stratix, Stratix GX and Cyclone
$::gIS_HARDCOPY2           = "false";    # Required because we munge gFAMILY to be Stratix II in the case of HC2
$::gLOCAL_DATA_BITS        = 32;        # local data bus width
$::gMEM_DQ_PER_DQS         = 8;         #-- no. of DQ bits per DQS/DM, generally 8 or 32

$::gMEM_CHIP_BITS          = 1;         #
$::gLEGAL_MEM_CHIP_BITS    = 1;         #
$::gENABLE_CAPTURE_CLK     = "false";   #-- Whether or not to use an external capture clock
$::gENABLE_RESYNCH_CLK     = "true";    #-- Whether or not to use an external resynch clock
$::gRESYNCH_EDGE           = "rising";  #-- rising, falling
$::gPOSTAMBLE_EDGE         = "rising";  #-- rising, falling
$::gPOSTAMBLE_CYCLE        = 0;         #-- 0,1,2
$::gINTER_RESYNCH          = "false";   #-- Insert extra negedge sys_clk resynch register in the data path
$::gINTER_POSTAMBLE        = "false";   #-- Insert extra negedge sys_clk postamble register in the data path
$::gPIPELINE_READDATA      = "false";   #-- Insert pipeline registers to reclock the output of the resynch registers to the posedge
$::gREG_DIMM               = "false";   #-- Registered DIMM mode for testbench
$::gENABLE_POSTAMBLE_LOGIC = "true";    #-- Whether or not to insert the logic to control the capture registers, particularly important during the DQS postamble
$::gPOSTAMBLE_REGS         = 1;          #-- Number of regs feeding the inclocken of the capture registers
$::gSTRATIX_UNDELAYEDDQSOUT_INSERT_BUFFERS = 0;
$::gDLL_REF_CLOCK__SWITCHED_OFF_DURING_READS = "false";
$::gSTRATIXII_DQS_PHASE_SHIFT = 6750;
$::gSTRATIXII_DLL_DELAY_BUFFER_MODE = "low";
$::gSTRATIXII_DQS_OUT_MODE  = "delay_chain3";
$::gSTRATIXII_DLL_DELAY_CHAIN_LENGTH = 16;
$::gLOCAL_AVALON_IF           = "false";
$::gMEM_CHIPSELS              = 1;
$::gMEM_BANK_BITS             = 2;
$::gMEM_ROW_BITS              = 12;
$::gMEM_COL_BITS              = 10;
$::gMEM_PCH_BIT               = 10;
$::gMEM_ODT_RANKS             = 0;
$::gLOCAL_BURST_LEN           = 1;
$::gLOCAL_BURST_LEN_BITS      = 1;
$::gUSER_REFRESH              = "false";
$::gCONNECT_RESYNCH_CLK_TO    = "clk";
$::gCONNECT_POSTAMBLE_CLK_TO  = "clk";
$::gCONNECT_CAPTURE_CLK_TO    = "clk";
$::gCLOCK_PERIOD_IN_PS        = 10000;
$::gTINIT_CLOCKS              = 100;
$::gNUM_CLOCK_PAIRS           = 1;
$::gDQS_PHASE_SHIFT           = 90;  #degrees
$::gTPD_CLOCK_TRACE_NOM       = 500;
$::gTPD_CLOCKFEEDBACK_TRACE_NOM = 1000;
$::gTPD_DQS_TRACE_TOTAL_NOM   = 500;
$::gRTL_ROUNDTRIP_CLOCKS      = 0.0;
$::gBUFFER_DLL_DELAY_OUTPUT   = "false";
$::gFEDBACK_CLOCK_MODE = "false";
$::gTOPLEVEL_NAME = "example_top";
$::gWRAPPER_NAME = "wrapper";
$::gDDR_PREFIX_NAME = "ddr_";
$::gREGTEST_ADD_DLL_PORTS = 0;
$::gWIZARD_VERSION = "2.2.0";
$::gPARSE_EXAMPLE_DESIGN = "true";
$::gTESTBENCH_USE_VECTOR = "false";
$::gDQS_CRAM_CYCLONE    = 0;
$::gCLOCKFEEDBACK_IN_PIN_NAME = "fedback_clock_in";
$::gCLOCK_POS_PIN_NAME = "clk_to_sdram[0]";
$::gCLOCK_NEG_PIN_NAME = "clk_to_sdram_n[0]";
$::gEXTRA_PL_REG 		= "true";
$::gNEGEDGE_ADDRCMD		= "true";
$::gCASLATENCY		= "3.0";
$::MIG_FAMILY     = "NONE";
$::output_directory = "";
$::gCLOCK_GENERATION = "ddio";


#
# Parse the command line, returning the final command line
$debug = 0;
$error = 0;
print "pwd = $work_base\n" if $debug;
&usage if ($#ARGV == -1);
@args = &parse_args($work_base, @ARGV);
print @args, "\n";
#&process_soma();
&ddr_sdram();
&example_instance();
&example_driver();
&datapath();
&byte_group();
&write_example_testbench();
exit(-$error) if $error;
#

# Remove ".."'s in pathnames
#@tmp = ();

#foreach $arg (@args) {
#    $arg =~ s#[^/]\+/\.\.##g;
#    push(@tmp, $arg);
#}
#@args = @tmp;
exit(0);

#
# Parse an array of command-line arguments, returning

# an array of expanded command-line arguments
sub parse_args {

    #Fix for DDR2 Avalon mode
    if ($gLOCAL_AVALON_IF eq "true") {
        $gLOCAL_BURST_LEN = 1;
        $gLOCAL_BURST_LEN_BITS = 1;
    }

    local($cwd,         # Current working directory
      @args) = @_;  # List of arguments
    local ($arg) = "";
    $parse_count++;
    local($arg, @final,$pwd);
    readargs: while ($arg = shift(@args)) {
    chomp($arg);
    #print "ARG=", $arg, "\n";
    # Is this an option with a filename argument
    # that requires relocation?
    if ($arg =~ m/^-([fF])(.*)$/) {
        $opt = $1;

        $arg = $2;
        # Was it specified using the "-O arg" syntax?

        $arg = shift(@args) unless $arg;
        # Prepend the CWD if the argument is relative
# Not needed - relative paths not supported
#        $arg = "$cwd/$arg" unless $arg =~ m|^/|;
        # If this was a '-f' or '-F' option, read the file
        # and parse it as a sequence of options

        if ($opt =~ m/[fF]/) {
            print "Opening $arg file for reading\n" if $debug;

            if (!open(MFT, "< $arg")) {
                print STDERR "ERROR: Cannot open $arg for reading: $!\n";
                $error++;
                next;
            }
            local(@subargs, $_, @myargs) = ();
            while ($_ = <MFT>) {
                chomp;
# original argument splitting
#                @myargs = /\s*(\S+)/g;
                @myargs = ();
#                while ( /\s*(\S+)/g ) {
                # Now expect "XXX    =  YYY" format only
#                while ( /\s*(\S+)\s*=\s*(\S+)/g ) {
                while ( /\s*(\S+)\s*=(.*)/g ) {
                    $store_1 = $1;
                    if ($2 =~ /\s*(\S+)/ ) {
                        $store_2 = $1;
                    } else {
                        $store_2 = "";
                        print "Found Null Arg" if $debug;
                    }
                    # if we find a // then ignore the rest of the line
                    if (($store_1 =~ m#//#) || ($store_1 =~ m#--#)){
                        #print "\n\n Found Comment ! \n\n";
                        last;
                    } else {
                           #push(@myargs, $1);
                           push(@myargs, "-g" . $store_1."=".$store_2);
                       }

                }
                print "My Args=" if $debug;

                print join "|", @myargs, "\n" if $debug;
                push(@subargs, @myargs);
                #push(@subargs, $_);
            }
            close(MFT);
            # If the option was '-F', change the cwd to the directory

            # containing the argument file
            $newcwd = $cwd;

            # Not needed any more (should use -f instead)
            #if ($opt eq "F") {
            #    $arg =~ m#^(.*)/[^/]+$#;
            #    $newcwd = $1;
            #    chdir($newcwd) or die "Can't chdir to $newcwd";
            #    print "Changed dir -F to $newcwd\n" if $debug;
            #}
            push(@final, &parse_args($newcwd, @subargs));
            #Not needed any more
            #chdir($cwd) or die "Can't chdir to $cwd";
            #print "Changed dir back to $cwd\n" if $debug;
        } else {
            push(@final, "-$opt", $arg);
        }

    }
    # Get the generics

    elsif ($arg =~ m/^-(g|g)(.*)$/) {
        $opt = $1;
        $arg = $2;
        # Was it specified using the "-O arg" syntax?
        $arg = shift(@args) unless $arg;
 #       print $opt, "=====", $arg, "\n";

        $arg =~ m/^(.*)=(.*)$/;
        $generic = uc $1;

        $generic_val = $2;
#        print $generic, "+++++", $generic_val, "\n";
#$gINTER_POSTAMBLE        = "false";   #-- Insert extra negedge sys_clk postamble register in the data path
#$gPIPELINE_READDATA      = "false";   #-- Insert pipeline registers to reclock the output of the resynch registers to the posedge
#$gENABLE_POSTAMBLE_LOGIC = "true";    #-- Whether or not to insert the logic to control the capture registers, particularly important during the DQS postamble
#$gPOSTAMBLE_REGS         = 2          #-- Number of regs feeding the inclocken of the capture registers
        if ($generic eq "FAMILY") {
            $gFAMILY = $generic_val;
            if ($gFAMILY  eq "stratixii") {
                $gFAMILY = "Stratix II";
                $gpllFAMILY = "Stratix II";
                $gFAMILYlc = "stratixii";
            }
	    elsif ($gFAMILY  eq "stratixiigx") {
                $gFAMILY = "Stratix II";
                $gpllFAMILY = "Stratix II";
                $gFAMILYlc = "stratixii";
            }
	    elsif ($gFAMILY  eq "hardcopyii") {
                $gFAMILY = "Stratix II";
                $gpllFAMILY = "Stratix II";
                $gFAMILYlc = "stratixii";
                $gIS_HARDCOPY2 = "true";
            }
            elsif ($gFAMILY  eq "stratixgx") {
                $gFAMILY = "Stratix";
                $gpllFAMILY = "Stratix";
                $gFAMILYlc = "stratix";
            }
            elsif ($gFAMILY  eq "stratix") {
                $gFAMILY = "Stratix";
                $gpllFAMILY = "Stratix";
                $gFAMILYlc = "stratix";
            }
            elsif ($gFAMILY  eq "cyclone") {
                $gFAMILY = "Cyclone";
                $gpllFAMILY = "Cyclone";
                $gFAMILYlc = "cyclone";
            }
            elsif ($gFAMILY  eq "cycloneii") {
                $gFAMILY = "Cyclone II";
                $gFAMILYlc = "cycloneii";
                $gpllFAMILY = "Cyclone II";
            }
            else {
                $gFAMILYlc = lc $gFAMILY;
            }
            print "gFAMILY=",$gFAMILY, "\n";
            print "gpllFAMILY=",$gpllFAMILY, "\n";
        }
        elsif ($generic eq "MIG_FAMILY") {
            $MIG_FAMILY = $generic_val;
            print "MIG_FAMILY=",$MIG_FAMILY, "\n";
        }
        elsif ($generic eq "MEM_TYPE") {
            if ($generic_val eq "DDR2") {
                $gMEM_TYPE = "ddr2_sdram";
            } elsif ($generic_val eq "DDR") {
                $gMEM_TYPE = "ddr_sdram";
            } else {
                $gMEM_TYPE = $generic_val;
            }
            print "gMEM_TYPE=",$gMEM_TYPE, "\n";
        }
        elsif ($generic eq "LOCAL_DATA_BITS") {
            $gLOCAL_DATA_BITS = $generic_val;
            print "gLOCAL_DATA_BITS=",$gLOCAL_DATA_BITS, "\n";
        }
        elsif ($generic eq "MEM_DQ_PER_DQS") {
            $gMEM_DQ_PER_DQS = $generic_val;
            print "gMEM_DQ_PER_DQS=",$gMEM_DQ_PER_DQS, "\n";
        }
        elsif ($generic eq "MEM_CHIP_BITS") {
            $gMEM_CHIP_BITS = $generic_val;
            if ($gMEM_CHIP_BITS > 0) {
                $gLEGAL_MEM_CHIP_BITS = $gMEM_CHIP_BITS;
            }
            print "gMEM_CHIP_BITS=",$gMEM_CHIP_BITS, "\n";
        }
        elsif ($generic eq "ENABLE_CAPTURE_CLK") {
            $gENABLE_CAPTURE_CLK = $generic_val;
            print "gENABLE_CAPTURE_CLK=",$gENABLE_CAPTURE_CLK, "\n";
        }
        elsif ($generic eq "ENABLE_RESYNCH_CLK") {
            $gENABLE_RESYNCH_CLK = $generic_val;
            print "gENABLE_RESYNCH_CLK=",$gENABLE_RESYNCH_CLK, "\n";
        }
        elsif ($generic eq "CHOSEN_RESYNCH_EDGE") {
            $gRESYNCH_EDGE = $generic_val;
            print "gRESYNCH_EDGE=",$gRESYNCH_EDGE, "\n";
        }
        elsif ($generic eq "CHOSEN_POSTAMBLE_EDGE") {
            $gPOSTAMBLE_EDGE = $generic_val;
            print "gPOSTAMBLE_EDGE=",$gPOSTAMBLE_EDGE, "\n";
        }
        elsif ($generic eq "CHOSEN_POSTAMBLE_CYCLE") {
            $gPOSTAMBLE_CYCLE = $generic_val;
            print "gPOSTAMBLE_CYCLE=",$gPOSTAMBLE_CYCLE, "\n";
        }
        elsif ($generic eq "INTER_RESYNCH") {
            $gINTER_RESYNCH = $generic_val;
            print "gINTER_RESYNCH=",$gINTER_RESYNCH, "\n";
        }
        elsif ($generic eq "INTER_POSTAMBLE") {
            $gINTER_POSTAMBLE = $generic_val;
            print "gINTER_POSTAMBLE=",$gINTER_POSTAMBLE, "\n";
        }
        elsif ($generic eq "PIPELINE_READDATA") {
            $gPIPELINE_READDATA = $generic_val;
            print "gPIPELINE_READDATA=",$gPIPELINE_READDATA, "\n";
        }
        elsif ($generic eq "REG_DIMM") {
            $gREG_DIMM = $generic_val;
            print "gREG_DIMM=",$gREG_DIMM, "\n";
        }
        elsif ($generic eq "ENABLE_POSTAMBLE") {
            $gENABLE_POSTAMBLE_LOGIC = $generic_val;
            print "gENABLE_POSTAMBLE_LOGIC=",$gENABLE_POSTAMBLE_LOGIC, "\n";
        }
        elsif ($generic eq "POSTAMBLE_REGS") {
            $gPOSTAMBLE_REGS = $generic_val;
            print "gPOSTAMBLE_REGS=",$gPOSTAMBLE_REGS, "\n";
        }
        elsif ($generic eq "STRATIX_UNDELAYEDDQSOUT_INSERT_BUFFERS") {
            $gSTRATIX_UNDELAYEDDQSOUT_INSERT_BUFFERS = $generic_val;
            print "gSTRATIX_UNDELAYEDDQSOUT_INSERT_BUFFERS=",$gSTRATIX_UNDELAYEDDQSOUT_INSERT_BUFFERS, "\n";
        }
        elsif ($generic eq "LOCAL_AVALON_IF") {
            $gLOCAL_AVALON_IF = $generic_val;
            print "gLOCAL_AVALON_IF=",$gLOCAL_AVALON_IF, "\n";
        }
        elsif ($generic eq "MEM_CHIPSELS") {
            $gMEM_CHIPSELS = $generic_val;
            print "gMEM_CHIPSELS=",$gMEM_CHIPSELS, "\n";
        }
        elsif ($generic eq "MEM_BANK_BITS") {
            $gMEM_BANK_BITS = $generic_val;
            print "gMEM_BANK_BITS=",$gMEM_BANK_BITS, "\n";
        }
        elsif ($generic eq "MEM_ROW_BITS") {
            $gMEM_ROW_BITS = $generic_val;
            print "gMEM_ROW_BITS=",$gMEM_ROW_BITS, "\n";
        }
        elsif ($generic eq "MEM_COL_BITS") {
            $gMEM_COL_BITS = $generic_val;
            print "gMEM_COL_BITS=",$gMEM_COL_BITS, "\n";
        }
        elsif ($generic eq "MEM_PCH_BIT") {
            $gMEM_PCH_BIT = $generic_val;
            print "gMEM_PCH_BIT =",$gMEM_PCH_BIT, "\n";
        }
        elsif ($generic eq "MEM_ODT_RANKS") {
            $gMEM_ODT_RANKS = $generic_val;
            print "gMEM_ODT_RANKS =",$gMEM_ODT_RANKS, "\n";
        }
        elsif ($generic eq "LOCAL_BURST_LEN") {
            $gLOCAL_BURST_LEN = $generic_val;
            print "gLOCAL_BURST_LEN=",$gLOCAL_BURST_LEN, "\n";
        }
        elsif ($generic eq "LOCAL_BURST_LEN_BITS") {
            $gLOCAL_BURST_LEN_BITS = $generic_val;
            print "gLOCAL_BURST_LEN_BITS=",$gLOCAL_BURST_LEN_BITS, "\n";
        }
        elsif ($generic eq "USER_REFRESH") {
            $gUSER_REFRESH = $generic_val;
            print "gUSER_REFRESH=",$gUSER_REFRESH, "\n";
        }
        elsif ($generic eq "BUFFER_DLL_DELAY_OUTPUT") {
            $gBUFFER_DLL_DELAY_OUTPUT = $generic_val;
            print "gBUFFER_DLL_DELAY_OUTPUT=",$gBUFFER_DLL_DELAY_OUTPUT, "\n";
        }
        elsif ($generic eq "FEDBACK_CLOCK_MODE") {
            $gFEDBACK_CLOCK_MODE = $generic_val;
            print "gFEDBACK_CLOCK_MODE=",$gFEDBACK_CLOCK_MODE, "\n";
        }
        elsif ($generic eq "CHOSEN_RESYNCH_CLK") {
            $gCONNECT_RESYNCH_CLK_TO = $generic_val;
            print "gCONNECT_RESYNCH_CLK_TO=",$gCONNECT_RESYNCH_CLK_TO, "\n";
        }
        elsif ($generic eq "CHOSEN_CAPTURE_CLK") {
            $gCONNECT_CAPTURE_CLK_TO = $generic_val;
            print "gCONNECT_CAPTURE_CLK_TO=",$gCONNECT_CAPTURE_CLK_TO, "\n";
        }
        elsif ($generic eq "CHOSEN_RESYNCH_CYCLE") {
            $gRESYNCH_CYCLE = $generic_val;
            print "gRESYNCH_CYCLE=",$gRESYNCH_CYCLE, "\n";
        }
        elsif ($generic eq "CHOSEN_POSTAMBLE_CLK") {
            $gCONNECT_POSTAMBLE_CLK_TO = $generic_val;
            print "gCONNECT_POSTAMBLE_CLK_TO=",$gCONNECT_POSTAMBLE_CLK_TO, "\n";
        }
        elsif ($generic eq "CLOCK_PERIOD_IN_PS") {
            $gCLOCK_PERIOD_IN_PS = $generic_val;

            print "gCLOCK_PERIOD_IN_PS=",$gCLOCK_PERIOD_IN_PS, "\n";
        }
        elsif ($generic eq "DQS_PHASE") {

            $gDQS_PHASE_SHIFT = $generic_val;
            print "gDQS_PHASE_SHIFT=",$gDQS_PHASE_SHIFT, "\n";
        }
        elsif ($generic eq "EXTRA_PL_REG") {
            $gEXTRA_PL_REG = $generic_val;
            print "gEXTRA_PL_REG=",$gEXTRA_PL_REG, "\n";
        }
        elsif ($generic eq "NEGEDGE_ADDRCMD") {
            $gNEGEDGE_ADDRCMD = $generic_val;
            print "gNEGEDGE_ADDRCMD=",$gNEGEDGE_ADDRCMD, "\n";
        }
        elsif ($generic eq "STRATIXII_DQS_PHASE") {
            $gSTRATIXII_DQS_PHASE_SHIFT = $generic_val;
            print "gSTRATIXII_DQS_PHASE_SHIFT=",$gSTRATIXII_DQS_PHASE_SHIFT, "\n";
        }
        elsif ($generic eq "STRATIXII_DLL_DELAY_BUFFER_MODE") {

            $gSTRATIXII_DLL_DELAY_BUFFER_MODE = $generic_val;
            print "gSTRATIXII_DLL_DELAY_BUFFER_MODE=",$gSTRATIXII_DLL_DELAY_BUFFER_MODE, "\n";
        }
        elsif ($generic eq "STRATIXII_DQS_OUT_MODE") {
            $gSTRATIXII_DQS_OUT_MODE = $generic_val;
            print "gSTRATIXII_DQS_OUT_MODE=",$gSTRATIXII_DQS_OUT_MODE, "\n";
        }
        elsif ($generic eq "STRATIXII_DLL_DELAY_CHAIN_LENGTH") {
            $gSTRATIXII_DLL_DELAY_CHAIN_LENGTH = $generic_val;
            print "gSTRATIXII_DLL_DELAY_CHAIN_LENGTH=",$gSTRATIXII_DLL_DELAY_CHAIN_LENGTH, "\n";
        }
        elsif ($generic eq "DLL_REF_CLOCK__SWITCHED_OFF_DURING_READS") {
            $gDLL_REF_CLOCK__SWITCHED_OFF_DURING_READS = $generic_val;
            print "gDLL_REF_CLOCK__SWITCHED_OFF_DURING_READS=",$gDLL_REF_CLOCK__SWITCHED_OFF_DURING_READS, "\n";
        }
        elsif ($generic eq "TINIT_CLOCKS") {
            $gTINIT_CLOCKS = $generic_val;
            print "gTINIT_CLOCKS=",$gTINIT_CLOCKS, "\n";
        }
        elsif ($generic eq "NUM_OUTPUT_CLOCKS") {
            $gNUM_CLOCK_PAIRS = $generic_val;

            print "gNUM_CLOCK_PAIRS=",$gNUM_CLOCK_PAIRS, "\n";
        }
        elsif ($generic eq "RTL_ROUNDTRIP_CLOCKS") {

            $gRTL_ROUNDTRIP_CLOCKS = $generic_val;
            print "gRTL_ROUNDTRIP_CLOCKS=",$gRTL_ROUNDTRIP_CLOCKS, "\n";
        }
        elsif ($generic eq "TPD_CLOCK_TRACE_NOM") {
            $gTPD_CLOCK_TRACE_NOM = $generic_val;
            print "gTPD_CLOCK_TRACE_NOM=",$gTPD_CLOCK_TRACE_NOM, "\n";
        }
        elsif ($generic eq "TPD_CLOCKFEEDBACK_TRACE_NOM") {

            $gTPD_CLOCKFEEDBACK_TRACE_NOM = $generic_val;
            print "gTPD_CLOCKFEEDBACK_TRACE_NOM=",$gTPD_CLOCKFEEDBACK_TRACE_NOM, "\n";
        }

        elsif ($generic eq "TPD_DQS_TRACE_TOTAL_NOM") {
            $gTPD_DQS_TRACE_TOTAL_NOM = $generic_val;
            print "gTPD_DQS_TRACE_TOTAL_NOM=",$gTPD_DQS_TRACE_TOTAL_NOM, "\n";
        }
        elsif ($generic eq "TOPLEVEL_NAME") {
            $gTOPLEVEL_NAME = $generic_val;
            print "gTOPLEVEL_NAME=",$gTOPLEVEL_NAME, "\n";
        }
        elsif ($generic eq "WRAPPER_NAME") {
            $gWRAPPER_NAME = $generic_val;
            print "gWRAPPER_NAME=",$gWRAPPER_NAME, "\n";
        }
        elsif ($generic eq "DDR_PIN_PREFIX") {
            $gDDR_PREFIX_NAME = $generic_val;
            print "gDDR_PREFIX_NAME=",$gDDR_PREFIX_NAME, "\n";
        }
        elsif ($generic eq "PARSE_EXAMPLE_DESIGN") {
            $gPARSE_EXAMPLE_DESIGN = $generic_val;
            print "gPARSE_EXAMPLE_DESIGN=",$gPARSE_EXAMPLE_DESIGN, "\n";
        }
        elsif ($generic eq "TESTBENCH_USE_VECTOR") {
            $gTESTBENCH_USE_VECTOR = $generic_val;
            print "gTESTBENCH_USE_VECTOR=",$gTESTBENCH_USE_VECTOR, "\n";
        }
        elsif ($generic eq "DQS_CRAM_CYCLONE") {
            $gDQS_CRAM_CYCLONE = $generic_val;
            print "gDQS_CRAM_CYCLONE =",$gDQS_CRAM_CYCLONE, "\n";
        }
        elsif ($generic eq "CLOCKFEEDBACK_IN_PIN_NAME") {
            $gCLOCKFEEDBACK_IN_PIN_NAME = $generic_val;
            print "CLOCKFEEDBACK_IN_PIN_NAME =",$gCLOCKFEEDBACK_IN_PIN_NAME, "\n";
        }
        elsif ($generic eq "CLOCK_POS_PIN_NAME") {
            $gCLOCK_POS_PIN_NAME = $generic_val;
            print "CLOCK_POS_PIN_NAME =",$gCLOCK_POS_PIN_NAME, "\n";
            $clock_pos_pin_name = $generic_val;
            $clock_pos_pin_name = $` if ($clock_pos_pin_name =~ /\[/);

        }
        elsif ($generic eq "CLOCK_NEG_PIN_NAME") {
            $gCLOCK_NEG_PIN_NAME = $generic_val;
            print "CLOCK_NEG_PIN_NAME =",$gCLOCK_NEG_PIN_NAME, "\n";
            $clock_neg_pin_name = $generic_val;
            $clock_neg_pin_name = $` if ($clock_neg_pin_name =~ /\[/);
        }
        elsif ($generic eq "LANGUAGE") {
            $language = $generic_val;
            if ($language ne "vhdl") {
                $language = "verilog";
            }
            print "language=",$language, "\n";
        }
        elsif ($generic eq "CAS_LATENCY") {
            $gCASLATENCY = $generic_val;
            print "gCASLATENCY=",$gCASLATENCY, "\n";
        }
        elsif ($generic eq "QUARTUS_VERSION") {
            $quartus_version = $generic_val;
            if ($quartus_version ne "4.0") {
                $quartus_version = "4.1";
            }
            print "quartus_version=",$quartus_version, "\n";
        }
        elsif ($generic eq "MEGAWIZARD_VERSION") {
            $gWIZARD_VERSION = $generic_val;
            print "WIZARD_VERSION=",$gWIZARD_VERSION, "\n";

        }
        elsif ($generic eq "REGTEST_ADD_DLL_PORTS") {

            $gREGTEST_ADD_DLL_PORTS = $generic_val;
            print "REGTEST_ADD_DLL_PORTS=",$gREGTEST_ADD_DLL_PORTS, "\n";
        }
        elsif ($generic eq "CLOCK_GENERATION") {
            # clock_generation is either "ddio" or a phase shift
            if ($generic_val eq "ddio") {
                $gCLOCK_GENERATION = $generic_val;
            }
            elsif ($generic_val >= 0 and $generic_val <= 360) {
                $gCLOCK_GENERATION = "dedicated";
            } else {
                $gCLOCK_GENERATION = "ddio"; # default to good old DDIO mode
            }

            print "CLOCK_GENERATION=",$gCLOCK_GENERATION, "\n";
        }
        
        else {
            print $generic, " - Unrecognised Generic !!!\n";
        }
#        print "cas=",$gCASLATENCY," col=",$gcolbits," row=",$growbits, "\n";
#        $arg =~ tr/A-Z/a-z/;

#        print $opt, "=====", $arg, "\n";
        $generic = $arg;

        push(@final, "-$opt", $arg);
    }
    # Get the soma in file name
    elsif ($arg =~ m/^-(s|S)(.*)$/) {
        $opt = $1;
        $arg = $2;
        # Was it specified using the "-O arg" syntax?
        $arg = shift(@args) unless $arg;
        print $opt, "=====", $arg, "\n";
#        $arg =~ tr/A-Z/a-z/;
#        print $opt, "=====", $arg, "\n";
        $soma_file = $arg;
        push(@final, "-$opt", $arg);
    }
    # Get the soma out file name

    elsif ($arg =~ m/^-(o|O)(.*)$/) {
        $opt = $1;

        $arg = $2;
        # Was it specified using the "-O arg" syntax?
        $arg = shift(@args) unless $arg;
        print $opt, "=====", $arg, "\n";
#        $arg =~ tr/A-Z/a-z/;
#        print $opt, "=====", $arg, "\n";
        $output_directory = $arg . "/";
	my $s1 = '/';

        $output_directory =~ s/\\/$s1/g;
        push(@final, "-$opt", $arg);
    }

    # Get debug option
    elsif ($arg =~ m/^-(d|d)(.*)$/) {
        $debug = 1;
    }
    elsif ($arg =~ m/^-(h|H)(.*)$/) {
        $opt = $1;
        &usage;
    }
    # Anything else is a test to run
    else {
    }
    }
    #print join " ", @final, "\n";
    @args = @final;
    return @final;
#    return @args;
}
sub byte_group{
&init_controller3();
}
sub datapath{
&init_controller2();
}
sub ddr_sdram {
&init_controller();
}
sub example_driver{
&init_controller4();
}
sub example_instance
{
    if ($language eq "vhdl") {
        $file_ext = ".vhd"
    } else {
        $file_ext = ".v"
    }

    $example_instance_file_out = $output_directory .$gTOPLEVEL_NAME . $file_ext;
    $example_instance_file_out_noext = $output_directory . $gTOPLEVEL_NAME ;

    $example_instance_number = 1;
    ######################################################################
    # Check that file doesn't exist otherwise increment the number
    ######################################################################
    while (1) {
        $example_instance_backup_file_out = $example_instance_file_out_noext . "_" . $example_instance_number . $file_ext;
        if (-e $example_instance_backup_file_out) {
            $example_instance_number++;
        } else {
            last;
        }
    }

    # If top level file exists, back up current user edits to .tmp
    if (-e ${example_instance_file_out})
    {
        $top_level_exists = "true";
        open(EI_IN, "< ${example_instance_file_out}") or die "Error! Couldn't open ${example_instance_file_out} $!";
        open(EI_OUT, "> ${example_instance_file_out}.tmp") or die "Error! Couldn't open ${example_instance_file_out}.tmp . $!";
        while ($_ = <EI_IN>) {
            print EI_OUT $_;
        };
    } else {
        $top_level_exists = "false";
    }
    print "** TOP LEVEL FILE IS = $example_instance_file_out and gPARSE_EXAMPLE_DESIGN = $gPARSE_EXAMPLE_DESIGN\n";
    print "** top_level_exists = $top_level_exists\n";
    
    # Create a default top level with Europa called $example_instance_file_out 
    # unless there wasn't one and parse top level was OFF - this is the case 
    # where the top level is in another directory (SPR 211649) or the user 
    # really doesn't want one
    if ($top_level_exists eq "true" or $gPARSE_EXAMPLE_DESIGN eq "true") { 
        &init_controller5();
    } else {
        print "     WARNING : Not generating a top level example file because there wasn't one and \"Update example top level file\" was disabled\n";    
    }

    
    
    # if there wasn't a top level before, there won't be a .tmp and so no need to parse
    if (-e $example_instance_file_out.".tmp") {
        
        %insert_hash = ();

        # Read in clean, newly generated file file and extract the magic text between the tags
        open(EI_IN, "< ${example_instance_file_out}") or die "Error! Couldn't open ${example_instance_file_out} $!";
        while ($_ = <EI_IN>) {
            $preserve_text="";
            if ( /\.*<< START MEGAWIZARD INSERT (\w+)/ || /\.*<< start (\w+)/ ) {#if (/\.*<< START MEGAWIZARD INSERT (\w+)/ ) {
                $preserve_type = $1;
                print "\n Found Insert $preserve_type ! \n" if $debug;       # debug
                $_ = <EI_IN>;
                until ( /\.*<< END MEGAWIZARD INSERT $preserve_type/ || /\.*<< end $preserve_type/ || eof EI_IN) {#until ( (/\.*<< END MEGAWIZARD INSERT $preserve_type/) || (eof (EI_IN))) {
                    $preserve_text .= $_;
                    $_ = <EI_IN>;
                }
                # print "preserve_type = $preserve_type\ntext = $preserve_text";
                #		print "\n Found END Insert $preserve_text";
                $insert_hash{$preserve_type}=$preserve_text;          # Add to hash
                print "\n Found END Insert $preserve_type ! \n" if $debug;      # debug
            }
        }

        # Now read in the user edited one  (.tmp) and replace everything between the tags with the newly generated text, then write it to .tmp2
	    open(EI_IN, "< ${example_instance_file_out}.tmp") or die "Error! Couldn't open ${example_instance_file_out}.tmp $!";
        open(EI_OUT, "> ${example_instance_file_out}.tmp2") or die "Error! Couldn't open ${example_instance_file_out}.tmp2 . $!";
        print "\n Parsing Generated Example Instance File ! \n" if $debug;               # debug

        $allowed_to_parse_file = 0;
        while ($_ = <EI_IN>) {
            $preserve_text="";
            print EI_OUT;
            if ( /\.*<< START MEGAWIZARD INSERT (\w+)/ || /\.*<< start (\w+)/ ) {
                $preserve_type = $1;
                print "\n Found Insert $preserve_type ! \n" if $debug;       # debug
                print EI_OUT $insert_hash{$preserve_type};
                until ( /\.*<< END MEGAWIZARD INSERT $preserve_type/ || /\.*<< end $preserve_type/ || eof EI_IN) {
                    $_ = <EI_IN>;
                }
                print EI_OUT;
                print "Found END Insert $preserve_type ! \n" if $debug;      # debug
            }

            # Decide whether this top level was created by the current version of the wizard, if not, we can't parse it so don't.
            if ( /\.*<< MEGAWIZARD PARSE FILE DDR(\S+)/ ) {
                print "\n Found PARSE FILE DDR${1} ! \n" if $debug;      # debug
                if ($1 eq $gWIZARD_VERSION) {
                    print "\n Version number matches - parsing file! \n" if $debug;      # debug
                    $allowed_to_parse_file = 1;
                } else {
                    print "    WARNING : Version of ${example_instance_file_out} ($1) does not match wizard version ($gWIZARD_VERSION) \n              Backing up the old file to ${example_instance_backup_file_out} and creating a new one.\n";     
                    $allowed_to_parse_file = 0;
                }
            }
        }

        if ($allowed_to_parse_file == 0) {          # version numbers don't match! 

            if ($gPARSE_EXAMPLE_DESIGN eq "true") { # version numbers don't match and gPARSE_EXAMPLE_DESIGN is true (ie user wants a new top)
                # copy .tmp (user edited, not merged) to top_1.v (backup version). This still creates a new top level called top.v! 
                open(EI_IN, "< ${example_instance_file_out}.tmp") or die "Error! Couldn't open ${example_instance_file_out}.tmp $!";
                open(EI_OUT, "> ${example_instance_backup_file_out}") or die "Error! Couldn't open ${example_instance_backup_file_out} . $!";
                while ($_ = <EI_IN>) {
                    print EI_OUT $_;
                };
            } else { # version number don't match and the user doesn't want us to touch his file 
                # copy .tmp (user edited, not merged) back to top.v (original version). 
                open(EI_IN, "< ${example_instance_file_out}.tmp") or die "Error! Couldn't open ${example_instance_file_out}.tmp $!";
                open(EI_OUT, "> ${example_instance_file_out}") or die "Error! Couldn't open ${example_instance_file_out} . $!";
                while ($_ = <EI_IN>) {
                    print EI_OUT $_;
                };
                
            };
                
        } else {
            if ($gPARSE_EXAMPLE_DESIGN eq "true") { # version numbers match and gPARSE_EXAMPLE_DESIGN is true (ie user wants a new top)
                # copy .tmp (user edited, not merged) to top_1.v (backup version) 
                open(EI_IN, "< ${example_instance_file_out}.tmp") or die "Error! Couldn't open ${example_instance_file_out}.tmp $!";
                open(EI_OUT, "> ${example_instance_backup_file_out}") or die "Error! Couldn't open ${example_instance_backup_file_out} . $!";
                while ($_ = <EI_IN>) {
                    print EI_OUT $_;
                };
            
                # copy .tmp2 (user edits merged with reference) to top.v   
                open(EI_IN, "< ${example_instance_file_out}.tmp2") or die "Error! Couldn't open ${example_instance_file_out}.tmp2 $!";
                open(EI_OUT, "> ${example_instance_file_out}") or die "Error! Couldn't open ${example_instance_file_out} . $!";
                while ($_ = <EI_IN>) {
                    print EI_OUT $_;
                };
            } else { # version number match but the user doesn't want us to touch his file
                # copy .v (clean, freshly generated) to top_1.v (backup version) 
                open(EI_IN, "< ${example_instance_file_out}") or die "Error! Couldn't open ${example_instance_file_out} $!";
                open(EI_OUT, "> ${example_instance_backup_file_out}") or die "Error! Couldn't open ${example_instance_backup_file_out} . $!";
                while ($_ = <EI_IN>) {
                    print EI_OUT $_;
                };
                # put the un-edited (.tmp) file back onto top.v
                open(EI_IN, "< ${example_instance_file_out}.tmp") or die "Error! Couldn't open ${example_instance_file_out}.tmp $!";
                open(EI_OUT, "> ${example_instance_file_out}") or die "Error! Couldn't open ${example_instance_file_out} . $!";
                while ($_ = <EI_IN>) {
                    print EI_OUT $_;
                };
            }
        }
            
    } else  # if the user edited version (.tmp) doesn't exist, do nothing
    {
    }

### END
}

sub write_example_testbench{
    if ($language eq "vhdl") {
        $file_ext = ".vhd"
    } else {
        $file_ext = ".v"
    }

    $example_testbench_file_out = $output_directory . $gTOPLEVEL_NAME . "_tb" . $file_ext;
    $example_testbench_file_out_noext = $output_directory . $gTOPLEVEL_NAME . "_tb" ;

    $example_testbench_number = 1;
    ######################################################################
    # Check that file doesn't exist otherwise increment the number
    ######################################################################
    while (1) {
        $example_testbench_backup_file_out = $example_testbench_file_out_noext . "_" . $example_testbench_number . $file_ext;
        #$run_dir = "$test.rundir$run_dir_num";
        if (-e $example_testbench_backup_file_out) {
            $example_testbench_number++;
        } else {
            last;
        }
    }

    # Write the reference testbench into tb.v.tmp 
    open(ETB_OUT, "> ${example_testbench_file_out}.tmp") or die "Error! Couldn't open ${example_testbench_file_out}.tmp . $!";

    if ($language eq "vhdl") {
         
        vhdl_write_etb_header();        # Writes the VHDL header for the testbench including a commented list of all the params
        vhdl_write_etb_portlist();      # Writes the rest of the VHDL testbench

    } else {
        
        verilog_write_etb_header();     # Writes the Verilog header for the testbench including a commented list of all the params
        verilog_write_etb_portlist();   # Writes the rest of the Verilog testbench
    }                                                
    close ETB_OUT;

    # Check if there is already a testbench file
    if (-e $example_testbench_file_out) {
        
        %insert_hash = ();

        # Read in clean, newly generated file file and extract the magic text between the tags
        print "\n Parsing Generated Example Testbench File ! \n" if $debug;               # debug
        open(ETB_IN, "< ${example_testbench_file_out}.tmp") or die "Error! Couldn't open ${example_testbench_file_out}.tmp. $!";
        while ($_ = <ETB_IN>) {
            $preserve_text="";
            if ( /\.* << START MEGAWIZARD INSERT (\w+)/ ) {
                $preserve_type = $1;
                print "\n Found Insert $preserve_type ! \n" if $debug;       # debug
                $_ = <ETB_IN>;
                until ( /\.* << END MEGAWIZARD INSERT $preserve_type/ || eof ETB_IN) {
                    $preserve_text .= $_;
                    $_ = <ETB_IN>;
                }
                #chomp($preserve_text);
                $insert_hash{$preserve_type}=$preserve_text;          # Add to hash
                print "\n Found END Insert $preserve_type ! \n" if $debug;      # debug
            }

        }

        # Now read in the user edited one (.v) and replace everything between the tags with the newly generated text, then write it to .tmp2
        open(ETB_IN, "< ${example_testbench_file_out}") or die "Error! Couldn't open ${example_testbench_file_out}. $!";
        open(ETB_OUT, "> ${example_testbench_file_out}.tmp2") or die "Error! Couldn't open ${example_testbench_file_out}.tmp2 . $!";
        print "\n Parsing Existing Example Testbench File ! \n";               # debug
        $allowed_to_parse_file = 0;
        while ($_ = <ETB_IN>) {
            $preserve_text="";
            print ETB_OUT;
            if ( /\.* << START MEGAWIZARD INSERT (\w+)/ ) {
                $preserve_type = $1;
                print "\n Found Insert $preserve_type ! \n" if $debug;       # debug
                print ETB_OUT $insert_hash{$preserve_type};
                until ( /\.* << END MEGAWIZARD INSERT $preserve_type/ || eof ETB_IN) {
                    $_ = <ETB_IN>;
                }
                print ETB_OUT;
                print "\n Found END Insert $preserve_type ! \n" if $debug;      # debug
            }
            if ( /\.* << MEGAWIZARD PARSE FILE DDR(\S+)/ ) {
                print "\n Found PARSE FILE DDR${1} ! \n" if $debug;      # debug
                if ($1 eq $gWIZARD_VERSION) {
                    print "\n Version number matches - parsing file! \n" if $debug;      # debug
                    $allowed_to_parse_file = 1;
                } else {
                    print "    WARNING : Version of ${example_testbench_file_out} ($1) does not match wizard version ($gWIZARD_VERSION) \n              Backing up the old file to ${example_testbench_backup_file_out} and creating a new one.\n";     
                    $allowed_to_parse_file = 0;
                }
            }

        }

        if ($allowed_to_parse_file == 0) {          # version numbers don't match so don't even try to parse the old one        

            # copy tb.v (user edited, not merged) to top_1.v (backup version) and then create a new clean tb called tb.v! 
            print "\n Parsed Example Testbench File does not match - generating new file! \n" if $debug;               # debug
            open(ETB_IN, "< ${example_testbench_file_out}") or die "Error! Couldn't open ${example_testbench_file_out} $!";
            open(ETB_OUT, "> ${example_testbench_backup_file_out}") or die "Error! Couldn't open ${example_testbench_backup_file_out} . $!";
            while ($_ = <ETB_IN>) {
                print ETB_OUT $_;
            };

            # create a new clean tb called tb.v to match the new version (having backed up the old one)
            open(ETB_IN, "< ${example_testbench_file_out}.tmp") or die "Error! Couldn't open ${example_testbench_file_out}.tmp $!";
            open(ETB_OUT, "> ${example_testbench_file_out}") or die "Error! Couldn't open ${example_testbench_file_out} . $!";
            while ($_ = <ETB_IN>) {
                print ETB_OUT $_;
            };
         } else {
            if ($gPARSE_EXAMPLE_DESIGN eq "true") { # version numbers match and gPARSE_EXAMPLE_DESIGN is true (ie user wants a new tb)
                
                # copy .v (user edited, not merged) to top_1.v (backup version) 
                open(ETB_IN, "< ${example_testbench_file_out}") or die "Error! Couldn't open ${example_testbench_file_out} $!";
                open(ETB_OUT, "> ${example_testbench_backup_file_out}") or die "Error! Couldn't open ${example_testbench_backup_file_out} . $!";
                while ($_ = <ETB_IN>) {
                    print ETB_OUT $_;
                };
    
                # copy .tmp2 (user edits merged with reference) to tb.v   
                open(ETB_IN, "< ${example_testbench_file_out}.tmp2") or die "Error! Couldn't open ${example_testbench_file_out}.tmp2 $!";
                open(ETB_OUT, "> ${example_testbench_file_out}") or die "Error! Couldn't open ${example_testbench_file_out} . $!";
                while ($_ = <ETB_IN>) {
                    print ETB_OUT $_;
                };
            } else { # version number match but the user doesn't want us to touch his file
                # unlike the top level generation flow, we can do nothing here as the clean copy was called tb.v.tmp
            }
         }
    } else { # no tb.v at all, so we should generate one. This is less dangerous than the top.v generation and will be true when creating a new design...
        # Copy clean, just generated tb.v.tmp to tb.v.
        open(ETB_IN, "< ${example_testbench_file_out}.tmp") or die "Error! Couldn't open ${example_testbench_file_out}.tmp $!";
        open(ETB_OUT, "> ${example_testbench_file_out}") or die "Error! Couldn't open ${example_testbench_file_out} . $!";
        while ($_ = <ETB_IN>) {
            print ETB_OUT $_;
        };

    };        


### END
}


sub vhdl_write_etb_header {
### HEADER
#print "writing tb header";
$header_title = "Example top level testbench for $gWRAPPER_NAME DDR SDRAM Controller";
$header_filename = $gTOPLEVEL_NAME . "_tb" . $file_ext;
$header_revision = "V" . $gWIZARD_VERSION;


print ETB_OUT  <<HEADERZZ;
--------------------------------------------------------------------------------
-- This confidential and proprietary software may be used only as authorized by
-- a licensing agreement from Altera Corporation.
--
-- (C) COPYRIGHT 2005 ALTERA CORPORATION
-- ALL RIGHTS RESERVED
--
-- The entire notice above must be reproduced on all authorized copies and any
-- such reproduction must be pursuant to a licensing agreement from Altera.
--
-- Title        : $header_title
-- Project      : DDR SDRAM Controller
--
-- File         : $header_filename
--
-- Revision     : $header_revision
--
-- Abstract:
-- Automatically generated testbench for the example top level design to allow
-- functional and timing simulation.
--
--------------------------------------------------------------------------------
--
-- *************** This is a MegaWizard generated file ****************
--
-- If you need to edit this file make sure the edits are not inside any 'MEGAWIZARD'
-- text insertion areas.
-- (between "<< START MEGAWIZARD INSERT" and "<< END MEGAWIZARD INSERT" comments)
--
-- Any edits inside these delimiters will be overwritten by the megawizard if you
-- re-run it.
--
-- If you really need to make changes inside these delimiters then delete
-- both 'START' and 'END' delimiters.  This will stop the megawizard updating this
-- section again.
--
------------------------------------------------------------------------------------
-- << START MEGAWIZARD INSERT PARAMETER_LIST
-- Parameters:
--
-- Device Family                      : $gFAMILY
-- local Interface Data Width         : $gLOCAL_DATA_BITS
-- MEM_CHIPSELS                       : $gMEM_CHIPSELS
-- MEM_BANK_BITS                      : $gMEM_BANK_BITS
-- MEM_ROW_BITS                       : $gMEM_ROW_BITS
-- MEM_COL_BITS                       : $gMEM_COL_BITS
-- LOCAL_DATA_BITS                    : $gLOCAL_DATA_BITS
-- NUM_CLOCK_PAIRS                    : $gNUM_CLOCK_PAIRS
-- RTL_ROUNDTRIP_CLOCKS               : $gRTL_ROUNDTRIP_CLOCKS
-- CLOCK_TICK_IN_PS                   : $gCLOCK_PERIOD_IN_PS
-- REGISTERED_DIMM                    : $gREG_DIMM
-- BOARD_DQS_DELAY                    : $gTPD_DQS_TRACE_TOTAL_NOM
-- BOARD_CLK_DELAY                    : $gTPD_CLOCK_TRACE_NOM
-- TINIT_CLOCKS                       : $gTINIT_CLOCKS
-- << END MEGAWIZARD INSERT PARAMETER_LIST
------------------------------------------------------------------------------------
-- << MEGAWIZARD PARSE FILE DDR${gWIZARD_VERSION}


HEADERZZ
}

sub vhdl_write_etb_portlist {
### DATAPATH PORTS ETC

if (($gFAMILY eq "Stratix") & ($gENABLE_CAPTURE_CLK ne "true")) {
$vhdl_etb_stratix_ref_clock=<<vhdl_etb_stratix_ref_clock
-- Stratix Only
        stratix_dqs_ref_clk   =>  stratix_dqs_ref_clk,      --Feeds the Straix "DQS phase Shift Reference Circuit"
                                                            --This port does not drive any logic inside the design.
        stratix_dqs_ref_clk_out   =>  stratix_dqs_ref_clk,

vhdl_etb_stratix_ref_clock
}



if ($gMEM_TYPE eq "ddr2_sdram") {
    # whether or not to put an ODT pin on the controller
    $vhdl_etb_ddr2_port_map=<<vhdl_etb_ddr2_port_map;
        ${gDDR_PREFIX_NAME}odt       => odt,
vhdl_etb_ddr2_port_map

    $vhdl_mem_model_component=<<vhdl_ddr2_component;
    component generic_ddr2_sdram_rtl is
    generic(
        ROWBITS         : integer := 13;
        DATABITS        : integer := 8;
        COLBITS         : integer := 9;
        BANKBITS        : integer := 2
    );
    port(
        CLK             : in     std_logic;
        CLK_N           : in     std_logic;
        CKE             : in     std_logic;
        CS_N            : in     std_logic;
        RAS_N           : in     std_logic;
        CAS_N           : in     std_logic;
        WE_N            : in     std_logic;
        DM_RDQS         : inout  std_logic_vector;
        BA              : in     std_logic_vector;
        ADDR            : in     std_logic_vector;
        DQ              : inout  std_logic_vector;
        DQS             : inout  std_logic_vector;
        DQS_N           : inout  std_logic_vector;
        RDQS_N          : out    std_logic_vector;
        ODT             : in     std_logic
    );
    end component generic_ddr2_sdram_rtl;
vhdl_ddr2_component
    
    # $vhdl_dimm_ddr2_mode="TRUE";
    $vhdl_memory_inst=<<vhdl_ddr2_mem_inst;
       chipsel : for i in 0 to (gMEM_CHIPSELS - 1) generate
            device : for j in 0 to (gLOCAL_DATA_BITS / 2 / gMEM_DQ_PER_DQS - 1) generate
            
                    mem : generic_ddr2_sdram_rtl
                        generic map(
                            BANKBITS    => gMEM_BANK_BITS,
                            ROWBITS     => gMEM_ROW_BITS,
                            COLBITS     => gMEM_COL_BITS,
                            DATABITS    => gMEM_DQ_PER_DQS
                        )
                        port map (
                            CLK         => clk_to_ram,            
                            CLK_N       => clk_to_ram_n,          
                            CKE         => cke_delayed(i),        
                            CS_N        => cs_n_delayed(i),       
                            RAS_N       => ras_n_delayed,         
                            CAS_N       => cas_n_delayed,         
                            WE_N        => we_n_delayed,          
                            DM_RDQS     => dm_delayed(j downto j),                                                   
                            BA          => ba_delayed,                                                      
                            ADDR        => a_delayed(gMEM_ROW_BITS - 1 downto 0),                           
                            DQ          => mem_dq(gMEM_DQ_PER_DQS * (j + 1) - 1 downto gMEM_DQ_PER_DQS * j),
                            DQS         => mem_dqs(j downto j),  
                            DQS_N       => mem_dqsn(j downto j),
                            RDQS_N      => mem_rdqsn_unused(j downto j),
                            ODT         => odt_delayed(i)
                        );
            end generate; -- all chips
        end generate; -- all sides
vhdl_ddr2_mem_inst

} else {
    # $vhdl_dimm_ddr2_mode="FALSE";
    $vhdl_memory_inst=<<vhdl_ddr_mem_inst;
       chipsel : for i in 0 to (gMEM_CHIPSELS - 1) generate
            device : for j in 0 to (gLOCAL_DATA_BITS / 2 / gMEM_DQ_PER_DQS - 1) generate
                mem : generic_ddr_sdram_rtl
                    generic map(
                        BANKBITS    => gMEM_BANK_BITS,
                        ROWBITS     => gMEM_ROW_BITS,
                        COLBITS     => gMEM_COL_BITS,
                        DATABITS    => gMEM_DQ_PER_DQS
                    )
                    port map (
                        clk    => clk_to_ram,
                        clk_n  => clk_to_ram_n,
                        cke    => cke_delayed(i),
                        cs_n   => cs_n_delayed(i),
                        ras_n  => ras_n_delayed,
                        cas_n  => cas_n_delayed,
                        we_n   => we_n_delayed,
                        dm     => dm_delayed(j),
                        ba     => ba_delayed,
                        addr   => a_delayed(gMEM_ROW_BITS - 1 downto 0),
                        dq     => mem_dq(gMEM_DQ_PER_DQS * (j + 1) - 1 downto gMEM_DQ_PER_DQS * j),
                        dqs    => mem_dqs(j)
                    );
            end generate; -- all chips
        end generate; -- all sides
vhdl_ddr_mem_inst
    
    $vhdl_mem_model_component=<<vhdl_ddr_component;
    component generic_ddr_sdram_rtl is
    generic (                                  
        ROWBITS  : integer := 12;
        DATABITS : integer :=  8;
        COLBITS  : integer := 10;
        BANKBITS : integer :=  2
    );
    PORT (     
        Dq    : inout std_logic_vector (DATABITS - 1 downto 0);
        Dqs   : inout std_logic;
        Addr  : in    std_logic_vector (ROWBITS - 1 downto 0);
        Ba    : in    std_logic_vector (1 downto 0);
        Clk   : in    std_logic;
        Clk_n : in    std_logic;
        Cke   : in    std_logic;
        Cs_n  : in    std_logic;
        Ras_n : in    std_logic;
        Cas_n : in    std_logic;
        We_n  : in    std_logic;
        Dm    : in    std_logic
    );
    end component generic_ddr_sdram_rtl;
vhdl_ddr_component
}


if ($gFEDBACK_CLOCK_MODE eq "true") {
$vhdl_etb_fclk_port_map=<<vhdl_etb_fclk_port_map;
        $gCLOCKFEEDBACK_IN_PIN_NAME   => fedback_clk,
        fedback_clk_out               => fedback_clk_out,

vhdl_etb_fclk_port_map
$vhdl_etb_fclk_delay=<<vhdl_etb_fclk_delay;
    fedback_clk      <= transport fedback_clk_out after GATE_BOARD_FEDBACKCLK_DELAY * 1 ps;
vhdl_etb_fclk_delay
}

print ETB_OUT  <<PORTSZZ;

library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all;
use ieee.numeric_std.all;
use std.textio.all;

-- << START MEGAWIZARD INSERT ENTITY
entity ${gTOPLEVEL_NAME}_tb is
-- << END MEGAWIZARD INSERT ENTITY
    generic (

-- << START MEGAWIZARD INSERT GENERICS
        gMEM_CHIPSELS          : in integer := $gMEM_CHIPSELS;
        gMEM_BANK_BITS         : in integer := $gMEM_BANK_BITS;
        gMEM_ROW_BITS          : in integer := $gMEM_ROW_BITS;
        gMEM_COL_BITS          : in integer := $gMEM_COL_BITS;
        gMEM_DQ_PER_DQS        : in integer := $gMEM_DQ_PER_DQS;
        gLOCAL_DATA_BITS       : in integer := $gLOCAL_DATA_BITS;
        gNUM_CLOCK_PAIRS       : in integer := $gNUM_CLOCK_PAIRS;
        RTL_ROUNDTRIP_CLOCKS   : in real    := $gRTL_ROUNDTRIP_CLOCKS;
        CLOCK_TICK_IN_PS       : in integer := $gCLOCK_PERIOD_IN_PS;
        REGISTERED_DIMM        : in boolean := $gREG_DIMM;
        BOARD_DQS_DELAY        : in integer := $gTPD_DQS_TRACE_TOTAL_NOM;
        BOARD_CLK_DELAY        : in integer := $gTPD_CLOCK_TRACE_NOM;
        BOARD_FEDBACKCLK_DELAY : in integer := $gTPD_CLOCKFEEDBACK_TRACE_NOM;

        TINIT_CLOCKS           : in integer := $gTINIT_CLOCKS;
-- << END MEGAWIZARD INSERT GENERICS

        RTL_DELAYS             : in integer := 1;  -- set to zero for Gatelevel
        USE_GENERIC_MEMORY_MODEL : in boolean := FALSE;

        REF_CLOCK_TICK_IN_PS   : in integer := $gCLOCK_PERIOD_IN_PS  --edit if you change your PLL reference clock frequency

    );
end;

-- << START MEGAWIZARD INSERT ARCHITECTURE
architecture rtl of ${gTOPLEVEL_NAME}_tb is
-- << END MEGAWIZARD INSERT ARCHITECTURE

    -------------------------------------------------------------------------------
    -- Functions needed in VHDL 
    function auk_to_integer (value: std_logic_vector) return integer is
    constant V: std_logic_vector(1 to value'length) := value;
    variable result: integer := 0;
    variable bit0: integer := 0;
    variable err: integer := 0;
    begin
        for i in 1 to value'length loop
            case V(i) is
            when '0' => bit0 := 0;
            when '1' => bit0 := 1;
            when others => err := 1;
            end case;
            result := (result * 2) + bit0;
        end loop;
        if (err = 0) then return result;
        else
            assert false report "auk_to_integer:: There is an 'U'|'X'|'W'|'Z'|'-' in an arithmetic operand, and it has been converted to 0." severity warning;
            return 0;
        end if;
    end auk_to_integer;

    function auk_to_string (value: integer; base: integer; size: integer) return string is
        variable V: integer := value;
        variable Result: string(1 to size);
        variable Width: natural := 0;
        constant MAX: INTEGER := 2147483647;
    begin
        assert ((base = 2) or (base=10) or (base=16))
            report "invalid base"
            severity ERROR;
        if V < 0 then
            V := (V + MAX) + 1;
        end if;
        for I in Result'Reverse_range loop
            case V mod base is
            when 0 => Result(I) := '0';
            when 1 => Result(I) := '1';
            when 2 => Result(I) := '2';
            when 3 => Result(I) := '3';
            when 4 => Result(I) := '4';
            when 5 => Result(I) := '5';
            when 6 => Result(I) := '6';
            when 7 => Result(I) := '7';
            when 8 => Result(I) := '8';
            when 9 => Result(I) := '9';
            when 10 => Result(I) := 'a';
            when 11 => Result(I) := 'b';
            when 12 => Result(I) := 'c';
            when 13 => Result(I) := 'd';
            when 14 => Result(I) := 'e';
            when 15 => Result(I) := 'f';
            when others =>
                      Result(I) := '?';
            end case;
            if V > 0 then
                Width := Width + 1;
            end if;
            V := V / base;
        end loop;
        if value < 0 then
            Result(Result'Length - Width) := '-';
            Width := Width + 1;
        end if;
        if Width = 0 then
            Width := 1;
        end if;
        -- pad to at least size wide
        if (Width < size) then
            Width := size;
        end if;

        return Result(Result'Length - Width + 1 to Result'Length);
    end auk_to_string;
    
    function auk_to_string (value: std_logic_vector; base: integer; size: integer) return string is
        variable ivalue : integer;
    begin
        ivalue := auk_to_integer(value);
        return auk_to_string(ivalue, base, size);
    end auk_to_string;

    -- override the "=" function because it doesn't work very well when comparing 'Z's
    function "=" (a, b : std_logic_vector) return boolean is
        variable a_bit, b_bit : std_logic;
        variable result : boolean;
    begin
        result := true;

        for i in a'reverse_range loop
            a_bit := a(i);
            b_bit := b(i);

            if (a_bit /= b_bit) then
                result := false;
            end if;

        end loop;

        return result;
    end; -- overridden "=" function

    
    
    -------------------------------------------------------------------------------
    -- Component for the generic memory model - you should replace this with the model you are using
$vhdl_mem_model_component
    
    -------------------------------------------------------------------------------


    -- Delay the incoming DQ & DQS to mimic the SDRAM round trip delay
    -- The round trip delay is now modeled inside the datapath (<your core name>_auk_ddr_dqs_group.v/vhd) for RTL simulation.
    constant SAMPLE_DELAY : integer := 0; -- RTL only

    constant GATE_BOARD_DQS_DELAY  : integer := BOARD_DQS_DELAY * abs(RTL_DELAYS-1);            -- Gate level timing only
    constant GATE_BOARD_CLK_DELAY  : integer := BOARD_CLK_DELAY * abs(RTL_DELAYS-1);            -- Gate level timing only
    constant GATE_BOARD_FEDBACKCLK_DELAY  : integer := BOARD_FEDBACKCLK_DELAY * abs(RTL_DELAYS-1);            -- Gate level timing only

    signal cmd_bus_watcher_enabled  : std_logic := '0';

    signal   clk         : std_logic := '0';
    signal   clk_n       : std_logic := '1';

    signal   reset_n        : std_logic;
    signal   a              : std_logic_vector(gMEM_ROW_BITS - 1 downto 0);
    signal   ba             : std_logic_vector(gMEM_BANK_BITS - 1 downto 0);
    signal   cs_n           : std_logic_vector(gMEM_CHIPSELS - 1 downto 0);
    signal   cke            : std_logic_vector(gMEM_CHIPSELS - 1 downto 0);
    signal   odt            : std_logic_vector(gMEM_CHIPSELS - 1 downto 0);
    signal   ras_n          : std_logic;
    signal   cas_n          : std_logic;
    signal   we_n           : std_logic;

    signal   dm             : std_logic_vector(gLOCAL_DATA_BITS / 2 / gMEM_DQ_PER_DQS - 1 downto 0);

    signal stratix_dqs_ref_clk    : std_logic;  -- only used on stratix to provide external dll reference clock
    signal fedback_clk            : std_logic;  -- only used in fedback clock mode
    signal fedback_clk_out        : std_logic;  -- only used in fedback clock mode

    signal clk_to_sdram    : std_logic_vector(gNUM_CLOCK_PAIRS-1 downto 0);
    signal clk_to_sdram_n  : std_logic_vector(gNUM_CLOCK_PAIRS-1 downto 0);

    signal clk_to_ram      : std_logic;
    signal clk_to_ram_n    : std_logic;

    signal a_delayed       : std_logic_vector(gMEM_ROW_BITS - 1 downto 0);
    signal ba_delayed      : std_logic_vector(gMEM_BANK_BITS - 1 downto 0);
    signal cke_delayed     : std_logic_vector(gMEM_CHIPSELS - 1 downto 0);
    signal odt_delayed     : std_logic_vector(gMEM_CHIPSELS - 1 downto 0);
    signal cs_n_delayed    : std_logic_vector(gMEM_CHIPSELS - 1 downto 0);
    signal ras_n_delayed   : std_logic;
    signal cas_n_delayed   : std_logic;
    signal we_n_delayed    : std_logic;
    signal dm_delayed      : std_logic_vector(gLOCAL_DATA_BITS / 2 / gMEM_DQ_PER_DQS - 1 downto 0);

    signal fpga_dq        : std_logic_vector(gLOCAL_DATA_BITS / 2 - 1 downto 0) := (others => 'Z');
    signal mem_dq         : std_logic_vector(gLOCAL_DATA_BITS / 2 - 1 downto 0) := (others => 'Z');
    signal fpga_dqs       : std_logic_vector(gLOCAL_DATA_BITS / 2 / gMEM_DQ_PER_DQS - 1 downto 0) := (others => 'Z');
    signal mem_dqs        : std_logic_vector(gLOCAL_DATA_BITS / 2 / gMEM_DQ_PER_DQS - 1 downto 0) := (others => 'Z');
    signal mem_dqsn       : std_logic_vector(gLOCAL_DATA_BITS / 2 / gMEM_DQ_PER_DQS - 1 downto 0) := (others => 'Z');
    signal mem_rdqsn_unused : std_logic_vector(gLOCAL_DATA_BITS / 2 / gMEM_DQ_PER_DQS - 1 downto 0) := (others => 'Z');
    signal dq_lock          : std_logic := 'Z';
    signal dqs_lock         : std_logic := 'Z';

    signal all_dq_z        : std_logic_vector(gLOCAL_DATA_BITS / 2 - 1 downto 0) := (others => 'Z');
    signal all_dqs_z       : std_logic_vector(gLOCAL_DATA_BITS / 2 / gMEM_DQ_PER_DQS - 1 downto 0) := (others => 'Z');

    signal zero_one        : std_logic_vector(gMEM_BANK_BITS - 1 downto 0) := (others => '0'); 

    signal test_complete   : std_logic;
    -- counter to count the number of sucessful read and write loops
    signal test_complete_count : integer;

    signal pnf             : std_logic;
    signal pnf_per_byte    : std_logic_vector(gLOCAL_DATA_BITS/8 - 1 downto 0);

    signal clk_to_buf       : std_logic;
    signal clk_from_buf     : std_logic;

begin

    zero_one(0) <= '1';
    
-- << START MEGAWIZARD INSERT DUT_INSTANCE_NAME
dut : entity work.${gTOPLEVEL_NAME}
-- << END MEGAWIZARD INSERT DUT_INSTANCE_NAME
    port map
    (
        -- clocks and reset
        clock_source    =>  clk,          -- PLD input clock source from which all clocks are derived.
        reset_n         => reset_n,

-- << START MEGAWIZARD INSERT PORT_MAP
        $clock_pos_pin_name  =>  clk_to_sdram, 
        $clock_neg_pin_name  =>  clk_to_sdram_n,

$vhdl_etb_stratix_ref_clock
$vhdl_etb_fclk_port_map
        -- ddr sdram interface
$vhdl_etb_ddr2_port_map
        ${gDDR_PREFIX_NAME}cke       => cke,
        ${gDDR_PREFIX_NAME}cs_n      => cs_n,
        ${gDDR_PREFIX_NAME}ras_n     => ras_n,
        ${gDDR_PREFIX_NAME}cas_n     => cas_n,
        ${gDDR_PREFIX_NAME}we_n      => we_n,
        ${gDDR_PREFIX_NAME}ba        => ba,
        ${gDDR_PREFIX_NAME}a         => a,
        ${gDDR_PREFIX_NAME}dq        => fpga_dq,
        ${gDDR_PREFIX_NAME}dqs       => fpga_dqs,
        ${gDDR_PREFIX_NAME}dm        => dm,
-- << END MEGAWIZARD INSERT PORT_MAP

        test_complete   => test_complete,
        pnf_per_byte    => pnf_per_byte,
        pnf             => pnf


    );

    -- Generic memory model instantiation - you must edit this to match the memory model that you are using 
$vhdl_memory_inst

    process
    begin
       clk <= '0';
       clk_n <= '1';
       while (true) loop
           --wait for 10 ns;
           wait for (REF_CLOCK_TICK_IN_PS/2) * 1 ps;
           clk <= not clk;
           clk_n <= not clk_n;
       end loop;
       wait;
    end process;


    clk_to_ram      <= transport clk_to_sdram(0)   after GATE_BOARD_CLK_DELAY * 1 ps;
    clk_to_ram_n    <= NOT clk_to_ram;      -- mem model ignores clk_n ?

    -- << START MEGAWIZARD INSERT FEDBACK_CLOCK_DELAY
$vhdl_etb_fclk_delay
    -- << END MEGAWIZARD INSERT FEDBACK_CLOCK_DELAY


    process
    begin
        reset_n <= '1';
        wait until (clk'event and clk = '1');
        wait until (clk'event and clk = '1');
        wait until (clk'event and clk = '1');
        wait until (clk'event and clk = '1');
        wait until (clk'event and clk = '1');
        wait until (clk'event and clk = '1');
        reset_n <= '0';
        wait until (clk'event and clk = '1');
        wait until (clk'event and clk = '1');
        wait until (clk'event and clk = '1');
        wait until (clk'event and clk = '1');
        wait until (clk'event and clk = '1');
        wait until (clk'event and clk = '1');
        reset_n <= '1';
        wait;
    end process;



    -- control and data lines = 3 inches
    a_delayed       <=   transport a      after GATE_BOARD_CLK_DELAY * 1 ps + 1 ps;
    ba_delayed      <=   transport ba     after GATE_BOARD_CLK_DELAY * 1 ps + 1 ps;
    cke_delayed     <=   transport cke    after GATE_BOARD_CLK_DELAY * 1 ps + 1 ps;
    odt_delayed     <=   transport odt    after GATE_BOARD_CLK_DELAY * 1 ps + 1 ps;  -- ddr2 only
    cs_n_delayed    <=   transport cs_n   after GATE_BOARD_CLK_DELAY * 1 ps + 1 ps;
    ras_n_delayed   <=   transport ras_n  after GATE_BOARD_CLK_DELAY * 1 ps + 1 ps;
    cas_n_delayed   <=   transport cas_n  after GATE_BOARD_CLK_DELAY * 1 ps + 1 ps;
    we_n_delayed    <=   transport we_n   after GATE_BOARD_CLK_DELAY * 1 ps + 1 ps;
    dm_delayed      <=   transport dm     after GATE_BOARD_CLK_DELAY * 1 ps + 1 ps;



-- ---------------------------------------------------------------

    endit : process
    variable count          : integer := 0;
    variable ln : line;

    begin
        -- Stop simulation after test_complete or TINIT + 20000 clocks
        while ((count < (TINIT_CLOCKS+20000) ) and (test_complete /= '1')) loop
            count := count + 1;
            wait until clk_to_sdram(0)'event and clk_to_sdram(0) = '0';
        end loop;
        if (test_complete = '1') then
            if (pnf = '1') then
                write(ln, now);
                write(ln, string'("          --- SIMULATION PASSED --- "));
                writeline(output, ln);
                ASSERT false REPORT "--- SIMULATION PASSED ---" SEVERITY FAILURE ;
            else
                write(ln, now);
                write(ln, string'("          --- SIMULATION FAILED --- "));
                writeline(output, ln);
                ASSERT false REPORT "--- SIMULATION FAILED ---" SEVERITY FAILURE ;
            end if;
        else
                write(ln, now);
                write(ln, string'("          --- SIMULATION FAILED, DID NOT COMPLETE --- "));
                writeline(output, ln);
                ASSERT false REPORT "--- SIMULATION FAILED, DID NOT COMPLETE ---" SEVERITY FAILURE ;
        end if;
        wait;
    end process;

    process(clk_to_sdram(0), reset_n)
    begin
        if (reset_n = '0') then
            test_complete_count <= 0;
        elsif (clk_to_sdram(0)'event and clk_to_sdram(0) = '1') then
                if (test_complete = '1') then
                    test_complete_count <= test_complete_count + 1;
                end if;
        end if;

    end process;






-- ---------------------------------------------------------------
--******************************* DQ  ****************************
    process(mem_dq, dq_lock)
    begin
        if (dq_lock = '0') then
            fpga_dq <= transport mem_dq after (GATE_BOARD_DQS_DELAY + SAMPLE_DELAY)* 1 ps + 1 ps;
        end if;
    end process;

    process(fpga_dq, dq_lock)
    begin
        if (dq_lock = '1') then
            mem_dq <= transport fpga_dq after GATE_BOARD_DQS_DELAY * 1 ps + 1 ps;
        end if;
    end process;

    process(mem_dq, fpga_dq, dq_lock)
    begin
         if (mem_dq /= all_dq_z) and (fpga_dq = all_dq_z) and (dq_lock = 'Z') then
            dq_lock <= '0';
         elsif (mem_dq = all_dq_z) and (fpga_dq /= all_dq_z) and (dq_lock = 'Z') then
            dq_lock <= '1';
         elsif (mem_dq = all_dq_z) and (fpga_dq = all_dq_z) then
            dq_lock <= 'Z';
         end if;
    end process;
--******************************* DQ  ****************************




--******************************* DQS ****************************
    process(mem_dqs, dqs_lock)
    begin
        if (dqs_lock = '0') then
            fpga_dqs <= transport mem_dqs after ((GATE_BOARD_DQS_DELAY )+ SAMPLE_DELAY) * 1 ps + 1 ps;
        end if;
    end process;

    process(fpga_dqs, dqs_lock)
    begin
        if (dqs_lock = '1') then
            mem_dqs <= transport fpga_dqs after ((GATE_BOARD_DQS_DELAY)) * 1 ps + 1 ps;
        end if;
    end process;

    process(mem_dqs, fpga_dqs, dqs_lock)
    begin
         if (mem_dqs /= all_dqs_z) and (fpga_dqs = all_dqs_z) and (dqs_lock = 'Z') then
            dqs_lock <= '0';
         elsif (mem_dqs = all_dqs_z) and (fpga_dqs /= all_dqs_z) and (dqs_lock = 'Z') then
            dqs_lock <= '1';
         elsif (mem_dqs = all_dqs_z) and (fpga_dqs = all_dqs_z) then
            dqs_lock <= 'Z';
         end if;
    end process;
--******************************* DQS ****************************






    -- Watch the SDRAM command bus
    process (clk_to_ram)
        variable cmd_bus : std_logic_vector(2 downto 0);
        variable ln : line;
    begin
    if (clk_to_ram'event and clk_to_ram = '1') then
        if (TRUE) then

            cmd_bus := (ras_n_delayed, cas_n_delayed, we_n_delayed);
            case cmd_bus is
                when "000" =>       -- LMR command
                    write(ln, now);

                    if (ba_delayed = zero_one) then
                        write(ln, string'("          ELMR     settings = "));

                        if (a_delayed(0) = '0') then
                            write(ln, string'("DLL enable"));
                        end if;
                    else
                        write(ln, string'("          LMR      settings = "));

                        case a_delayed(2 downto 0) is
                            when "001" => write(ln, string'("BL = 2,"));
                            when "010" => write(ln, string'("BL = 4,"));
                            when "011" => write(ln, string'("BL = 8,"));
                            when others => write(ln, string'("BL = ??,"));
                        end case;

                        case a_delayed(6 downto 4) is
                            when "010" => write(ln, string'(" CL = 2.0,"));
                            when "110" => write(ln, string'(" CL = 2.5,"));
                            when "011" => write(ln, string'(" CL = 3.0,"));
                            when "100" => write(ln, string'(" CL = 4.0,"));
                            when "101" => write(ln, string'(" CL = 5.0,"));
                            when others => write(ln, string'(" CL = ??,"));
                        end case;

                        if (a_delayed(8) = '1') then
                            write(ln, string'(" DLL reset"));
                        end if;

                    end if;

                    writeline(output, ln);
                when "001" =>       -- ARF command
                    write(ln, now);
                    write(ln, string'("          ARF "));
                    writeline(output, ln);
                when "010" =>       -- PCH command
                    write(ln, now);
                    write(ln, string'("          PCH"));
                    if (a_delayed(10) = '1') then
                        write(ln, string'(" all banks "));
                    else
                        write(ln, string'(" bank "));
                        write(ln, auk_to_string(ba_delayed,16,gMEM_BANK_BITS));
                    end if;
                    writeline(output, ln);
                when "011" =>       -- ACT command
                    write(ln, now);
                    write(ln, string'("          ACT     row address "));
                    write(ln, auk_to_string(a_delayed,16,gMEM_ROW_BITS));
                    write(ln, string'(                               " bank "));
                    write(ln, auk_to_string(ba_delayed,16,gMEM_BANK_BITS));
                    writeline(output, ln);
                when "100" =>       -- WR command
                    write(ln, now);
                    write(ln, string'("          WR to   col address "));
                    write(ln, auk_to_string(a_delayed,16,gMEM_ROW_BITS));
                    write(ln, string'(                               " bank "));
                    write(ln, auk_to_string(ba_delayed,16,gMEM_BANK_BITS));
                    writeline(output, ln);
                when "101" =>       -- RD command
                    write(ln, now);
                    write(ln, string'("          RD from col address "));
                    write(ln, auk_to_string(a_delayed,16,gMEM_ROW_BITS));
                    write(ln, string'(                               " bank "));
                    write(ln, auk_to_string(ba_delayed,16,gMEM_BANK_BITS));
                    writeline(output, ln);
                when "110" =>       -- BT command
                    write(ln, now);
                    write(ln, string'("          BT "));
                    writeline(output, ln);
                when "111" => null; -- NOP command
                when others => null;
            end case;
        else
        end if; -- if enabled
    end if;

    end process;


end rtl;





PORTSZZ

}



sub verilog_write_etb_header {
### HEADER

$header_title = "Example top level testbench for $gWRAPPER_NAME DDR SDRAM Controller";
$header_filename = $gTOPLEVEL_NAME . "_tb" . $file_ext;
$header_revision = "V" . $gWIZARD_VERSION;


print ETB_OUT  <<HEADERZZ;
//------------------------------------------------------------------------------
// This confidential and proprietary software may be used only as authorized by
// a licensing agreement from Altera Corporation.
//
// (C) COPYRIGHT 2005 ALTERA CORPORATION
// ALL RIGHTS RESERVED
//
// The entire notice above must be reproduced on all authorized copies and any
// such reproduction must be pursuant to a licensing agreement from Altera.
//
// Title        : $header_title
// Project      : DDR SDRAM Controller
//
// File         : $header_filename
//
// Revision     : $header_revision
//
// Abstract:
// Automatically generated testbench for the example top level design to allow
// functional and timing simulation.
//
//------------------------------------------------------------------------------
//
// *************** This is a MegaWizard generated file ****************
//
// If you need to edit this file make sure the edits are not inside any 'MEGAWIZARD'
// text insertion areas.
// (between "<< START MEGAWIZARD INSERT" and "<< END MEGAWIZARD INSERT" comments)
//
// Any edits inside these delimiters will be overwritten by the megawizard if you
// re-run it.
//
// If you really need to make changes inside these delimiters then delete
// both 'START' and 'END' delimiters.  This will stop the megawizard updating this
// section again.
//
//----------------------------------------------------------------------------------
// << START MEGAWIZARD INSERT PARAMETER_LIST
// Parameters:
//
// Device Family                      : $gFAMILY
// local Interface Data Width         : $gLOCAL_DATA_BITS
// MEM_CHIPSELS                       : $gMEM_CHIPSELS
// MEM_BANK_BITS                      : $gMEM_BANK_BITS
// MEM_ROW_BITS                       : $gMEM_ROW_BITS
// MEM_COL_BITS                       : $gMEM_COL_BITS
// LOCAL_DATA_BITS                    : $gLOCAL_DATA_BITS
// NUM_CLOCK_PAIRS                    : $gNUM_CLOCK_PAIRS
// RTL_ROUNDTRIP_CLOCKS               : $gRTL_ROUNDTRIP_CLOCKS
// CLOCK_TICK_IN_PS                   : $gCLOCK_PERIOD_IN_PS
// REGISTERED_DIMM                    : $gREG_DIMM
// BOARD_DQS_DELAY                    : $gTPD_DQS_TRACE_TOTAL_NOM
// BOARD_CLK_DELAY                    : $gTPD_CLOCK_TRACE_NOM
// TINIT_CLOCKS                       : $gTINIT_CLOCKS
// << END MEGAWIZARD INSERT PARAMETER_LIST
//----------------------------------------------------------------------------------
// << MEGAWIZARD PARSE FILE DDR${gWIZARD_VERSION}


`timescale 1 ps/1 ps

HEADERZZ
}

sub verilog_write_etb_portlist {
### DATAPATH PORTS ETC

if (($gFAMILY eq "Stratix") & ($gENABLE_CAPTURE_CLK ne "true")) {
$verilog_etb_stratix_ref_clock=<<verilog_etb_stratix_ref_clock
        .stratix_dqs_ref_clk(stratix_dqs_ref_clk),
        .stratix_dqs_ref_clk_out(stratix_dqs_ref_clk),
verilog_etb_stratix_ref_clock
}

if ($gMEM_TYPE eq "ddr2_sdram") {
$verilog_etb_ddr2_port_map=<<verilog_etb_ddr2_port_map;
        .${gDDR_PREFIX_NAME}odt(odt),
verilog_etb_ddr2_port_map
}

if ($gFEDBACK_CLOCK_MODE eq "true") {
$verilog_etb_fclk_port_map=<<verilog_etb_fclk_port_map;
        .$gCLOCKFEEDBACK_IN_PIN_NAME(fedback_clk),
        .fedback_clk_out(fedback_clk_out),
verilog_etb_fclk_port_map
$verilog_etb_fclk_delay=<<verilog_etb_fclk_delay;
    assign fedback_clk = fedback_clk_out;
verilog_etb_fclk_delay
}


$RTL_ROUNDTRIP_90DEGS=0;
$RTL_ROUNDTRIP_90DEGS = int($gRTL_ROUNDTRIP_CLOCKS * 4);

my $mem_data_width = $gLOCAL_DATA_BITS / 2;

print ETB_OUT  <<PORTSZZ;


// << START MEGAWIZARD INSERT MODULE
module ${gTOPLEVEL_NAME}_tb ();
// << END MEGAWIZARD INSERT MODULE

    // << START MEGAWIZARD INSERT PARAMS
    parameter gMEM_CHIPSELS     = $gMEM_CHIPSELS;
    parameter gMEM_BANK_BITS    = $gMEM_BANK_BITS;
    parameter gMEM_ROW_BITS     = $gMEM_ROW_BITS;
    parameter gMEM_COL_BITS     = $gMEM_COL_BITS;
    parameter gLOCAL_DATA_BITS  = $gLOCAL_DATA_BITS;
    parameter gNUM_CLOCK_PAIRS  = $gNUM_CLOCK_PAIRS;
    parameter RTL_ROUNDTRIP_CLOCKS  = $gRTL_ROUNDTRIP_CLOCKS;
    parameter CLOCK_TICK_IN_PS  = $gCLOCK_PERIOD_IN_PS;
    parameter REGISTERED_DIMM   = 1'b0;
    parameter BOARD_DQS_DELAY   = $gTPD_DQS_TRACE_TOTAL_NOM;
    parameter BOARD_CLK_DELAY   = $gTPD_CLOCK_TRACE_NOM;
    parameter BOARD_FEDBACKCLK_DELAY  = $gTPD_CLOCKFEEDBACK_TRACE_NOM;

    parameter TINIT_CLOCKS  = $gTINIT_CLOCKS;
    // << END MEGAWIZARD INSERT PARAMS

    // set to zero for Gatelevel
    parameter RTL_DELAYS = 1;
    parameter USE_GENERIC_MEMORY_MODEL  = 1'b0;
    parameter REF_CLOCK_TICK_IN_PS  = $gCLOCK_PERIOD_IN_PS;  //edit if you change your PLL reference clock frequency

    // delay the incoming DQ & DQS to mimick the SDRAM round trip delay
    // parameter D90_DEG_DELAY = CLOCK_TICK_IN_PS / 4; // RTL only

    // The round trip delay is now modeled inside the datapath (<your core name>_auk_ddr_dqs_group.v/vhd) for RTL simulation.
    parameter D90_DEG_DELAY = 0; //RTL only

    parameter GATE_BOARD_DQS_DELAY = BOARD_DQS_DELAY * (RTL_DELAYS ? 0 : 1); // Gate level timing only
    parameter GATE_BOARD_CLK_DELAY = BOARD_CLK_DELAY * (RTL_DELAYS ? 0 : 1); // Gate level timing only
    parameter GATE_BOARD_FEDBACKCLK_DELAY = BOARD_FEDBACKCLK_DELAY * (RTL_DELAYS ? 0 : 1); // Gate level timing only
    wire cmd_bus_watcher_enabled;
    reg clk;
    reg clk_n;
    wire #((CLOCK_TICK_IN_PS / 4) * 3 * 1) clk_shifted;
    reg reset_n;
    wire[gMEM_ROW_BITS - 1:0] a;
    wire[gMEM_BANK_BITS - 1:0] ba;
    wire[gMEM_CHIPSELS - 1:0] cs_n;
    wire[gMEM_CHIPSELS - 1:0] cke;
    wire[gMEM_CHIPSELS - 1:0] odt;       //DDR2 only
    wire ras_n;
    wire cas_n;
    wire we_n;
    wire[gLOCAL_DATA_BITS / 2 / $gMEM_DQ_PER_DQS - 1:0] dm;
    wire[gLOCAL_DATA_BITS / 2 / $gMEM_DQ_PER_DQS - 1:0] dqs;
    wire[gLOCAL_DATA_BITS / 2 - 1:0] dq;
    wire[gLOCAL_DATA_BITS - 1:0] datain;
    wire[gLOCAL_DATA_BITS - 1:0] dataout;


    wire stratix_dqs_ref_clk;   // only used on stratix to provide external dll reference clock
    wire #(GATE_BOARD_FEDBACKCLK_DELAY * 1) fedback_clk;           // only used in fedback clock mode
    wire fedback_clk_out;                                          // only used in fedback clock mode
    wire[gNUM_CLOCK_PAIRS - 1:0] clk_to_sdram;
    wire[gNUM_CLOCK_PAIRS - 1:0] clk_to_sdram_n;
    wire #(GATE_BOARD_CLK_DELAY * 1) clk_to_ram;
    wire clk_to_ram_n;
    wire[gMEM_ROW_BITS - 1:0] #(GATE_BOARD_CLK_DELAY * 1 + 1) a_delayed;
    wire[gMEM_BANK_BITS - 1:0] #(GATE_BOARD_CLK_DELAY * 1 + 1) ba_delayed;
    wire[gMEM_CHIPSELS - 1:0] #(GATE_BOARD_CLK_DELAY * 1 + 1) cke_delayed;
    wire[gMEM_CHIPSELS - 1:0] #(GATE_BOARD_CLK_DELAY * 1 + 1) odt_delayed;  //DDR2 only
    wire[gMEM_CHIPSELS - 1:0] #(GATE_BOARD_CLK_DELAY * 1 + 1) cs_n_delayed;
    wire #(GATE_BOARD_CLK_DELAY * 1 + 1) ras_n_delayed;
    wire #(GATE_BOARD_CLK_DELAY * 1 + 1) cas_n_delayed;
    wire #(GATE_BOARD_CLK_DELAY * 1 + 1) we_n_delayed;
    wire[gLOCAL_DATA_BITS / 2 / $gMEM_DQ_PER_DQS - 1:0] #(GATE_BOARD_CLK_DELAY * 1 + 1) dm_delayed;

    tri  [gLOCAL_DATA_BITS / 2 - 1:0] fpga_dq = \{$mem_data_width\{1'bz}};
    wire [gLOCAL_DATA_BITS / 2 - 1:0] fpga_dq_int = \{$mem_data_width\{1'bz}};
    wire [gLOCAL_DATA_BITS / 2 - 1:0] fpga_dq_int0 = \{$mem_data_width\{1'bz}};
    wire [gLOCAL_DATA_BITS / 2 - 1:0] fpga_dq_int1 = \{$mem_data_width\{1'bz}};
    wire [gLOCAL_DATA_BITS / 2 - 1:0] fpga_dq_int2 = \{$mem_data_width\{1'bz}};
    wire [gLOCAL_DATA_BITS / 2 - 1:0] fpga_dq_int3 = \{$mem_data_width\{1'bz}};
    wire [gLOCAL_DATA_BITS / 2 - 1:0] fpga_dq_int4 = \{$mem_data_width\{1'bz}};
    wire [gLOCAL_DATA_BITS / 2 - 1:0] fpga_dq_int5 = \{$mem_data_width\{1'bz}};
    wire [gLOCAL_DATA_BITS / 2 - 1:0] fpga_dq_int6 = \{$mem_data_width\{1'bz}};
    wire [gLOCAL_DATA_BITS / 2 - 1:0] fpga_dq_int7 = \{$mem_data_width\{1'bz}};
    wire [gLOCAL_DATA_BITS / 2 - 1:0] fpga_dq_int8 = \{$mem_data_width\{1'bz}};


    tri  [gLOCAL_DATA_BITS / 2 / $gMEM_DQ_PER_DQS - 1:0] fpga_dqs = \{$mem_data_width\{1'bz}};
    wire [gLOCAL_DATA_BITS / 2 / $gMEM_DQ_PER_DQS - 1:0] fpga_dqs_int = \{$mem_data_width\{1'bz}};
    wire [gLOCAL_DATA_BITS / 2 / $gMEM_DQ_PER_DQS - 1:0] fpga_dqs_int0 = \{$mem_data_width\{1'bz}};
    wire [gLOCAL_DATA_BITS / 2 / $gMEM_DQ_PER_DQS - 1:0] fpga_dqs_int1 = \{$mem_data_width\{1'bz}};
    wire [gLOCAL_DATA_BITS / 2 / $gMEM_DQ_PER_DQS - 1:0] fpga_dqs_int2 = \{$mem_data_width\{1'bz}};
    wire [gLOCAL_DATA_BITS / 2 / $gMEM_DQ_PER_DQS - 1:0] fpga_dqs_int3 = \{$mem_data_width\{1'bz}};
    wire [gLOCAL_DATA_BITS / 2 / $gMEM_DQ_PER_DQS - 1:0] fpga_dqs_int4 = \{$mem_data_width\{1'bz}};
    wire [gLOCAL_DATA_BITS / 2 / $gMEM_DQ_PER_DQS - 1:0] fpga_dqs_int5 = \{$mem_data_width\{1'bz}};
    wire [gLOCAL_DATA_BITS / 2 / $gMEM_DQ_PER_DQS - 1:0] fpga_dqs_int6 = \{$mem_data_width\{1'bz}};
    wire [gLOCAL_DATA_BITS / 2 / $gMEM_DQ_PER_DQS - 1:0] fpga_dqs_int7 = \{$mem_data_width\{1'bz}};
    wire [gLOCAL_DATA_BITS / 2 / $gMEM_DQ_PER_DQS - 1:0] fpga_dqs_int8 = \{$mem_data_width\{1'bz}};

    tri [gLOCAL_DATA_BITS / 2 - 1:0] mem_dq = \{$mem_data_width\{1'bz}};
    tri [gLOCAL_DATA_BITS / 2 / $gMEM_DQ_PER_DQS - 1:0] mem_dqs = \{$mem_data_width\{1'bz}};


    reg dqs_oe = 1'b0;
    reg dqs_active = 1'b0;

    reg dq_oe = 1'b0;
    reg dq_active = 1'b0;

    reg dq_lock;
    reg dqs_lock;
    wire [gLOCAL_DATA_BITS / 2 - 1:0] all_dq_z = \{$mem_data_width\{1'bz}};
    wire [gLOCAL_DATA_BITS / 2 / $gMEM_DQ_PER_DQS - 1:0] all_dqs_z = \{$mem_data_width\{1'bz}};

    wire [gMEM_BANK_BITS - 1:0] zero_one; //"01";
    wire test_complete;
    // counter to count the number of sucessful read and write loops
    integer test_complete_count;
    wire pnf;
    wire [gLOCAL_DATA_BITS / 8 - 1:0] pnf_per_byte;
    wire clk_to_buf;
    wire clk_from_buf;


    assign cmd_bus_watcher_enabled = 1'b0;

   // ddr sdram interface

    // << START MEGAWIZARD INSERT ENTITY
    ${gTOPLEVEL_NAME} dut (
    // << END MEGAWIZARD INSERT ENTITY
        .clock_source(clk),
        .reset_n(reset_n),

        // << START MEGAWIZARD INSERT PORT_MAP
        .${clock_pos_pin_name}(clk_to_sdram),
        .${clock_neg_pin_name}(clk_to_sdram_n),

$verilog_etb_stratix_ref_clock
$verilog_etb_fclk_port_map
$verilog_etb_ddr2_port_map
        .${gDDR_PREFIX_NAME}cke(cke),
        .${gDDR_PREFIX_NAME}cs_n(cs_n),
        .${gDDR_PREFIX_NAME}ras_n(ras_n),
        .${gDDR_PREFIX_NAME}cas_n(cas_n),
        .${gDDR_PREFIX_NAME}we_n(we_n),
        .${gDDR_PREFIX_NAME}ba(ba),
        .${gDDR_PREFIX_NAME}a(a),
        .${gDDR_PREFIX_NAME}dq(fpga_dq),
        .${gDDR_PREFIX_NAME}dqs(fpga_dqs),
        .${gDDR_PREFIX_NAME}dm(dm),
        // << END MEGAWIZARD INSERT PORT_MAP

        .test_complete(test_complete),
        .pnf_per_byte(pnf_per_byte),
        .pnf(pnf)
    );


    // << START MEGAWIZARD INSERT MEMORY_ARRAY
    // Instantiate an array of 8-bit DDR memories to match the datawidth & chipselect requirements
    // This will need updating to match the memory models you are using.

PORTSZZ


for ($i=0; $i < $gMEM_CHIPSELS; $i++) {
    for ($j=0; $j < $gLOCAL_DATA_BITS / 2 / $gMEM_DQ_PER_DQS ; $j++) {

if ($gMEM_TYPE eq "ddr2_sdram") {
print ETB_OUT  <<PORTSZZ;

    generic_ddr2_sdram_rtl # (
        .BANKBITS ($gMEM_BANK_BITS),
        .ROWBITS  ($gMEM_ROW_BITS),
        .COLBITS  ($gMEM_COL_BITS),
        .DATABITS ($gMEM_DQ_PER_DQS)
    ) memory_${i}_${j} (
        .DQ      (mem_dq[ $gMEM_DQ_PER_DQS* ($j+1) - 1 :  $gMEM_DQ_PER_DQS * $j]),
        .DQS     (mem_dqs[$j]),
        .ADDR    (a_delayed[$gMEM_ROW_BITS-1: 0]),
        .BA      (ba_delayed),
        .CLK     (clk_to_ram),
        .CLK_N   (clk_to_ram_n),
        .CKE     (cke_delayed[$i]),
        .CS_N    (cs_n_delayed[$i]),
        .RAS_N   (ras_n_delayed),
        .CAS_N   (cas_n_delayed),
        .WE_N    (we_n_delayed),
        .DM_RDQS (dm_delayed[$j]),
        .ODT     (odt_delayed),
        .RDQS_N  (),
        .DQS_N   ()
    );

PORTSZZ
} else {
print ETB_OUT  <<PORTSZZ;

    generic_ddr_sdram_rtl # (
        .BANKBITS ($gMEM_BANK_BITS),
        .ROWBITS  ($gMEM_ROW_BITS),
        .COLBITS  ($gMEM_COL_BITS),
        .DATABITS ($gMEM_DQ_PER_DQS)
    ) memory_${i}_${j} (
        .Dq    (mem_dq[ $gMEM_DQ_PER_DQS* ($j+1) - 1 :  $gMEM_DQ_PER_DQS * $j]),
        .Dqs   (mem_dqs[$j]),
        .Addr  (a_delayed[$gMEM_ROW_BITS-1: 0]),
        .Ba    (ba_delayed),
        .Clk   (clk_to_ram),
        .Clk_n (clk_to_ram_n),
        .Cke   (cke_delayed[$i]),
        .Cs_n  (cs_n_delayed[$i]),
        .Ras_n (ras_n_delayed),
        .Cas_n (cas_n_delayed),
        .We_n  (we_n_delayed),
        .Dm    (dm_delayed[$j])
    );

PORTSZZ
}
    }
}



print ETB_OUT  <<PORTSZZ;
    // << END MEGAWIZARD INSERT MEMORY_ARRAY


    always
    begin
        clk <= 1'b0 ;
        clk_n <= 1'b1 ;
        while (1'b1)
        begin
            #((REF_CLOCK_TICK_IN_PS / 2) * 1);
            clk <= ~clk ;
            clk_n <= ~clk_n ;
        end
    end

    assign clk_shifted = clk_to_sdram[0] ;
    assign clk_to_ram = clk_to_sdram[0] ;
    assign clk_to_ram_n = ~clk_to_ram ; // mem model ignores clk_n ?

    // << START MEGAWIZARD INSERT FEDBACK_CLOCK_DELAY
$verilog_etb_fclk_delay
    // << END MEGAWIZARD INSERT FEDBACK_CLOCK_DELAY


    initial
    begin
        reset_n <= 1'b0 ;
        @(clk);
        @(clk);
        @(clk);
        @(clk);
        @(clk);
        reset_n <= 1'b1 ;
    end

    // control and data lines = 3 inches
    assign a_delayed = a ;
    assign ba_delayed = ba ;
    assign cke_delayed = cke ;
    assign odt_delayed = odt ;
    assign cs_n_delayed = cs_n ;
    assign ras_n_delayed = ras_n ;
    assign cas_n_delayed = cas_n ;
    assign we_n_delayed = we_n ;
    assign dm_delayed = dm ;

    // ---------------------------------------------------------------
    initial
    begin : endit
        integer count;
        reg ln;
        count = 0;

        // Stop simulation after test_complete or TINIT + 20000 clocks
        while ((count < (TINIT_CLOCKS + 20000)) & (test_complete !== 1))
        begin
            count = count + 1;
            @(negedge clk_to_sdram[0]);
        end
        if (test_complete === 1)
        begin
            if (pnf)
            begin
                \$write(\$time);
                \$write("          --- SIMULATION PASSED --- ");
                \$stop;
            end
            else
            begin
                \$write(\$time);
                \$write("          --- SIMULATION FAILED --- ");
                \$stop;
            end
        end
        else
        begin
            \$write(\$time);
            \$write("          --- SIMULATION FAILED, DID NOT COMPLETE --- ");
            \$stop;
        end
    end

    always @(clk_to_sdram[0] or reset_n)
    begin
        if (!reset_n)
        begin
            test_complete_count <= 0 ;
        end
        else if ((clk_to_sdram[0]))
        begin
            if (test_complete)
            begin
                test_complete_count <= test_complete_count + 1 ;
            end
        end
    end


    assign #((GATE_BOARD_DQS_DELAY) + 1) fpga_dq_int = (dq_oe) ? mem_dq : all_dq_z;   // This is effectively the read dir so it should have 90 deg added

    assign                  fpga_dq_int0 = fpga_dq_int;
    assign #(D90_DEG_DELAY) fpga_dq_int1 = fpga_dq_int;
    assign #(D90_DEG_DELAY) fpga_dq_int2 = fpga_dq_int1;
    assign #(D90_DEG_DELAY) fpga_dq_int3 = fpga_dq_int2;
    assign #(D90_DEG_DELAY) fpga_dq_int4 = fpga_dq_int3;
    assign #(D90_DEG_DELAY) fpga_dq_int5 = fpga_dq_int4;
    assign #(D90_DEG_DELAY) fpga_dq_int6 = fpga_dq_int5;
    assign #(D90_DEG_DELAY) fpga_dq_int7 = fpga_dq_int6;
    assign #(D90_DEG_DELAY) fpga_dq_int8 = fpga_dq_int7;

    // << START MEGAWIZARD INSERT DQ_DELAYS
    assign fpga_dq = RTL_DELAYS ? fpga_dq_int${RTL_ROUNDTRIP_90DEGS} : fpga_dq_int;
    // << END MEGAWIZARD INSERT DQ_DELAYS



    assign #((GATE_BOARD_DQS_DELAY * 1 + 1)) mem_dq = (~dq_oe) ? fpga_dq: all_dq_z;

    always@(mem_dq or fpga_dq or dq_active)
    begin
        if ((mem_dq !== all_dq_z) && (dq_active == 1'b0) )
        begin
            dq_active = 1'b1;
            dq_oe = 1'b1;
        end

        if ((fpga_dq !== all_dq_z) && (dq_active == 1'b0))
        begin
            dq_active = 1'b1;
            dq_oe = 1'b0;
        end

        if ((mem_dq === all_dq_z) && (fpga_dq === all_dq_z))
        begin
            dq_active = 1'b0;
        end
    end




    assign #(GATE_BOARD_DQS_DELAY + 1) fpga_dqs_int = (dqs_oe) ? mem_dqs : all_dqs_z;   // This is effectively the read dir so it should have 90 deg added

    assign                  fpga_dqs_int0 = fpga_dqs_int;
    assign #(D90_DEG_DELAY) fpga_dqs_int1 = fpga_dqs_int;
    assign #(D90_DEG_DELAY) fpga_dqs_int2 = fpga_dqs_int1;
    assign #(D90_DEG_DELAY) fpga_dqs_int3 = fpga_dqs_int2;
    assign #(D90_DEG_DELAY) fpga_dqs_int4 = fpga_dqs_int3;
    assign #(D90_DEG_DELAY) fpga_dqs_int5 = fpga_dqs_int4;
    assign #(D90_DEG_DELAY) fpga_dqs_int6 = fpga_dqs_int5;
    assign #(D90_DEG_DELAY) fpga_dqs_int7 = fpga_dqs_int6;
    assign #(D90_DEG_DELAY) fpga_dqs_int8 = fpga_dqs_int7;

    // << START MEGAWIZARD INSERT DQS_DELAYS
    assign fpga_dqs = RTL_DELAYS ? fpga_dqs_int${RTL_ROUNDTRIP_90DEGS} : fpga_dqs_int;
    // << END MEGAWIZARD INSERT DQS_DELAYS



    assign #(((GATE_BOARD_DQS_DELAY)) * 1 + 1) mem_dqs = (~dqs_oe) ? fpga_dqs: all_dqs_z;

    always@(mem_dqs or fpga_dqs or dqs_active)
    begin
        if ((mem_dqs !== all_dqs_z) && (dqs_active == 1'b0) )
        begin
            dqs_active = 1'b1;
            dqs_oe = 1'b1;
        end

        if ((fpga_dqs !== all_dqs_z) && (dqs_active == 1'b0))
        begin
            dqs_active = 1'b1;
            dqs_oe = 1'b0;
        end

        if ((mem_dqs === all_dqs_z) && (fpga_dqs === all_dqs_z))
        begin
            dqs_active = 1'b0;
        end
    end


    reg[2:0] cmd_bus;
    reg ln_;


    //***********************************************************
    // Watch the SDRAM command bus
    always @(clk_to_ram)
    begin
        if (clk_to_ram)
        begin
            if (1'b1)
            begin
                cmd_bus = {ras_n_delayed, cas_n_delayed, we_n_delayed};
                case (cmd_bus)
                    3'b000 :
                        begin
                            // LMR command
                            \$write(\$time);
                            if (ba_delayed == zero_one)
                            begin
                                \$write("          ELMR     settings = ");
                                if (!(a_delayed[0]))
                                begin
                                    \$write("DLL enable");
                                end
                            end
                            else
                            begin
                                \$write("          LMR      settings = ");
                                case (a_delayed[2:0])
                                    3'b001 :
                                        begin
                                            \$write("BL = 2,");
                                        end
                                    3'b010 :
                                        begin
                                            \$write("BL = 4,");
                                        end
                                    3'b011 :
                                        begin
                                            \$write("BL = 8,");
                                        end
                                    default :
                                        begin
                                            \$write("BL = ??,");
                                        end
                                endcase
                                case (a_delayed[6:4])
                                    3'b010 :
                                        begin
                                            \$write(" CL = 2.0,");
                                        end
                                    3'b110 :
                                        begin
                                            \$write(" CL = 2.5,");
                                        end
                                    3'b011 :
                                        begin
                                            \$write(" CL = 3.0,");
                                        end
                                    3'b100 :
                                        begin
                                            \$write(" CL = 4.0,");
                                        end
                                    3'b101 :
                                        begin
                                            \$write(" CL = 5.0,");
                                        end
                                    default :
                                        begin
                                            \$write(" CL = ??,");
                                        end
                                endcase
                                if ((a_delayed[8]))
                                begin
                                    \$write(" DLL reset");
                                end
                            end
                            \$write("\\n");
                        end
                    3'b001 :
                        begin
                            // ARF command
                            \$write(\$time);
                            \$write("          ARF\\n");
                        end
                    3'b010 :
                        begin
                            // PCH command
                            \$write(\$time);
                            \$write("          PCH");
                            if ((a_delayed[10]))
                            begin
                                \$write(" all banks \\n");
                            end
                            else
                            begin
                                \$write(" bank ");
                                \$write("%H\\n", ba_delayed);
                            end
                        end
                    3'b011 :
                        begin
                            // ACT command
                            \$write(\$time);
                            \$write("          ACT     row address ");
                            \$write("%H", a_delayed);
                            \$write(" bank ");
                            \$write("%H\\n", ba_delayed);
                        end
                   3'b100 :
                        begin
                            // WR command
                            \$write(\$time);
                            \$write("          WR to   col address ");
                            \$write("%H", a_delayed);
                            \$write(" bank ");
                            \$write("%H\\n", ba_delayed);
                        end
                   3'b101 :
                        begin
                            // RD command
                            \$write(\$time);
                            \$write("          RD from col address ");
                            \$write("%H", a_delayed);
                            \$write(" bank ");
                            \$write("%H\\n", ba_delayed);
                        end
                   3'b110 :
                        begin
                            // BT command
                            \$write(\$time);
                            \$write("          BT ");
                        end
                   3'b111 :
                        begin
                            // NOP command
                        end
                endcase
            end
            else
            begin
            end // if enabled
        end
    end

endmodule

PORTSZZ
}

