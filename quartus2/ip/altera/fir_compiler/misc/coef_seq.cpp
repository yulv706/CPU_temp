/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
//
// Revision Control Information
//
// $RCSfile: coef_seq.cpp,v $
// $Source: /cvs/uksw/dsp_cores/FIR/src/software/coeff_util/coef_seq.cpp,v $
//
// $Revision: #1 $
// $Date: 2009/02/04 $
// Author				:  Tony San? 
// Check in by :  $Author: max $
//
// Project      :  FIR
//
// Description	:
//
// ALTERA Proprietary and Confidential
// Copyright 2007 (c) Altera Corporation
// All rights reserved
//
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////


// Copyright (C) 1991-2004 Altera Corporation
// Any megafunction design, and related net list (encrypted or decrypted),
// support information, device programming or simulation file, and any other
// associated documentation or information provided by Altera or a partner
// under Altera's Megafunction Partnership Program may be used only to
// program PLD devices (but not masked PLD devices) from Altera.  Any other
// use of such megafunction design, net list, support information, device
// programming or simulation file, or any other related documentation or
// information is prohibited for any other purpose, including, but not
// limited to modification, reverse engineering, de-compiling, or use with
// any other silicon devices, unless such use is explicitly licensed under
// a separate agreement with Altera or a megafunction partner.  Title to
// the intellectual property, including patents, copyrights, trademarks,
// trade secrets, or maskworks, embodied in any such megafunction design,
// net list, support information, device programming or simulation file, or
// any other related documentation or information provided by Altera or a
// megafunction partner, remains with Altera, the megafunction partner, or
// their respective licensors.  No other licenses, including any licenses
// needed under any third party's intellectual property, are provided herein.
// Company : Altera Corp
// Filename : coef_seq.cpp
// Last Update : Nov 17, 2004
// Description:
// 	This open source C/C++ code is for creating the input coefficient sequences
//      for use with FIR filters generated by the FIR Compiler MegaCore
//
//
// The command to use coef_seq.exe is:
// coef_seq.exe <path to the input coefficient file>\input_file.txt 
// <path to the output coefficient file>\output_file.txt 
// <FIR structure> <coefficient store> <allow or disallow symmetry> 
// <number of calculations for MCV|coefficient bit width for others> 
// <number of coefficient sets> <filter rate> <filter factor> <coefficient bit width>


// where:                                                                  
// <FIR structure> is                                                   
// MCV - multi-cycle variable                                            
// SER - fully serial                                                    
// MBS - multi-bit serial                                                
// PAR - fully parallel                                                  
//
// <coefficient store> is                                               
// LC - logic cells                                                      
// M512 - M512 blocks                                                    
// M4K - M4K blocks                                                      
//
// <allow or disallow symmetry> is:                                     
// MSYM - Take advantage of symmetric coefficients                       
// NOSYM - Use non-symmetric coefficients                                
//
// <number of calculations for MCV/ coefficient bit width for others> is:
// for multi-cycle variable filters, the number of clock cycles to      
// calculate the result or all other filters, use the coefficient bit width                 
//
// <filter rate> is be specified as one of the following (SGL, INT, DEC)
// SGL - Single Rate FIR Filter                                          
// INT - Interpolating FIR Filter                                        
// DEC - Decimating FIR Filter                                           
//
// <filter factor> is an integer value representing the rate-changing factor.                                                                 
// For single-rate filters, this argument should be set to 1.           
// For multi-rate FIR filters, this argument should be an integer between 1z and 16.  

// <coefficient bit width> is the integer value representing the userspecified
// coefficient bit width, which ranges from 2-32.

// NOTE : The entire command line must be provided in a single line with no carriage \
// returns or line-feeds
//
// NOTE : For additional information on how to use this program, please refer to the
// FIR Compiler User Guide



//coef_seq.cpp : Defines the entry point for the console application.

#include <iostream>
#include <fstream>
#include <stdio.h>
#include <math.h>
using namespace std;

//the dummy one is added for consistency with netlist_writer
//AUTO should be 4
enum coef_store_type {LC, M512, M4K,DUMMY,AUTO};
enum struct_type {MCV, SER, MBS, PAR};
enum sym_chk {NOSYM,MSYM};
enum poly_type {SGL,INT,DEC};

char out_name[256];
int coef[2048];
int coef_ori[2048];
enum coef_store_type coef_store_type;
enum struct_type struct_type;
enum sym_chk sym_chk;
enum poly_type poly_type;
int poly_fact;
int num_coef_set;
int coef_bit_width;
int coef_length;
int coef_length_ori = 0;
int sym = 0;
long num_cycles = 1;
int num_mac;

void mcv_single_rate_reseq();
void distru_reseq();
void multi_rate_poly_mcv_reseq();
void deci_reseq();
void single_rate_out_write();
void multi_rate_poly_out_write();
void deci_out_write();
void itobi(char[32], int);

int num_coef_group;
int mcv_coef_length;
int group_size = 0;
int mem_width;
int length_wr;
int mcv_reload_zero_insert;


int main(int argc, char* argv[])
{
	int coef_set_width = 0;
//	int coef_width;

	int i,j;

	char in_name[256];
	char *non;

	char temp_char[20];

	int flag = 0;

	float max_value = (float)pow(2.0,36);// initial as m4k
	int width_index_ini = 5;
	int group_size_ini = 7 - coef_set_width;


	ofstream out_file;
//	ofstream temp_file;
	int arg_err = 0;

/***********************************************************************************************
// Parameters check
/*********************************************************************************************/

	if (argc >= 11 ) // if the user calls this program with no arguments ...
	{

		strcpy(in_name,argv[1]);// input file name, full path
		strcpy(out_name,argv[2]);// out file name, full path
		
		strcpy(temp_char, argv[3]);//structure type
		if( strcmp(temp_char, "MCV") == 0)
		{
			struct_type = MCV;
		}
		else if( strcmp(temp_char, "SER") == 0)
		{
			struct_type = SER;
		}
		else if( strcmp(temp_char, "MBS") == 0)
		{
			struct_type = MBS;
		}
		else if( strcmp(temp_char, "PAR") == 0)
		{
			struct_type = PAR;
		}
		else
		{
 			printf("ERROR of argv[3]:  Structure Type should be one of the following:MCV,SER,MBS,PAR\n");
			arg_err = 1;
		}
		strcpy(temp_char, argv[4]);//coef_storage type
		if( strcmp(temp_char, "LC") == 0)
		{
			coef_store_type = LC;
		}
		else if( strcmp(temp_char, "M512") == 0)
		{
			coef_store_type = M512;
		}
		else if( strcmp(temp_char, "M4K") == 0)
		{
			coef_store_type = M4K;
		}
		else if( strcmp(temp_char, "AUTO") == 0)
		{
			coef_store_type = AUTO;
		}		
		else
		{
			printf("ERROR of argv[4]:    Coef store type should be one of the following:LC M512,M4K or AUTO\n");
			arg_err = 1;
		}

		strcpy(temp_char, argv[5]);//NOSYM
		if( strcmp(temp_char, "NOSYM") == 0)
		{
			sym_chk = NOSYM;
		}
		else if( strcmp(temp_char, "MSYM") == 0)
		{
			sym_chk = MSYM;
		}
		else
		{
			printf("ERROR of argv[5]:    Pluse use NOSYM/MSYM\n");
			arg_err = 1;
		}

		if(struct_type == MCV)
		{
			num_cycles = strtol(argv[6], &non,10);//num of cycles
			if(num_cycles < 0 )
			{
				arg_err = 1;
				printf("ERROR of argv[6]:    num of calculation cycles should be positive\n");
			}
		}
		else
		{
			coef_bit_width = strtol(argv[6], &non,10);//num of coef_bit_width
			if(coef_bit_width < 0  || coef_bit_width > 32)
			{
				arg_err = 1;
				printf("ERROR of argv[6]:    coefficient bit width should be positive and less than 32\n");
			}
		}
		num_coef_set = strtol(argv[7], &non,10);//num of coefficient set
		if(num_coef_set < 0  || num_coef_set > 16)
		{
			arg_err = 1;
			printf("ERROR : argv[7] :    number of coefficient sets should be positive and less than 17\n");
		}

		strcpy(temp_char, argv[8]);//poly_type
		poly_type = SGL;
		if( strcmp(temp_char, "SGL") == 0)
		{
			poly_type = SGL;
		}
		else if( strcmp(temp_char, "INT") == 0)
		{
			poly_type = INT;
		}
		else if( strcmp(temp_char, "DEC") == 0)
		{
			poly_type = DEC;
		}
		else
		{
			printf("ERROR : argv[8]:    Filter rate description should be one of the following:SGL INT DEC\n");
			arg_err = 1;
		}


		poly_fact = strtol(argv[9], &non,10);//multi-rate factor
		if(poly_fact < 0  || poly_fact > 16)
		{
			arg_err = 1;
			printf("ERROR : argv[9]:    Multi rate factor should be an integer in the range 1 to 16\n");
		}
		else
		{
			if(poly_type == DEC && struct_type == MCV)
			{
			}
			else if(poly_fact>1)
			{
				num_coef_set = num_coef_set * poly_fact;
			}
		}
		
		coef_bit_width = strtol(argv[10], &non,10);//coefficient width
                if(coef_bit_width < 0  || coef_bit_width > 32)
                {
                        arg_err = 1;
                        printf("ERROR : argv[10]:    Coefficient width should be an integer in the range 2 to 32\n");
                }


		ifstream in_file(in_name, ios::in);
		//in_file.open(in_name, ios::in);
		if(in_file.is_open() == 0)
		{
			printf("ERROR argv[1]:  Can not open %s\n", argv[1]);
			return 1;
		}

		for (i = 0; i<2048; ++i)
		{
			coef[i] = 0;
		}

		j=0;
		i=0;
		double float_coef;
		char coef_line[256];
		while (!in_file.eof())
		{
			strcpy(coef_line, "\n");
 			in_file >>coef_line;
			if(coef_line[0] != '\n' && coef_line[0] != 0)
			{
				coef[i] = atoi(coef_line);
				float_coef = atof(coef_line);
				if(coef[i] != float_coef)
				{
					printf("ERROR argv[1]: %s can only contain fixed point numbers.\n", argv[1]);
				}
				++i;
			}
		}
		if(i == 0)
		{
			printf("ERROR argv[1]:  %s is empty.\n", argv[1]);
		}

		coef_length = i;
		for (i=0; i<2048; ++ i)
		{
			coef_ori[i] = coef[i];
		}

		sym = 1;
		 int half_len = (int)ceil(((double)coef_length)/2.0);
		 for (i = 0; i < half_len; ++i)
		 {
			if(coef[i] != coef[coef_length-1-i])
			{
				sym = 0;
			}
		 }
		 if(sym == 0)
		 {
			sym = -1;
			 for (i = 0; i < half_len; ++i)
			 {
				if(coef[i] != -coef[coef_length-1-i])
				{
					sym = 0;
				}
			 }
		 }

		if(sym == 0 && sym_chk == MSYM)
		{
			printf("The coefficients are non_symmetric.\n", argv[6]);
			arg_err = 1;
		}

		 if(sym_chk == NOSYM)
		 {
			 sym = 0;
		 }

		in_file.close();
/********************End of parameters check*****************************/
	}
	else
	{
		printf("Error:   This program requires 10 arguments! \n ");
		return 1;
	}

	if(arg_err == 1)
	{
		printf("Error:   Parameters is not right!!! \n ");
		return 1;
	}
	else
	{
		if(poly_type == SGL)
		{
			if(struct_type == MCV)
			{
				mcv_single_rate_reseq();
			}
			else
			{
				distru_reseq();
			}
			single_rate_out_write();
		}
//		else if(poly_type == DEC && sym != 0)
		else if(poly_type == DEC && struct_type == MCV)
		{
			deci_reseq();
			deci_out_write();

		}
		else if(poly_type == INT || poly_type == DEC)
		{
			if(struct_type == MCV)
			{
				multi_rate_poly_mcv_reseq();
			}
			else
			{
				distru_reseq();
			}
			multi_rate_poly_out_write();
		}
	}
	return 0;
}

void mcv_single_rate_reseq()
{
/****************************MCV FIR resequence Single rate************************/
	int tmp_coef[2048];
	int coef_one_mem = 0;
	int mem_num = 0;
	int half_len = (int)ceil(((double) coef_length)/2.0);
	int zeros_insert;
	int i,j,k;
	if(struct_type == MCV )
	{
		if(sym != 0 && (poly_type == SGL || poly_type == DEC))
		{coef_length = half_len;}
		num_mac = (int) ceil(((double) coef_length)/((double) num_cycles));
		int mcv_coef_length = num_mac * num_cycles;
		if(coef_store_type == M512 || coef_store_type == AUTO)
		{
			coef_one_mem = (int) floor(18.0/((double) coef_bit_width));
			if(coef_one_mem == 0)
			{
				coef_one_mem = 1;
			}

		}
		else if(coef_store_type == M4K)
		{
			coef_one_mem = (int) floor(36.0/((double) coef_bit_width));
		}
		else
		{
			coef_one_mem = 1;
		}

		mem_num = (int) ceil(((double) num_mac)/ ((double)coef_one_mem));
		mcv_reload_zero_insert = mem_num * coef_one_mem - num_mac;
		if(mem_num == 1)
		{
			mcv_reload_zero_insert = 0;
		}

		if(sym == 0)
		{
			zeros_insert = 0;
		}
		else
		{
			zeros_insert =(int) floor((double) (mcv_coef_length - coef_length));
		}

		for (i=0; i<2048; ++i)
		{
			tmp_coef[i] = 0;
		}

		for (i=0; i<coef_length; ++ i)
		{
			tmp_coef[i + int(zeros_insert)] = coef[i];
		}

		for (i=0; i<mcv_coef_length; ++ i)
		{
			coef[i] = tmp_coef[i];
		}

		k = 0;
		for (j=0; j<num_mac; ++j)
		{
			for (i=0; i<num_cycles; ++i)
			{
				k = i*num_mac + j;
				if (i==0)
				{
					tmp_coef[k] = coef[(num_cycles - 1) * num_mac + j];
				}
				else
				{
					tmp_coef[k] = coef[(i -1 ) * num_mac + j];
				}
			}
		}

		for (j=0; j<num_mac; ++j)
		{
			for (i=0; i<num_cycles; ++i)
			{
				k = i*num_mac + (num_mac - 1 - j);
				if(coef_store_type == LC)
				{
					coef[j*num_cycles + i] = tmp_coef[k];
				}
			}
		}
		mcv_coef_length = (num_mac + mcv_reload_zero_insert) * num_cycles;

		if(mcv_reload_zero_insert > 0)
		{
			for( i = 0; i < num_cycles; i++)
			{
				for(j = 0; j < num_mac + mcv_reload_zero_insert ; j++)
				{
					int ini_index = i * (num_mac) + j;
					int new_index = i * (num_mac + mcv_reload_zero_insert) + j;
					if(j < (mem_num-1) * coef_one_mem)
					{
						tmp_coef[new_index] = coef[ini_index];
					}
					else if(j < (mem_num-1) * coef_one_mem + mcv_reload_zero_insert)
					{
						tmp_coef[new_index] = 0;
					}
					else
					{
						tmp_coef[new_index] = coef[ini_index - mcv_reload_zero_insert];
					}
				}
			}
			for (i=0; i<2048; ++i)
			{
				coef[i] = tmp_coef[i] ;
			}
		}
	}

}
void distru_reseq()
{
/**********************************************************************************
*
* Reorder For distrubuted architecture 
* single and multi rate.
*
**********************************************************************************/
	int width_stage[6];
	int half_len = (int) ceil(((double) coef_length)/2.0);
	int coef_set_width = (int)ceil(log((double) num_coef_set)/log(2.0));
	int width_index_ini = 5;
	int group_size_ini = 7 - coef_set_width;
	float max_value;
	int width_index;
	int flag = 0;

	length_wr = (int)ceil((double)((double)coef_length/(double)poly_fact));
	if(length_wr<3)
	{
		length_wr = 3;
	}
	coef_length_ori = coef_length;
	if(poly_type==INT||poly_type==DEC)
	{
		coef_length = length_wr;
	}
	width_stage[0] = 1;
	width_stage[1] = 2;
	width_stage[2] = 4;
	width_stage[3] = 9;
	width_stage[4] = 18;
	width_stage[5] = 36;

	if(sym == 1)
	{
		coef_length = half_len;
	}

	if(coef_store_type == M512 || coef_store_type == AUTO) //M512
	{
		width_stage[5] = 0;
		if(coef_set_width<=4)
		{
			width_index_ini = 4;
			group_size_ini = 5 - coef_set_width;
		}
		else
		{
			width_index_ini = 4;
			group_size_ini = 1;
		}
		max_value = (float)pow(2.0,18);
	}
	else
	{
		width_index_ini = 5;
		group_size_ini = 7 - coef_set_width;
		if(coef_set_width<=6)
		{
			group_size_ini = 7 - coef_set_width;
		}
		else
		{
			group_size_ini = 1;
		}
		max_value = (float)pow(2.0,36);
	}

	group_size = group_size_ini;
	if( group_size > coef_length)
	{
		group_size = coef_length;
		mem_width = coef_bit_width + (int)ceil(log((double) group_size)/log(2.0));
	}
	else
	{
		width_index = width_index_ini;
		mem_width = coef_bit_width + (int)ceil(log((double) group_size)/log(2.0));
		if(group_size<length_wr){
			while(mem_width < width_stage[width_index])
			{
				flag =1;
				group_size++;
				width_index --;
				mem_width = coef_bit_width + (int) ceil(log((double) group_size)/log(2.0));
			}
			if(flag == 1)
			{
				group_size--;
				width_index ++;
				mem_width = coef_bit_width + (int) ceil(log((double) group_size)/log(2.0));
			}
			if(group_size>length_wr)
			{
				group_size = length_wr;
				mem_width = coef_bit_width + (int) ceil(log((double) group_size)/log(2.0));
			}
		}
	}
	num_coef_group = (int)ceil(((double)coef_length) /((double) group_size));


}
void multi_rate_poly_mcv_reseq()
{
/**********************************************************************************
*
* Reorder For Multi-Rate Coeficient Sets, MCV only
*
**********************************************************************************/
	int coef_mr[2048];
	int tmp_coef[2048];
	int coef_one_mem = 0;
	int mem_num = 0;
	int half_len =(int) ceil(((double) coef_length)/2.0);
	int mcv_coef_length;
	int i,j,k;
	int ai = 0;
	int bi = 0;
	int ci = 0;

	if(poly_type==INT||poly_type==DEC)
	{
		length_wr = (int)ceil((double)((double)(coef_length)/(double)poly_fact));
		if(length_wr<3)
		{
				length_wr = 3;
		}

		// Multi-Cycle Variable
		if(struct_type == MCV)
		{
			// Store to temporary array coef_mr[]
			num_mac = (int)ceil(((double) length_wr)/((double) num_cycles));
			mcv_coef_length = num_mac * num_cycles;
			if(coef_store_type == M512 || coef_store_type == AUTO)
			{
				coef_one_mem = (int) floor(18.0/((double) coef_bit_width));
				if(coef_one_mem == 0)
				{
					coef_one_mem = 1;
				}
			}
			else if(coef_store_type == M4K)
			{
				coef_one_mem = (int) floor(36.0/((double) coef_bit_width));
			}
			else
			{
				coef_one_mem = 1;
			}
			mem_num = (int) ceil(((double) num_mac)/ ((double)coef_one_mem));
			mcv_reload_zero_insert = mem_num * coef_one_mem - num_mac;
			if(mem_num == 1)
			{
				mcv_reload_zero_insert = 0;
			}

			for(i=0;i<2048;i++)
			{
				coef_mr[i] = 0;
				coef[i] = 0;
			}
			if(coef_store_type==LC)
			{
				for(i=0;i<poly_fact;i++)
				{
					for(j=0;j<mcv_coef_length;j++)
					{
						ai = i+j*poly_fact;
						bi = j+i*mcv_coef_length;	
						ci = (mcv_coef_length-1-j)+i*mcv_coef_length;	
						if(num_cycles==1)
						{
							//reorder and reverse each set
							coef_mr[ci] = coef_ori[ai];
						}
						else
						{
							// just reorder
							coef_mr[bi] = coef_ori[ai];
						}
					}
				}
				coef_mr[mcv_coef_length*poly_fact] = 0;
							
				for (int iset = 0; iset<poly_fact; ++iset)
				{
					for (j=0; j<num_mac; ++j)
					{
						for (i=0; i<num_cycles; ++i)
						{
							k = i*num_mac + j + iset * mcv_coef_length;
							if (i==0)
							{
								tmp_coef[k] = coef_mr[(num_cycles - 1) * num_mac + j + iset * mcv_coef_length];
							}
							else
							{
								tmp_coef[k] = coef_mr[(i -1 ) * num_mac + j + iset * mcv_coef_length];
							}
						}
					}

					for (j=0; j<num_mac; ++j)
					{
						for (i=0; i<num_cycles; ++i)
						{
							k = i*num_mac + (num_mac - 1 - j) + iset * mcv_coef_length;
							if(coef_store_type == LC)
							{
								coef[j*num_cycles + i + iset * mcv_coef_length] = tmp_coef[k];
							}
						}
					}
				}
				for(i=0;i<2048;i++)
				{
					if(num_cycles>1)
					{
						coef_mr[i] = coef[i];
					}
				}
			}
			else
			{
				for(i=0;i<poly_fact;i++)
				{
					for(j=0;j<length_wr;j++)
					{
						ai = i+j*poly_fact;
						bi = j+i*mcv_coef_length;	
						coef_mr[bi] = coef_ori[ai];
					}
				}

				for(i=0;i<poly_fact;i++)
				{
					mcv_coef_length = (num_mac + mcv_reload_zero_insert) * num_cycles;
					if(mcv_reload_zero_insert > 0)
					{
						for( int i_p = 0; i_p < num_cycles; i_p++)
						{
							for(int j_p = 0; j_p < num_mac + mcv_reload_zero_insert ; j_p++)
							{
								int ini_index = i_p * (num_mac) + j_p + i * num_mac * num_cycles;
								int new_index = i_p * (num_mac + mcv_reload_zero_insert) + j_p + mcv_coef_length * i;
								if(j_p < (mem_num-1) * coef_one_mem)
								{
									tmp_coef[new_index] = coef_mr[ini_index];
								}
								else if(j_p < (mem_num-1) * coef_one_mem + mcv_reload_zero_insert)
								{
									tmp_coef[new_index] = 0;
								}
								else
								{
									tmp_coef[new_index] = coef_mr[ini_index - mcv_reload_zero_insert];
								}
							}
						}
					}
				}
				if(mcv_reload_zero_insert > 0)
				{
					for (int i_l=0; i_l<2048; ++i_l)
					{
						coef_mr[i_l] = tmp_coef[i_l] ;
					}
				}
				coef_mr[mcv_coef_length*poly_fact+1] = 0;
			}
			length_wr = mcv_coef_length;
			}
			//Reassign back to array before writing to disk
			for(i=0;i<2048;i++)
			{
				coef[i] = coef_mr[i];
			}
		}
				/*********************************************************************************/

}
void deci_reseq()
{
/**********************************************************************************
*
* Reorder for decimation fir (allow symmetric)
*	
**********************************************************************************/
	int half_len =(int) ceil(((double) coef_length)/2.0);
	int tmp_coef[2048];
	int loc_coef[2048];

	float mcv_coef_length;
	float zeros_insert; 

	int calc_cycles = num_cycles;

    if(poly_type == DEC)
	{
		calc_cycles = num_cycles * poly_fact;
	}
	int loc_length;

	if(sym == 0)
	{
		loc_length = coef_length;
	}
	else
	{
		loc_length = half_len;
	}

	num_mac =(int) ceil(((double) loc_length)/((double) calc_cycles));

	mcv_coef_length = num_mac * calc_cycles;
	zeros_insert = 0;

	if(sym == 0 )
	{
		zeros_insert = 0;
	}
	else
	{
		zeros_insert = mcv_coef_length - loc_length;
	}

	int i,j,k,l;

	k = 0;
	l = 0;
	for (i=0; i<2048; ++i)
	{
		tmp_coef[i] = 0;
	}


	k = 0;
	l = 0;

	for (i=0; i<loc_length; ++ i)
	{
		tmp_coef[i + int(zeros_insert)] = coef[i];
	}
	for (i=0; i<mcv_coef_length; ++ i)
	{
		loc_coef[i] = tmp_coef[i];
	}

	if(num_cycles > 1)
	{
			for(k = 0 ; k< num_mac; ++k)
			{
				for (i=0; i<num_cycles; ++i)
				{
					for(j = 0 ; j< poly_fact; ++j)
					{
						int tmp_index = i*poly_fact + j + k *poly_fact * num_cycles;
						int loc_index = k*poly_fact + j + i *poly_fact*num_mac;
						tmp_coef[tmp_index ] = loc_coef[loc_index];
					}
				}
			}
			for (i=0; i<mcv_coef_length; ++i)
			{
				loc_coef[i] = tmp_coef[i];
			}
			for(k = 0 ; k< num_mac; ++k)
			{
				for(j = 0 ; j< poly_fact; ++j)
				{
					for (i=0; i<num_cycles; ++i)
					{
						int tmp_index = k*poly_fact*num_cycles + i + j*num_cycles;
						int loc_index = k*poly_fact*num_cycles + i * poly_fact + j ;
						tmp_coef[tmp_index ] = loc_coef[loc_index];
					}
				}
			}
			for (i=0; i<mcv_coef_length; ++i)
			{
				loc_coef[i] = tmp_coef[i];
			}
			for(k = 0 ; k< num_mac; ++k)
			{
				for(j = 0 ; j< poly_fact; ++j)
				{
					for (i=0; i<num_cycles; ++i)
					{
						int tmp_index = k*poly_fact*num_cycles + i + j *num_cycles;
						int loc_index = k*poly_fact*num_cycles + (num_cycles -1-i) + j * num_cycles;
						tmp_coef[tmp_index ] = loc_coef[loc_index];
					}
				}
			}
	}

	for (i=0; i<mcv_coef_length; ++i)
	{
		coef[i] = tmp_coef[i];
	}
	//end of coef_resequence


	//insert zeros when use memory to store coefficient and coefficient in one memory is more than one
	int mem_num;
	int coef_one_mem = 1;
	if(coef_store_type == M512 || coef_store_type == AUTO)
	{
		coef_one_mem = (int) floor(18.0/((double) coef_bit_width));
		if(coef_one_mem == 0)
		{
			coef_one_mem = 1;
		}
	}
	else if(coef_store_type == M4K)
	{
		coef_one_mem = (int) floor(36.0/((double) coef_bit_width));
	}
	else
	{
		coef_one_mem = 1;
	}
	if(coef_store_type != LC)
	{
		mem_num = (int) ceil(((double) num_mac)/ ((double)coef_one_mem));
		mcv_reload_zero_insert = mem_num * coef_one_mem - num_mac;
		if(mem_num == 1)
		{
			mcv_reload_zero_insert = 0;
		}
	}

	if(mcv_reload_zero_insert > 0)
	{
		for (j=0; j<mem_num * coef_one_mem; ++j)
		{
			for (i=0; i<calc_cycles; ++i)
			{
				if(j < (mem_num -1) * coef_one_mem)
				{
					coef[j* calc_cycles + i] = tmp_coef[j* calc_cycles + i];
				}
				else if(j <(mem_num -1) * coef_one_mem + mcv_reload_zero_insert)
				{
					coef[j* calc_cycles + i] = 0;
				}
				else
				{
					coef[j* calc_cycles + i] = tmp_coef[(j - mcv_reload_zero_insert)* calc_cycles + i];
				}
			}
		}
	}

}

void single_rate_out_write()
{
/**********************************************************************************
*
* Write coeficients to file
* Single-Rate Filter
*	
**********************************************************************************/
	ofstream out_file;
	int i,j,k,m,l;
	int jg;
	int index_cnt;
	int sub_coef[30];
	int size;
	int tmp_coef[2048];
	char temp[32];
	char bi_index[256];
	int mcv_coef_length = (num_mac + mcv_reload_zero_insert) * num_cycles;
	
	out_file.open(out_name, ios::out);
	i = out_file.is_open();
	if (i!=0)
	{
		if(struct_type == MCV)
		{
			out_file <<  coef[0] ;	
			for (i=1; i<mcv_coef_length; ++i)
			{
				out_file << "\n"<< coef[i] ;	
			}
		}
		else
		{
			for (jg=0; jg<num_coef_group; ++jg)                                             
			{ 
				for( k = 0; k < group_size; ++ k)
				{
					index_cnt = jg * group_size + k;
					if(index_cnt < coef_length)                                              
					{                                                                  
						sub_coef[k] = coef[index_cnt];                      
					}
					else
					{
						sub_coef[k] = 0;
					}
				}
				size = (int) pow(2.0, group_size);                                               
                                                                          
				int conv_value = (int)pow(2.0, mem_width);                                        
				for(m=0; m< size; m++)                                                     
				{                                                                          
					tmp_coef[0]  = 0;
					itobi(temp, m);//integer to binary                                
					strcpy(bi_index, temp);                                            
					j= strlen(bi_index);                                               
					for(l = 0; l<j; ++l)                                               
					{                                                                  
						if(bi_index[l] == 49)                                      
						{                                                          
							tmp_coef[0] = tmp_coef[0]  + sub_coef[j-1-l];       
						}                                                          
					}                                                                  
					if(tmp_coef[0]  < 0)                                                
					{                                                                  
						tmp_coef[0]  = conv_value + tmp_coef[0] ;                    
					}
					if(jg == 0 && m == 0)
					{
						out_file << "0";
					}
					else
					{
						out_file << "\n"<< tmp_coef[0] ;
					}
				}  
			}                                                                          
		}
	}
	out_file.close();
}
void multi_rate_poly_out_write()
{
/**********************************************************************************
*
* Write coeficients to file
* Multi-Rate Filter
// Maybe creating a 2-D array of coeficients would be a better option
// run the writer section one phase after another concatenating the ouptut
// from each run to form the loadable PP set
*
**********************************************************************************/
	ofstream out_file;
//	ofstream temp_file;
	int i,j,k,m,l;
	int coef_mr_arr[128][16];
	int jg;
	int index_cnt;
	int sub_coef[30];
	int size;
	int tmp_coef[2048];
	char temp[32];
	char bi_index[256];


	if(poly_type==INT||poly_type==DEC)
	{
		out_file.open(out_name, ios::out);
//		temp_file.open("c:/cvs/sj/projects/fir_compiler/work/gui/temp/coef_arr.txt", ios::out);
		i = out_file.is_open();
		if (i!=0)
		{
			if(struct_type == MCV)
			{
				out_file <<  coef[0] ;	
				for (i=1; i<poly_fact*length_wr; ++i)
				{
					out_file << "\n"<< coef[i] ;	
				}
			}
			else
			{
			// Initialize 2-D array of coeficients coef_mr_arr[16][2048]
				for(i = 0; i < 16; ++i)
				{
					for (j = 0; j < 128; ++j)
					{	
						coef_mr_arr[j][i] = 0;
					}
				}
				// Generate 2-D array of coeficients coef_mr_arr[phase][j]
				for(i = 0; i < poly_fact; ++i)
				{
					for (j = 0; j < length_wr; ++j)
					{	
						coef_mr_arr[j][i] = coef[j*poly_fact+i];
					}
				}
				for(i = 0; i < poly_fact; ++i)
				{
					for (jg=0; jg<num_coef_group; ++jg)                                             
					{ 
						for( k = 0; k < group_size; ++ k)
						{
							index_cnt = jg * group_size + k;
							if(index_cnt < coef_length)                                              
							{                                                                  
								sub_coef[k] = coef_mr_arr[index_cnt][i];                      
							}
							else
							{
								sub_coef[k] = 0;
							}
						}
						size = (int)pow(2.0, group_size);                                               
                                                                                                  
						int conv_value = (int)pow(2.0, mem_width);                                        
						for(m=0; m< size; m++)                                                     
						{                                                                          
							tmp_coef[0]  = 0;
							itobi(temp, m);//integer to binary                                
							strcpy(bi_index, temp);                                            
							j= strlen(bi_index);                                               
							for(l = 0; l<j; ++l)                                               
							{                                                                  
								if(bi_index[l] == 49)                                      
								{                                                          
									tmp_coef[0] = tmp_coef[0]  + sub_coef[j-1-l];       
								}                                                          
							}                                                                  
							if(tmp_coef[0]  < 0)                                                
							{                                                                  
								tmp_coef[0]  = conv_value + tmp_coef[0] ;                    
							}
							if(jg == 0 && m == 0)
							{
								out_file << "0";
							}
							else
							{
								out_file << "\n"<< tmp_coef[0] ;
							}
						}  
					}                                                                          
				out_file << "\n";
				}
				//out_file << "\n";
			}
		}
		out_file.close();
//		temp_file.close();
		//printf("num_coef_group=%d group_size =%d size=%d\n",num_coef_group,group_size,size);
	}

}
void deci_out_write()
{
	ofstream out_file;
	out_file.open(out_name, ios::out);
	int index_adjust = 0;
	int i,k,j;
	int calc_cycles = num_cycles;

    if(poly_type == DEC)
	{
		calc_cycles = num_cycles * poly_fact;
	}
	
	if(coef_store_type == LC)
	{
		for(i=num_mac -1; i>= 0; --i)
		{
			for (k=calc_cycles -1; k>= 0; --k)
			{
				
/*				if(num_cycles == 1)
				{
					index_adjust = k + 2;
				}
				else
				{
					index_adjust = k;
				}
				if(sym == 0 && num_cycles == 1)
				{
//					index_adjust--;
					index_adjust = k +3 - poly_fact;
				}*/


				index_adjust = k + 4;
				if(sym != 0)
				{
					index_adjust++;
				}
				if(num_coef_set > 1)
				{
					index_adjust--;
				}


				while( index_adjust >= calc_cycles)
				{
					index_adjust = index_adjust - calc_cycles;
				}
				while( index_adjust < 0 )
				{
					index_adjust = index_adjust + calc_cycles;
				}

				j = coef[i * calc_cycles + index_adjust];
				out_file << j <<"\n"; ;
			}
		}
	}
	else
	{
		for (k=0; k<calc_cycles; ++k)
		{
			for(i=0; i<num_mac + mcv_reload_zero_insert; ++i)
			{
				j = coef[i * calc_cycles + k];
				out_file << j <<"\n"; ;
			}
		}

	}
	out_file.close();
}

void itobi(char str_deci[32], int i)
{
	char str_temp[32];

	str_deci[0] = '\0';
	int med;
	while (i > 0)
	{
		str_temp[0] = '\0';
		int j= strlen(str_temp);
		med = (i >> 1);
		if ( i == (med << 1) )
		{strcat(str_temp,"0");}
		else
		{strcat(str_temp,"1");}
		i = med;
		strcat(str_temp,str_deci);
		strcpy(str_deci,str_temp);
	}
}

                                                                                       
