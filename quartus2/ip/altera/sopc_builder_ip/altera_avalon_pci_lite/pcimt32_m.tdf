-- This is      the Master Control Module for PCI/MT64 MegaCore
DEFINE PCI_FAMILY_STRATIXII()		= (((DEVICE_FAMILY == "STRATIX II" ) OR (DEVICE_FAMILY == "HardCopy II" ) ) ? 1 : 0);     
DEFINE PCI_FAMILY_CYCLONE()		= ((DEVICE_FAMILY == "CYCLONE")  ? 1 : 0);  
INCLUDE "maxplus2.inc";
--INCLUDE "pcimt32.inc";


PARAMETERS
(       DEVICE_FAMILY			= "Stratix",
        VERBOSE                 = "NO",
        PCI_32                  = "YES",
        P2P_BRIDGE              = "NO",
        P2P_ENABLE_BITS         = H"00000000", 
        PRIMARY_INTERFACE       = "YES",
        OPTIMIZE_MSTR           = "YES",
        OPTIMIZE_FRAME          = "YES",
        OPTIMIZE_IRDY           = "YES",
        OPTIMIZE_ACK            = "YES",
        OPTIMIZE_ADOE           = "YES",
        IRDY_SPEEDUP            = "YES",
        VERSION_1_0_COMPATIBLE  = "NO",
        DAC_ENA                 = 1,

        DISCARD_TIMER           = "NO",
        SUBORDINATE_BUS         = "NO",
        PREFETCHABLE_MEMORY     = "NO",
        TARGET_ONLY             = "NO",

        PCI_66MHZ_CAPABLE       = "YES",
        INTERNAL_ARBITER        = "NO",                 -- Determines if REQ signal should have a tristate buffer or not.
        INTERRUPT_PIN_REG       = H"01",
        VENDOR_ID               = H"1172",              -- Vendor ID Register
        DEVICE_ID               = H"0004",              -- Device ID Register
        REVISION_ID             = H"01",                -- Revision ID Register
        CLASS_CODE              = H"FF0000",    -- Class Code Register
        ENABLE_BITS             = H"00000000",  -- HARDWIRE_BAR3_ENA    HARDWIRE_BAR2_ENA               HARDWIRE_BAR1_ENA       HARDWIRE_BAR0_ENA
                                                                                        -- EXP_ROM_ENA                  HARDWIRE_EXP_ROM_ENA    HARDWIRE_BAR5_ENA       HARDWIRE_BAR4_ENA
                                                                                        -- HOST_BRIDGE_ENA              INTERRUPT_ACK_ENA               CIS_PTR_ENA             CAP_LIST_ENA
                                                                                        -- INTERNAL_ARBITER_ENA   
  
        SUBSYSTEM_ID            = H"0000",              -- Subsystem ID Register
        SUBSYSTEM_VENDOR_ID     = H"0000",              -- Subsystem Vendor ID Register
        MIN_GRANT               = H"00",                -- Minimum Grant Register
        MAX_LATENCY             = H"00",                -- Maximum Latency Register
        CAP_PTR                 = H"40",
        CIS_PTR                 = H"00000000",
        EXP_ROM_BAR             = H"FFF00000",  -- EXpansion ROM Base Address Register
        HARDWIRE_EXP_ROM        = H"FFF00000",
        NUMBER_OF_BARS          = 1,                    -- Number of Base Address Regisers to be used
        BAR0                    = H"FFF00000",  -- Values in CFG_BAR0
        BAR1                    = H"FFF00000",  --      Bit(0) = 0-Memory, 1-I/O Space
        BAR2                    = H"FFF00000",  --      Bit(1) = Reserve for I/O Space
        BAR3                    = H"FFF00000",  --      Bit(2,1) = Memory Type
        BAR4                    = H"FFF00000",  --      Bit(3)  = Prefetchable Memory Address
        BAR5                    = H"FFF00000",  --      Bits(31..n) = 1 for number of decode bits
        
        -- DEFAULT BAR VALUE
        
        HARDWIRE_BAR0           = H"F0000000",
        HARDWIRE_BAR1           = H"FF000000",
        HARDWIRE_BAR2           = H"FFF00000",          
        HARDWIRE_BAR3           = H"FFFF0000",
        HARDWIRE_BAR4           = H"FFFFF000",
        HARDWIRE_BAR5           = H"FFFFFF00",          
                
        
        LOCAL_CONFIG_ENA        = "NO",                 -- Enable Host Bridge Support
        DATA_TIMEOUT            = 16                    -- Load value for time counter on target

);

FUNCTION pcimt32_sr     (       s, r, clk, clrn, prn)
   RETURNS              (       q);


CONSTANT DISABLE_LAT_TMR         = (ENABLE_BITS & H"00008000") DIV 32768;       -- Bit 15
CONSTANT PCI_64BIT_SYSTEM        = (ENABLE_BITS & H"00010000") DIV 65536;       -- (BIT 16) Indicates whether this is a pure 64bit system or not
CONSTANT MW_CBEN_ENA             = (ENABLE_BITS & H"00020000") DIV H"20000";    -- (BIT 17) master write cben enable
 CONSTANT IGNORE_CFG_MABRT       = (ENABLE_BITS & H"00080000") DIV H"80000";    -- 19 Ignore Master Abort for Master Configuration Transactions
 

SUBDESIGN 'pcimt32_m'
(
--==== BEGINNING OF SUBDESIGN SECTION =============================================================


---- PCI Inputs -----------------------------------------------------------------------------------
        clk                     : INPUT;        -- PCI Clock
        rstn                    : INPUT;        -- PCI Restet
        gnt                     : INPUT;        -- Active High PCI Grant Signal
        
        frame                   : INPUT;        -- Active High FRAMEn Input
        irdy                    : INPUT;        -- Active High IRDYn INPUT
        trdy                    : INPUT;        -- Active High TRDYn Input
        devsel                  : INPUT;        -- Active High DEVSELn Input
        stop                    : INPUT;        -- Active High STOPn Input
        ack64                   : INPUT;        -- Active High Ack64n Input     
        perr                    : INPUT;        -- Active high Parity Error
---------------------------------------------------------------------------------------------------

---- PCI Outputs ----------------------------------------------------------------------------------
        frame_out               : OUTPUT;       -- FRAMEn Output Register
        irdy_out                : OUTPUT;       -- IRDYn Output Register
        req64_out               : OUTPUT;       -- Req64n Output register
        req_or_out              : OUTPUT;       -- PCI Bus Request Output Register
        perr_vld                : OUTPUT;       -- Parity Error was detected
---------------------------------------------------------------------------------------------------

---- Output Enables -------------------------------------------------------------------------------
        frame_oe                : OUTPUT;       -- Frame Output Enable
        irdy_oe                 : OUTPUT;       -- IRDYn Output Enable
        req64_oe                : OUTPUT;       -- Req64n Output Enable
        par_oe                  : OUTPUT;       -- PAR Output Enable
        perr_oe                 : OUTPUT;       -- PERR Output Enable
        ad_oe                   : OUTPUT;       -- Master AD OE Output
        cbe_oe                  : OUTPUT;       -- Command/Byte Enable Output Enable
---------------------------------------------------------------------------------------------------

---- Local Side Data/Byte Enable Path Input -------------------------------------------------------
        low_lm_dati[31..0]      : INPUT; -- Local Side Master Data Bus - Low
        high_lm_dati[31..0]     : INPUT; -- Local Side Master Data Bus - High

        low_lm_beni[3..0]       : INPUT; -- Local Side Master Byte Enables - Low
        high_lm_beni[3..0]      : INPUT; -- Local Side Master Byte Enables - High
---------------------------------------------------------------------------------------------------

---- Local Side Data/Byte Enable Path Output ------------------------------------------------------
        low_data_out[31..0]     : OUTPUT;       -- Master Output Data to AD Output Register
        high_data_out[31..0]    : OUTPUT;   -- Master Output Data to AD Output Register

        low_cbe_out[3..0]       : OUTPUT;       -- Command/Byte Enable Output Registers - Low
        high_cbe_out[3..0]      : OUTPUT;       -- Command/Byte Enable Output Registers - High
---------------------------------------------------------------------------------------------------

---- Local Side Master Inputs ---------------------------------------------------------------------
        lm_req32                : INPUT; -- Local Master 32 bit Request Signal
        lm_req64                : INPUT; -- Local Master Request Signal
        lm_last                 : INPUT; -- Local Master Last Transaction Signal
        lm_rdyn                 : INPUT; -- Local Side Master Data Ready Input (1 cycle ahead)
---------------------------------------------------------------------------------------------------

---- Local Side Master Outputs --------------------------------------------------------------------
        lm_adr_ack              : OUTPUT;       -- local Master Address Acknowledge
        lm_ackn                 : OUTPUT;       -- PCI/B Ready/Acknowledge Signal
        lm_dxfrn                : OUTPUT;       -- Local Master Data Transfer Signal
        lm_dato_vld_out         : OUTPUT;       -- Local Master Data Output Valid

        lm_ldata_ackn           : OUTPUT;       -- l_dato low is valid
        lm_hdata_ackn           : OUTPUT;       -- l_dato high is valid

        lm_tsr[12..0]            : OUTPUT;       -- Master Transaction Status Registers
                                                                -- 0: Master is requesting the Bus
                                                                -- 1: Master has been Granted the bus
                                                                -- 2: Master is in Address Phase
                                                                -- 3: Master is Transferring data
                                                                -- 4: Latency Timer has expired
                                                                -- 5: Master Recieved a retry
                                                                -- 6: Master Recieved a Disconnect with 0 Data Transfers
                                                                -- 7: Master Recieved a Disconnect with 1 Data Transfers
                                                                -- 8: PCI Data Transfer has occurred. 
                                                                -- 9: 64 bit transaction
                                                                -- 10: Received a Master Abort
                                                                -- 11: Latency Timer Experied in MWI Command
                                                                -- 12: Received Target Abort
---------------------------------------------------------------------------------------------------

---- Types of Transaction Information ---------------------------------------------------------------   
        mstr_ena                : INPUT;        -- Master Enable                                                
        targ_access             : INPUT;
                                
        mstr_actv               : OUTPUT;       -- Master Active. Asserted while mstr has ownership of bus.
        mstr_wr_dxfr            : OUTPUT;       -- Master Write Data Transfer           
        tgt_64_response_out     : OUTPUT;                       
        dac_cyc_out             : OUTPUT;
        mstr_cfg_cyc            : OUTPUT;

        hi_low_sel              : OUTPUT;       -- Master AD Output Select line to Select high data
---------------------------------------------------------------------------------------------------

---- Address Clock Enable/Hold Register Clock Enable ----------------------------------------------
        -- AD Bus Controls
        ad_ir_ce_a              : OUTPUT;
        ad_IR_ce_D              : OUTPUT;       -- AD Input Register Clock Enable Data
        ADOR_ena                : OUTPUT;       -- Master AD Output Registers clock Enable
        dati_HR_ena             : OUTPUT;       -- Master AD Hold Register Enable

        ad_sel                  : OUTPUT;       -- Master AD Output Mux Select
        hr_dat_sel              : OUTPUT;       -- Master AD Output Select line to chose the hold register data
        hr_adr_sel              : OUTPUT;       -- Holding Register Select      
---------------------------------------------------------------------------------------------------
        
---- Command/Byte Clock Enable/Hold Register Clock Enable -----------------------------------------
        cben_ir_ce_a            : OUTPUT;
        cben_ir_ce_d            : OUTPUT; -- for parity checker -- Oliver Tan -- msr64_io.scf
        cbe_ce                  : OUTPUT;       -- Command/Byte Enable Clock Enable Data
        cbe_HR_ena              : OUTPUT;       -- Master CBE Hold Register Enable
        hr_cbe_sel              : OUTPUT;       -- Master CBE Output Select line to chose the hold register data
---------------------------------------------------------------------------------------------------

---- Configuration Space Outputs ------------------------------------------------------------------
        lat_dat[7..0]           : INPUT;        -- Latency Timer Register Data
        perr_rep_set            : OUTPUT;       -- PERR Reported Set
        targ_abrt_set           : OUTPUT;       -- Set Command Register Target Abort Recieved Bit
        mstr_abrt_set           : OUTPUT;       -- Set Command Regsiter Master Abort Recieved Bit
---------------------------------------------------------------------------------------------------

---- Par_oe logic output to the top for optimization on gnt

        par_oe_lc1              : OUTPUT;
        mstr_park				: OUTPUT;

--==== END OF SUBDESIGN SECTION ===================================================================
        
)

VARIABLE

--==== BEGINNING OF VARIABLE SECTION ==============================================================

        no_op                   : NODE; -- No_op NODE to get rid of the unused NODEs
        
---- State Machine Variable NODEs -----------------------------------------------------------------
        IF (OPTIMIZE_MSTR == "NO") GENERATE     
                -- Master State Machine NODEs                   
                mstr_sm        : MACHINE with STATES (
                                       MS_IDLE,
                                       MS_REQ,
                                       MS_ENA,
                                       MS_ADR,
                                       MS_ADR2,
                                       MS_PARK,
                                       MS_DXFR,
                                       MS_TAR        );
                                       
                                       
                -- Master State Machine Next state NODEs
                MS_IDLE_d,
                MS_REQ_d,
                MS_ENA_d,
                MS_ADR_d,
                MS_ADR2_d,
                MS_PARK_d,
                MS_DXFR_d,
                MS_TAR_d           : NODE;
                -- Master Write State machine Declaration
                mw_sm           : MACHINE with STATES (
                                        MW_IDLE,
                                        MW_LXFR,
                                        MW_DXFR,
                                        MW_WAIT,
                                        MW_LAST,
                                        MW_HOLD,
                                        MW_DXFR_32,
                                        MW_WAIT_32,
                                        MW_END       );
                                        
                -- Master write State machine Next State NODEs
                MW_IDLE_d,
                MW_LXFR_d,
                MW_DXFR_d,
                MW_WAIT_d,
                MW_LAST_d,
                MW_HOLD_d,
                MW_DXFR_32_d,
                MW_WAIT_32_d,
                MW_END_d      : NODE;
                
                -- Master read State machine Declaration
                mr_sm           : MACHINE with STATES (
                                        MR_IDLE,
                                        MR_PXFR,        
                                        MR_DXFR,
                                        MR_LPXFR,
                                        MR_LWAIT,
                                        MR_LLWAIT,
                                        MR_LLXFR,
                                        MR_END            );                                                                        
                -- Master write State machine Next State NODEs
                MR_IDLE_d,
                MR_PXFR_d,      
                MR_DXFR_d,
                MR_LPXFR_d,
                MR_LWAIT_d,
               
                MR_LLWAIT_d,
                MR_LLXFR_d,
                MR_END_d          : NODE;
                latcntr_tor_set   : NODE;
--                frame_or_cascade  : NODE;
--                req64_or_cascade : NODE;
--                irdy_feedback_cascade1 : NODE;
--                irdy_feedback_cascade2 : NODE;
---- OPTIMIZE_MSTR == "YES"
        ELSE GENERATE   
                ---- Master State Machine 
                MS_IDLE_not,
                MS_REQ,
                MS_ENA,
                MS_ADR,
                MS_ADR2,
                MS_PARK,
                MS_DXFR,
                MS_TAR             : DFFE;
                        
                MS_REQ_d_lc[2..1]  : LCELL;
                
                MS_IDLE,
                MS_IDLE_d,
                MS_IDLE_lc1,
                MS_REQ_d,
                MS_ENA_d,
                MS_ADR_d,
                MS_ADR2_d,
                MS_PARK_d,
                MS_DXFR_d,
                ms_dxfr_lc1a,
                ms_dxfr_lc1b,
                ms_dxfr_lc1c,
                ms_dxfr_lc1,
                ms_dxfr_lc2,
                MS_TAR_d           : NODE;
                
                
                
                MS_ENA_d_lc       : NODE;     
                ---- Master Write State Machine 
                MW_IDLE_not        : DFFE;
                MW_IDLE            : NODE;
                MW_IDLE_d          : NODE;
        
                IF (VERSION_1_0_COMPATIBLE == "NO") GENERATE
                   MW_IDLE_lc1            : NODE;
                   MW_IDLE_lc1_cascade    : LCELL;  
                END GENERATE;
                
                IF (VERSION_1_0_COMPATIBLE == "YES") GENERATE
                   MW_LXFR_r1              : DFFE;
                   MW_LXFR_r2_d_lc1        : NODE;
                   MW_LXFR_r2              : DFFE; 
                   MW_LXFR                 : NODE;
                   MW_LXFR_r1_d            : NODE;
                   MW_LXFR_r2_d            : NODE;
                   MW_LXFR_d               : NODE;
                ELSE GENERATE
                   MW_LXFR_r[3..1]         : DFFE;
                   MW_LXFR                 : NODE;
                   MW_LXFR_lc[5..1]        : NODE;
                END GENERATE;
                
                MW_DXFR_r4                : DFFE;
                MW_DXFR_r1                : DFFE;
                MW_DXFR_r2                : DFFE;
                MW_DXFR_r1_cascade        : NODE;
--                MW_DXFR_r2_cascade        : LCELL;
                MW_DXFR_r4_cascade        : LCELL;
                MR_DXFR_cascade           : NODE;
                ms_tar_cascade            : NODE;
                latcntr_tor_set           : NODE;
                IF(PCI_32 == "NO") GENERATE
                  MW_DXFR_r3              : DFFE;
                END GENERATE;
                
                MW_DXFR_r1_d              : NODE;
                MW_DXFR_r2_d              : NODE;
                
                IF(PCI_32 == "NO") GENERATE
                  MW_DXFR_r3_d            : NODE;
                END GENERATE;
        
                MW_DXFR_r4_d              : NODE;
                MW_DXFR_lc[3..1]          : NODE;
                MW_DXFR                   : NODE;
                MW_DXFR_d                 : NODE;
                MW_WAIT                   : DFFE;
                MW_WAIT_d                 : NODE;
                MW_WAIT_lc[2..1]          : NODE;
                MW_WAIT_lc1_cascade       : LCELL;
                MW_WAIT_cascade           : LCELL;
                mw_dxfr_32_r2_lc1         : NODE;
                MW_END_r1_cascade         : NODE;
                MW_LAST_r[4..1]           : DFFE;
                MW_LAST_r1_d              : NODE;
                MW_LAST_r2_d              : NODE;
                MW_LAST_r3_d              : NODE;
                MW_LAST_lc[3..1]          : NODE;
                MW_LAST_d                 : NODE;
                MW_LAST                   : NODE;
                MW_LAST_r1_cascade        : NODE;
                MW_LAST_r3_cascade        : LCELL;
                
                
                MW_DXFR_32_r[3..1]        : DFFE;
                MW_DXFR_32_r1_d           : NODE;
                MW_DXFR_32_r2_d           : NODE;
                MW_DXFR_32_r3_d           : NODE;
                MW_DXFR_32_lc[3..1]       : NODE;
                MW_DXFR_32_d              : NODE;
                MW_DXFR_32                : NODE;
                
                MW_DXFR_32_r1_cascade     :NODE;
                MW_DXFR_32_r3_cascade     :LCELL;
                
                MW_HOLD_reg[2..1]         : DFFE;
                MW_HOLD                   : NODE;
                MW_HOLD_d[2..1]           : NODE;
                MW_HOLD_lc[3..1]          : NODE;
                
                
                MW_WAIT_32_r[2..1]        : DFFE;
                MW_WAIT_32_r1_d           : NODE;
                MW_WAIT_32_r2_d           : NODE;
                MW_WAIT_32_lc[3..1]       : NODE;
                MW_WAIT_32_d              : NODE;
                MW_WAIT_32                : NODE;
                
                MW_WAIT_32_r1_cascade     :NODE;
                MW_WAIT_32_r2_cascade     :NODE;
                
                MW_END_r[2..1]            : DFFE;
                MW_END_lc1                : NODE;
                MW_END_r1_d               : NODE;
                MW_END_r2_d               : NODE;
                MW_END_d                  : NODE;
                MW_END                    : NODE;
                
                ---- Master Read State Machine 
                MR_IDLE_not,
                MR_DXFR,
                MR_LWAIT,
                MR_END                    : DFFE;
                MR_IDLE_lc1               : LCELL;
                MR_LWAIT_lc1              : NODE;
                MR_LWAIT_lc2              : NODE;
                MR_IDLE,
                MR_IDLE_d,
                MR_DXFR_d_lc1,
                MR_DXFR_d,
                MR_LWAIT_d,
                MR_END_d_lc1,
                MR_END_d_lc2,
                MR_END_d                  : NODE;
                                          
                MR_PXFR_r1                : DFFE;
                MR_PXFR_lc1               : NODE;
                MR_PXFR_lc2               : NODE;
                MR_PXFR_r2                : DFFE;
                MR_PXFR                   : NODE;
                MR_PXFR_r1_d              : NODE;
                MR_PXFR_r2_d              : NODE;
                MR_PXFR_r2_cascade        : NODE;
                MR_LPXFR_r2_lc1           : NODE;
                MR_PXFR_d                 : NODE;         
                                          
                MR_LPXFR_r1               : DFFE;
                MR_LPXFR_lc1              : LCELL;
                MR_LPXFR_lc2              : LCELL;
                MR_LPXFR_r2               : DFFE; 
                MR_LPXFR_r3               : DFFE;
                MR_LPXFR                  : NODE;
                MR_LPXFR_r1_d             : NODE;
                MR_LPXFR_r2_d_lc1         : NODE;         
                MR_LPXFR_r2_d             : NODE;
                MR_LPXFR_r3_d             : NODE;
                MR_LPXFR_d                : NODE; 
                                          
                MR_LPXFR_lc1_cascade      : LCELL;
                MR_LLWAIT_r2_cascade      : LCELL;
                                          
                MR_LLWAIT_r1              : DFFE;
                MR_LLWAIT_r1_lc1          : NODE;
                MR_LLWAIT_r1_lc2          : NODE;
                MR_LLWAIT_r2              : DFFE;
                MR_LLWAIT                 : NODE;
                MR_LLWAIT_r1_d            : NODE;
                MR_LLWAIT_r2_d            : NODE;
                MR_LLWAIT_d               : NODE;
                                          
                MR_LLXFR_r1_d_lc1         : NODE;
                MR_LLXFR_r1               : DFFE;
                MR_LLXFR_r2_d_lc1         : NODE;
                MR_LLXFR_r2               : DFFE;
                MR_LLXFR                  : NODE;
                MR_LLXFR_r1_d             : NODE;
                MR_LLXFR_r2_d             : NODE;
                MR_LLXFR_d                : NODE;
                
           END GENERATE;
---------------------------------------------------------------------------------------------------

        l_req_vld                         : LCELL;        -- Local Request Valid.
---- Request Output Register ---------------------------------------------------------------------
        req_or                            : DFFE;         
        req_or_lc[2..1]                   : LCELL;
        req_or_d                          : NODE;
---------------------------------------------------------------------------------------------------

---- Latency Timer NODEs for Transaction Burst Length ---------------------------------------------
        latcntr : lpm_counter WITH (LPM_WIDTH= 8, LPM_DIRECTION= "DOWN");
        latcntr_cnt_en                   : LCELL;
        latcntr_toR_lc1                  : NODE; 
        latcntr_toR_lc2                  : NODE; 
        latcntr_tc                       : LCELL;
        latcntr_toR                      : SRFF;
        latcntr_toR_mwi                  : SRFF;
---------------------------------------------------------------------------------------------------

---- Devseln Timer for Master Abort ---------------------------------------------------------------     
        IF (VERSION_1_0_COMPATIBLE == "YES") GENERATE
          devsel_cntr                    : lpm_counter with (LPM_WIDTH = 2, LPM_DIRECTION = "UP");
          d_gnd[1..0]                    : DFFE;
        ELSE GENERATE
          devsel_toR_lc1                 : NODE;
          devsel_cntr                    : lpm_counter with (LPM_WIDTH = 3, LPM_DIRECTION = "UP");
          d_gnd[2..0]                    : DFFE;
        END GENERATE;

        devsel_toR                       : DFFE;
        mstr_abrt                        : DFFE;
        mstr_abrt_det					 : SRFF; -- Used to set the lm_tsr Signal
        targ_abrt_det					 : SRFF; -- Used to set the lm_tsr Signal
---------------------------------------------------------------------------------------------------

---- Master Output Enable Register ----------------------------------------------------------------
        perr_oer                        : DFFE;         -- Parity Error Output Enable Regsiter
        irdy_oer_lc1                    : NODE;
        irdy_oer                        : DFFE;         -- Irdy Output Enable Regsiter
---------------------------------------------------------------------------------------------------

---- Address Output Enable Register ---------------------------------------------------------------
        IF (OPTIMIZE_ADOE == "NO") GENERATE
           ad_oer                       : DFFE;         -- AD Bus Output Enable Regsiter
        
        ELSE GENERATE
           ad_oer                       : DFFE;
           ad_oer_lc1                   : NODE;         
           ad_oer_lc2a                  : NODE;         
           ad_oer_lc2b                  : NODE;                                 
           ad_oer_lc2c                  : NODE;         
           ad_oer_lc2d                  : NODE;                 
           ad_oer_lc3                   : NODE;
           
            IF(PCI_FAMILY_STRATIXII() or PCI_FAMILY_CYCLONE()) GENERATE
              lcell_irdy                : NODE;
              MS_DXFR_trdy              : NODE;
              irdy_feedback_trdy        : NODE;
              DXFR_write_trdy           : NODE;
              WAIT_WAIT32_trdy          : NODE;
              MR_LWAIT_trdy             : NODE;
              MR_DXFR_trdy,
              MR_END_trdy,
              MR_LLWAIT_r1_trdy         : NODE;
              MR_LLXFR_r1_trdy          : NODE;
              MR_LPXFR_r1_trdy          : NODE;
              MW_LXFR_trdy              : NODE;
              ad_oer_trdy               : NODE;
              lcell_trdy                : NODE;
              trdy_det_trdy             : NODE;
              pxfr_det_trdy             : NODE;
              perr_vld_trdy             : NODE;
              lm_dato_vld_trdy          : NODE;
              MW_DXFR_r1_trdy           : NODE;
              MW_LAST_r1_trdy           : NODE;
              MW_DXFR_32_r1_trdy        : NODE;
              MW_WAIT_32_r1_trdy        : NODE;
              MW_WAIT_32_r2_trdy        : NODE;
              MW_END_r1_trdy            : NODE;
              MR_LPXFR_r2_trdy          : NODE;
              MR_LLXFR_r2_trdy          : NODE;
               cbe_oer_not_trdy         : NODE;
            END GENERATE;
          
       END GENERATE;           
        
        
---------------------------------------------------------------------------------------------------

---- Command/Byte Enable Output Enable Register ---------------------------------------------------
        cbe_oer_not                     : DFFE;
       
        cbe_oer                         : NODE;
        cbe_oer_r1_lc1                  : NODE;
        cbe_oer_r1_lc2                  : NODE;
        cbe_oer_r1_lc3                  : NODE;
        cbe_oer_r2_d                    : NODE;         -- CBEN Bus Output Enable Regsiter
        cbe_oer_r2_lc1                  : NODE;
        cbe_oer_r3_d                    : NODE;
        
---------------------------------------------------------------------------------------------------

---- Framen Output Register -----------------------------------------------------------------------
    IF (OPTIMIZE_FRAME == "NO") GENERATE
        frame_or                        : DFFE;
        frame_or_d                      : NODE;
     ELSE GENERATE
        frame_or_lc1_cascade            : LCELL;
        frame_or_lc1                    : NODE;
        frame_or_lc1a                   : NODE;
        frame_or_lc1b                   : NODE;
        frame_or_lc1c                   : NODE;
        frame_or_lc1c_carry             : CARRY_SUM;
        frame_or_lc2                    : NODE;
        frame_or_lc2a                   : NODE;
        frame_or_lc2b                   : NODE;
        frame_or_lc3                    : NODE;
        frame_or_lc3a                   : NODE;
        frame_or_lc3b                   : NODE;
        frame_or_lc3c                   : NODE;
        frame_or_not                    : DFFE;
        frame_or                        : NODE;
        frame_or_not_d                  : LCELL;
        frame_or_fb1                    : DFFE;
        frame_or_fb2                    : DFFE;
        frame_or_fb2_cascade            : LCELL;
        frame_or_fb                     : LCELL;
        frame_or_cascade         		: NODE;
    END GENERATE;
---------------------------------------------------------------------------------------------------
---- Req64n Output Register -----------------------------------------------------------------------     
IF (OPTIMIZE_FRAME == "NO") GENERATE
        req64_or                        : DFFE;
        req64_or_d                      : NODE;
        ad_oer_lc4                      : NODE;
ELSE GENERATE
        req64_or                        : NODE;
        req64_or_not                    : DFFE;
        req64_or_lc[2..1]               : NODE;
        req64_or_lc1_cascade            : LCELL;
        ad_oer_lc4                      : NODE;
        req64_or_not_d                  : LCELL;
        req64_or_cascade          		: NODE;
END GENERATE;

---------------------------------------------------------------------------------------------------

---- Irdyn Output Register ------------------------------------------------------------------------
        
IF (OPTIMIZE_IRDY == "NO") GENERATE
        irdy_or                         : DFFE;
ELSE GENERATE
        irdy_or                         : NODE;
        irdy_or_not                     : DFFE;
        irdy_or_lc[10..1]               : NODE;
        irdy_or_lc6a                    : NODE;
        irdy_or_not_d                   : LCELL;
        irdy_or_feedback_d              : NODE;
        irdy_or_feedback                : DFFE;
        
        irdy_or_lc4_cascade[2..1]       : LCELL;
        irdy_or_cascade                 : NODE;
        irdy_feedback_cascade1    		: NODE;
        irdy_feedback_cascade2    		: NODE;
END GENERATE;
---------------------------------------------------------------------------------------------------
        
---- Type of Transaction Information --------------------------------------------------------------
        io_cyc                          : DFFE;         -- Command is I/O Read/Write
        cfg_cyc                         : SRFF;         -- Command is Configuration Read/Write
		mwi_cyc							: SRFF;
        wr_rdn                          : SRFF;         -- 1: Write Cycle, 0: Read Cycle
        wr_rdn_set                      : NODE;
        
---------------------------------------------------------------------------------------------------

---- Data Transfer Information --------------------------------------------------------------------
        trdy_det_set                   : NODE;
        trdy_det_reset                 : NODE;
        trdy_det                       : SRFF;
        pxfr_det                       : DFFE;
        
        IF (PCI_32 == "NO") GENERATE
          tgt_64_response_set          : NODE;
          tgt_64_response_reset        : NODE;
          tgt_64_response_reset_lc1    : LCELL;
          tgt_64_response_reg          : DFFE;
          tgt_64_response              : NODE;         -- 64 bit transaction
        END GENERATE;
        direct_xfr                     : NODE;         -- Indicates pure 32->32 or 64->64 transfers
        
        
        IF (PCI_32 == "NO") GENERATE
                pure_32                : SRFF;                 -- Local and PCI 32 bit transfers
        END GENERATE;
        
                
        
---------------------------------------------------------------------------------------------------

---- Master State Machine Status ------------------------------------------------------------------
        adr_vld                        : NODE;         -- Local Side Has the valid Address/data
        ADOR_ena_lc1                   : NODE;
        ADOR_ena_lc                    : NODE;
        dati_hr_ena_lc                 : NODE;
        perr_vldR                      : DFFE;         -- Parity Error Valid
        perr_rep_setR                  : DFFE;
        park                           : DFFE;         -- Indicates that PCI Bus is parked
        idle_reg                       : DFFE;         -- Indicates that PCI Bus is parked
        
        IF (OPTIMIZE_MSTR == "NO") GENERATE
            mstr_done                  : NODE;         -- Indicates that mstr xfr is complete
        END GENERATE;
        MS_TAR_R                       : DFFE;         -- Registered MS_TAR signal
        mstr_enable                    : NODE;
        mstr_actv_lc                   : NODE;
        mstr_wr_dxfr                   : NODE;         -- Master Write Data Transfer
---------------------------------------------------------------------------------------------------

---- Dual Address Cycle (DAC) ---------------------------------------------------------------------
        IF (DAC_ENA     == 0) GENERATE
           dac_cyc                     : NODE;
           dac_cyc_reg_set             : NODE;
           dac_cmd                     : NODE;
        ELSE GENERATE
           dac_cyc_reg                 : SRFF;
           dac_cyc                     : NODE;
           dac_cyc_reg_set             : NODE;
           dac_cmd                     : NODE;
        END GENERATE;
        
        adr_phase                      : DFFE; 
        dac_cyc_strobe                 : DFFE;
        adr_phase_end                  : DFFE;
        adr_phase_end_lc1              : NODE;
---------------------------------------------------------------------------------------------------

---- Target Termination Indicator -----------------------------------------------------------------     
        -- Normal Termination
        lm_last_R_reset                : NODE;
        lm_last_R                      : SRFF;         -- Last Transfer Indicator
        last_xfr                       : NODE;         -- Last Transfer Indicator
        last_xfr_lc1                   : NODE;
        -- Abnormal Termination
        tabrt_set                      : DFFE;
        IF(PCI_FAMILY_STRATIXII() or PCI_FAMILY_CYCLONE()) GENERATE
           tabrt_set_trdy                 : NODE;
        END GENERATE;
       
        
        retry_det_set1                 : NODE;
        retry_det_set2                 : NODE;
        retry_det                      : SRFF;
        disc0_det_set                  : NODE;
        disc0_det                      : SRFF;
        disc1_det_set                  : NODE;
        disc1_det                      : SRFF;
---------------------------------------------------------------------------------------------------

---- Target Input Registers -----------------------------------------------------------------------
        stopR                           : DFFE;         -- Registered Active High Stop Signal
        trdyR                           : DFFE;         -- Registered Active High trdy Signal
        devselR                         : DFFE;         -- Registered Active High devsel Signal
        IF (PCI_32 == "NO") GENERATE
           ack64R                       : DFFE;         -- Registered Active High ack64 Signal
        ELSE GENERATE
           ack64R                       : NODE; 
        END GENERATE;
---------------------------------------------------------------------------------------------------

        
---- Local Master Variable NODEs ------------------------------------------------------------------     
        lm_dato_vld_lc1                 : NODE;
        lm_dato_vld                     : DFFE;
        lm_rdynR                        : DFFE;         -- Registered Active Low Local Ready
        lm_req64R                       : SRFF;         -- Registered Active High Local request
        lm_adr_ack_R_lc1                : NODE;
        lm_adr_ack_R_lc2                : NODE;
        lm_adr_ack_R                    : DFFE;

        IF (OPTIMIZE_ACK == "NO") GENERATE
          lm_ack_or                     : DFFE;
        ELSE GENERATE
          lm_ack_or                     : NODE;
          lm_ack_or_r[4..1]             : DFFE;
          lm_ack_or_r1_d                : NODE;
          lm_ack_or_r2_d                : NODE;
          lm_ack_or_r3_d                : NODE;
          lm_ack_or_r4_d                : NODE;
          lm_ack_or_lc[10..1]           : NODE;
          lm_ack_or_r1_cascade          : LCELL;
          lm_ack_or_lc3_cascade         : LCELL;
          lm_ack_or_r2_cascade          : LCELL;
          lm_ack_or_lc5_cascade         : LCELL;
        END GENERATE;
                
        
        
---------------------------------------------------------------------------------------------------

---- 32-bit PCI/64-bit Local Request Transaction --------------------------------------------------
--              lm_lack                         : TFFE;         -- Toggle flop to determine which data is next
        IF (PCI_32 == "NO") GENERATE
           lm_ldata_ack_ena1            : NODE;
           lm_ldata_ack_ena2            : NODE;
           lm_ldata_ack_ena3            : NODE;
           lm_ldata_ack_lc[4..1]        : NODE;
           lm_ldata_ack                 : DFFE;
           lm_ldata_ack_lc1_cascade     : LCELL;
           lm_ldata_ack_lc2_cascade     : LCELL;
           lm_ldata_ack_lc3_cascade     : LCELL;
           lm_hdata_ack_lc2_cascade     : LCELL;
           lm_hdata_ack_lc3_cascade     : LCELL;
           lm_hdata_ack_lc4_cascade     : LCELL;
           lm_hdata_ack_ena1            : NODE; 
           lm_hdata_ack_ena2            : NODE;
           lm_hdata_ack_lc[8..1]        : NODE;
           lm_hdata_ack                 : DFFE;
        END GENERATE;
        
        IF (PCI_32 == "NO") GENERATE
           WAIT_ndirect                 : DFFE;
           WAIT_ndirect_lc              : NODE;
           
           IF(PCI_FAMILY_STRATIXII() OR PCI_FAMILY_CYCLONE()) GENERATE
              WAIT_ndirect_trdy         : NODE;
           END GENERATE;
           
        END GENERATE;      
        
        DXFR_write                      : DFFE;
        DXFR_write_lc1                  : NODE;
        DXFR_write_lc2                  : NODE;
        DXFR_write_lc3                  : NODE;
        DXFR_write_lc4                  : NODE;
        DXFR_write_lc4a                 : NODE;
        WAIT_WAIT32                     : DFFE;
        WAIT_WAIT32_lc1                 : NODE;
        WAIT_WAIT32_lc2                 : NODE;
        WAIT_WAIT32_lc3                 : NODE;
        MW_WAIT_32_d_lc_1a              : NODE;
        MW_WAIT_32_d_lc_1b              : NODE;
        MW_WAIT_32_d_lc_1c              : NODE;
        MW_WAIT_32_d_lc_1d              : NODE;
        ---------------------------------------------------------------------------------------------------
        
        cbe_oer_lc2                     : NODE;        
        no_op_reg[4..1]                 : DFFE;
        no_op_prst_reg                  : DFFE;

        
--==== END OF VARIABLE SECTION ====================================================================

                
                
BEGIN

Assert (VERBOSE == "NO") Report " PCI Master Module $Revision: 1.4 $, $JustDate:  2/12/03 $"
severity INFO;


--==== BEGINNING OF LOGIC SECTION =================================================================

        

---- No Operation NODEs for Unused NODEs ----------------------------------------------------------


    no_op =  no_op 
                OR MS_IDLE_d
                OR MS_REQ_d
                OR MS_ENA_d
                OR MS_ADR_d
                OR MS_PARK_d
                OR MS_DXFR_d
                OR MS_TAR_d        
                OR MR_IDLE_d
                OR MR_PXFR_d
                OR MR_LPXFR_d
                OR MR_DXFR_d
                OR MR_LWAIT_d
                
                OR MR_LLWAIT_d
                OR MR_LLXFR_d
                OR MR_END_d
                OR MW_END_d
                OR MW_DXFR_32_d
                OR MW_WAIT_d
                OR ack64
                OR mstr_ena
                OR MW_LAST_d
                OR ack64R
                OR MW_WAIT_32_d
                OR MW_DXFR_d
                ;




---------------------------------------------------------------------------------------------------

---- Master Enabled Signal ------------------------------------------------------------------------
        -- Command Register 2 of the Configuration register
        IF (P2P_BRIDGE == "NO") GENERATE
          mstr_enable = mstr_ena;
        ELSE GENERATE
          IF (PRIMARY_INTERFACE == "YES") GENERATE
            mstr_enable = mstr_ena;
          ELSE GENERATE
            mstr_enable = VCC;
          END GENERATE;
        END GENERATE;
---------------------------------------------------------------------------------------------------     

---- Target Input Register ------------------------------------------------------------------------
        -- Registered Active high devsel Signal
        devselR.clk   = clk;
        devselR.clrn  = rstn;
        devselR.d     = devsel;
        -- Registered Active high Ack64 Signal
        IF (PCI_32 == "NO") GENERATE
          ack64R.clk   = clk;
          ack64R.clrn  = rstn;
          ack64R.d     = ack64;
        ELSE GENERATE
          ack64R       = GND;
        END GENERATE;
        
        -- Registered Active high trdy Signal
        trdyR.clk   = clk;
        trdyR.clrn  = rstn;
        IF(PCI_FAMILY_STRATIXII() or PCI_FAMILY_CYCLONE()) GENERATE
           trdyR.d     =  LCELL(lcell_trdy);
        ELSE GENERATE
            trdyR.d     =  trdy;
        END GENERATE;
       
        
        no_op_prst_reg.clk = clk;
        no_op_prst_reg.prn = rstn;
        no_op_prst_reg.d   = VCC;
        no_op_reg[].clk    = clk;
        no_op_reg[].clrn   = rstn;
        no_op_reg[].d      = VCC;
        
        -- Registered Active high Stop Signal
        stopR.clk                       = clk;
        stopR.clrn                      = rstn;
        stopR.d                         = stop;
---------------------------------------------------------------------------------------------------
                
---- Local Master Input Register ------------------------------------------------------------------
        lm_rdynR.clk    = clk;
        lm_rdynR.clrn   = rstn;
        lm_rdynR        = lm_rdyn;

        lm_req64R.clk   = clk;
        lm_req64R.clrn  = rstn;
        lm_req64R.s     = lm_req64;
        lm_req64R.r     = MS_TAR or MS_IDLE;
---------------------------------------------------------------------------------------------------

---- Latency Timer Register for Burst Length ------------------------------------------------------
        latcntr.data[7..0]      = lat_dat[7..0];
        latcntr.clock           = clk;
        latcntr.sload           = MS_ADR;
        latcntr.cnt_en          = latcntr_cnt_en;
        latcntr.aclr            = not rstn;
        latcntr.sclr            = LCELL(MS_REQ OR MS_TAR OR MS_IDLE);

        IF (DISABLE_LAT_TMR == 0) GENERATE
          latcntr_cnt_en          = MS_DXFR and not latcntr_tc;
        ELSE GENERATE
          latcntr_cnt_en          = GND;
        END GENERATE;
        
        -- Latency Timer Time Out Register
        IF(latcntr.q[7..0] == H"01") THEN
          latcntr_tc      = VCC;                  -- Latency Timer Reached terminal Count
        ELSE
          latcntr_tc      = GND;
        END IF;
        
        latcntr_toR_lc1 = LCELL (  NOT (MS_ENA OR MS_REQ));
        latcntr_toR_lc2 = LCELL (  NOT (MS_ENA OR MS_REQ OR MS_IDLE OR MS_TAR ));
        
        -- latcntr_tor_lc2 was added because it is possible for the latecntr_tc to be terminal
        -- during Idle and Turn Around.  This term prvents this signal from being asserted
        latcntr_tor_set    = LCELL(latcntr_tc AND not gnt AND latcntr_toR_lc2 AND NOT mwi_cyc);
        latcntr_toR.clk    = clk;
        latcntr_toR.clrn   = rstn;
        latcntr_toR.S      = latcntr_tor_set; -- reset dominant
        latcntr_toR.r      = NOT latcntr_toR_lc1;
       
        latcntr_toR_mwi.clk    = clk;
        latcntr_toR_mwi.clrn   = rstn;
        latcntr_toR_mwi.S      = LCELL(latcntr_tc AND not gnt AND latcntr_toR_lc2); 
        latcntr_toR_mwi.r      = NOT latcntr_toR_lc1;
---------------------------------------------------------------------------------------------------

---- Devseln Time Out for Master Abort ------------------------------------------------------------
        devsel_cntr.clock    = clk;
        devsel_cntr.aclr     = not rstn;
        devsel_cntr.sclr     = MS_ADR;
        devsel_cntr.sload    = devsel;
        devsel_cntr.data[]   = d_gnd[].q;
        devsel_cntr.cnt_en   = LCELL (not devselR and MS_DXFR);

        d_gnd[].clk          = clk;
        d_gnd[].clrn         = rstn;
        d_gnd[].d            = (gnd or d_gnd[].q);

        devsel_toR.clk       = clk;
        devsel_toR.clrn      = rstn;
        
        IF (VERSION_1_0_COMPATIBLE == "YES") GENERATE
          devsel_toR         = devsel_cntr.q[] == B"11" and not devsel and MS_DXFR;
        ELSE GENERATE
          devsel_toR_lc1     = LCELL(    (devsel_cntr.q[] == B"011" and not dac_cyc) 
                                      OR (devsel_cntr.q[] == B"100" and dac_cyc)
                                    );
          devsel_toR         = devsel_toR_lc1 and not devsel and MS_DXFR;
        END GENERATE;
---------------------------------------------------------------------------------------------------

---- Target Termination Indicator -----------------------------------------------------------------
        -- Normal Termination
        -- Last Taransfer, indicates that Master has only one more Data Phase 
        last_xfr        = LCELL(last_xfr_lc1 or lm_last);
        last_xfr_lc1    = LCELL(latcntr_toR or lm_last_R OR io_cyc or cfg_cyc);
        -- lm_last_R will hold the value of lm_last in case it is only one clock long
        lm_last_R.clk   = clk;
        lm_last_R.clrn  = rstn;
        lm_last_R.s     = lm_last and not latcntr_tor;
        lm_last_R_reset = LCELL((MS_IDLE and not (lm_req64 or lm_req32)) OR MS_TAR);
        lm_last_R.R             = lm_last_R_reset; 
                        -- for single cycle, when lm_lastn is asserted at the same time as lm_req64n or lm_req32n

        -- Master Abort Set Signal              
        mstr_abrt.clk   = clk;
        mstr_abrt.clrn  = rstn;
        mstr_abrt       = devsel_toR; 

		IF(IGNORE_CFG_MABRT) GENERATE	
			mstr_abrt_set   = LCELL (devsel_toR AND NOT cfg_cyc);
		ELSE GENERATE
		   	mstr_abrt_set   = LCELL(devsel_toR);
		END GENERATE;
        
        mstr_abrt_det.clk   = clk;
        mstr_abrt_det.clrn  = rstn;
        mstr_abrt_det.s     = devsel_toR; 
		mstr_abrt_det.r     = MS_REQ or MS_ENA;
        
        -- Target Abort Detect
        tabrt_set.clk   = clk;
        tabrt_set.clrn  = rstn;
        IF(PCI_FAMILY_STRATIXII() or PCI_FAMILY_CYCLONE()) GENERATE
           tabrt_set_trdy = LCELL(trdy);
           tabrt_set       = ( stop AND NOT devsel) and MS_DXFR AND NOT tabrt_set_trdy ;
        ELSE GENERATE
            tabrt_set       = ( stop AND NOT devsel) and MS_DXFR AND NOT trdy ;
        END GENERATE;
        targ_abrt_set   = tabrt_set;
        
        targ_abrt_det.clk	= clk;
        targ_abrt_det.clrn	= rstn;
        targ_abrt_det.s		= tabrt_set;
        targ_abrt_det.r     = MS_REQ or MS_ENA;

        -- Retry
        retry_det.clk   = clk;
        retry_det.clrn  = rstn;
        retry_det_set1  = LCELL(stopR and not tabrt_set and not targ_access);
        retry_det_set2  = LCELL(retry_det_set1 and lm_tsr3 and NOT trdy_det);
        retry_det.s     = retry_det_set2;
        retry_det.r     = MS_REQ or MS_ENA;
                
        -- Disconnect w/o Data
        disc0_det.clk   = clk;
        disc0_det.clrn  = rstn;
        disc0_det_set   = LCELL(retry_det_set1 and not trdyR and trdy_det and not disc1_det);
        disc0_det.s     = disc0_det_set;
        disc0_det.r     = MS_REQ OR MS_ENA;
        
        -- Disconnect w/ Data
        disc1_det.clk   = clk;
        disc1_det.clrn  = rstn;
        disc1_det_set   = LCELL(stopR and trdyR and lm_tsr3 and not targ_access);
        disc1_det.s     = disc1_det_set;
        disc1_det.r     = MS_REQ OR MS_ENA;
---------------------------------------------------------------------------------------------------

---- Master State Machine Status ------------------------------------------------------------------
        -- Address Valid.  Local Side Has valid Address
        adr_vld       = LCELL(MS_ENA %OR dac_cyc_strobe%);    -- Address Valid
        mstr_actv_lc  = LCELL( not ( MR_IDLE AND MW_IDLE ) );
        mstr_actv     = mstr_actv_lc;
        -- Added mstr_enable in this register to prevent it from using during the park state    
        
        
        mstr_park	= MS_PARK;
        
        IF(PCI_FAMILY_STRATIXII() or PCI_FAMILY_CYCLONE()) GENERATE
          lcell_irdy = LCELL(irdy);
          idle_reg.clk   = clk;
          idle_reg.clrn  = rstn;
          idle_reg.d     = mstr_enable and not frame and not lcell_irdy; 
          
          park.clk       = clk;
          park.clrn      = rstn;
          park.d         = gnt and mstr_enable and not frame and not lcell_irdy;
          
        ELSE GENERATE
          idle_reg.clk   = clk;
          idle_reg.clrn  = rstn;
          idle_reg.d     = mstr_enable and not frame and not irdy; 
          
          park.clk       = clk;
          park.clrn      = rstn;
          park.d         = gnt and mstr_enable and not frame and not irdy;
        END GENERATE;
        
       

        mstr_wr_dxfr   = mstr_actv and wr_rdn;

        MS_TAR_R.clk   = clk;
        MS_TAR_R.clrn  = rstn;
        MS_TAR_R.d     = MS_TAR;
        
        IF (OPTIMIZE_MSTR == "NO") GENERATE
          mstr_done       =  not frame_or and irdy_or and (trdy or stop or mstr_abrt);
        END GENERATE;
---------------------------------------------------------------------------------------------------
---- Local Request Valid        -----------------------------------------------------------------------

        -- Checkes to see if local side is done and master is enabled
        l_req_vld  = (mstr_enable and (lm_req64 or lm_req32) and MR_IDLE);

---- Data Transfer Information --------------------------------------------------------------------
        trdy_det.clk  = clk;
        trdy_det.clrn = rstn;
        trdy_det_set  = LCELL(MS_DXFR and not targ_access);

        IF(PCI_FAMILY_STRATIXII() or PCI_FAMILY_CYCLONE()) GENERATE
          trdy_det_trdy = LCELL(trdy);
          trdy_det.s                      =  trdy_det_set and trdy_det_trdy;
        ELSE GENERATE
          trdy_det.s                      =  trdy_det_set and trdy;
        END GENERATE;
        
        
        
        trdy_det_reset  = LCELL(MW_IDLE and MR_IDLE);
        trdy_det.r      = trdy_det_reset;
        

        pxfr_det.clk     = clk;
        pxfr_det.clrn    = rstn;
        IF(PCI_FAMILY_STRATIXII() or PCI_FAMILY_CYCLONE()) GENERATE
          pxfr_det_trdy    = LCELL(trdy);
          pxfr_det.d       = MS_DXFR and irdy_or and pxfr_det_trdy;
        ELSE GENERATE
          pxfr_det.d       = MS_DXFR and irdy_or and trdy;
        END GENERATE;
       
      

        -- Determine Master Write State Machine Path
        -- 32 bit burst transaction indicator
        IF (PCI_32 == "NO") GENERATE
          pure_32.clk   = clk;
          pure_32.clrn  = rstn;
          pure_32.r     = MR_END OR MW_END;
          
          IF (PCI_64BIT_SYSTEM == 0) GENERATE
            pure_32.s   = lm_req32;
          ELSE GENERATE
            pure_32.s   = lm_req32 OR lm_req64;
          END GENERATE;
                
        END GENERATE;

        -- Direct_xfr selects the direct data path i.e. no muxing, demuxing
        IF (PCI_32 == "NO") GENERATE
           direct_xfr  = LCELL(io_cyc or pure_32 or tgt_64_response or cfg_cyc);
        ELSE GENERATE
           direct_xfr  = VCC;
        END GENERATE;
                                                                                        
        -- Indicates a 64 bit transaction
        IF (PCI_32 == "NO") GENERATE
          tgt_64_response_reg.clk    = clk;
          tgt_64_response_reg.clrn   = rstn;
          tgt_64_response_reg        =   (ack64 and tgt_64_response_set and not tgt_64_response_reset)
                                      OR (tgt_64_response_reg and not tgt_64_response_reset);
          tgt_64_response            = tgt_64_response_reg;
          tgt_64_response_set        = LCELL(not MS_IDLE and not MS_REQ);
          tgt_64_response_reset_lc1  = ((MW_IDLE OR MW_END) AND MR_IDLE AND MS_TAR);
          tgt_64_response_reset      = LCELL(MR_END  OR MS_REQ OR tgt_64_response_reset_lc1);
          tgt_64_response_out        = tgt_64_response;
        ELSE GENERATE
          tgt_64_response_out             = GND;
        END GENERATE;
---------------------------------------------------------------------------------------------------

---- Type of Transaction Information --------------------------------------------------------------
        -- Write Indicates Whether Cycle Is read OR write

        IF (DAC_ENA     == 0) GENERATE
           wr_rdn.clk              = clk;
           wr_rdn.clrn             = rstn;
           wr_rdn.s                = wr_rdn_set;
           wr_rdn.r                = MS_TAR;
           wr_rdn_set              = adr_vld and low_lm_beni[0];
        ELSE GENERATE
           wr_rdn.clk              = clk;
           wr_rdn.clrn             = rstn;
           wr_rdn.s                = wr_rdn_set;
           wr_rdn.r                = MS_TAR;
           wr_rdn_set              = LCELL ( adr_vld AND     (     (low_lm_beni[0] and not dac_cyc_reg_set) 
                                                                or (high_lm_beni[0] and dac_cyc_reg_set)
                                                             )
                                            );
        END GENERATE;
        
        -- io_cyc indicates that the current cycle is an I/O Read/wr_rdn
        io_cyc.clk                      = clk;
        io_cyc.clrn                     = rstn;
        IF (VERSION_1_0_COMPATIBLE == "YES") GENERATE
          io_cyc.d  = adr_vld and ((low_lm_beni[3..1] == B"001") );
        ELSE GENERATE
          io_cyc.d  = adr_vld and ( (low_lm_beni[3..1] == B"001"));
        END GENERATE;
        
        -- cfg_cyc indicates that the current cycle is a Configuration Read/wr_rdn      
        cfg_cyc.clk    = clk;
        cfg_cyc.clrn   = rstn;
        
        IF (VERSION_1_0_COMPATIBLE == "YES") GENERATE
          cfg_cyc.S   = adr_vld and ((low_lm_beni[3..1] == B"101"));
        ELSE GENERATE
           cfg_cyc.S  = adr_vld and ((low_lm_beni[3..1] == B"101"));
        END GENERATE;
        cfg_cyc.R    = MS_TAR;
       -- cfg_cyc indicates that the current cycle is a Configuration Read/wr_rdn      
        mwi_cyc.clk    = clk;
        mwi_cyc.clrn   = rstn;
        mwi_cyc.S      = adr_vld and ((low_lm_beni[3..0] == B"1111"));
        mwi_cyc.R      = MS_TAR;

        mstr_cfg_cyc = cfg_cyc;

---------------------------------------------------------------------------------------------------

---- Dual Address Cycle Decode --------------------------------------------------------------------
        IF (DAC_ENA  == 0) GENERATE
          dac_cyc                 = GND;
          dac_cyc_out             = GND;
          dac_cyc_reg_set         = GND;
        ELSE GENERATE
          dac_cmd                 = LCELL( low_lm_beni[3..0] == B"1101");         -- Dual Address Cycle Command
          dac_cyc_reg.clk         = clk;
          dac_cyc_reg.clrn        = rstn;
          dac_cyc_reg.s           = dac_cyc_reg_set;
          dac_cyc_reg.r           = MS_IDLE;
          dac_cyc_reg_set         = dac_cmd and adr_vld;
          dac_cyc                 = dac_cyc_reg.q;
          dac_cyc_out             = dac_cyc;
        END GENERATE;           
                
---------------------------------------------------------------------------------------------------

---- Local Data/Command Byte Enable Path ----------------------------------------------------------
        IF (VERSION_1_0_COMPATIBLE == "YES") GENERATE   
           low_data_out[31..0]  = (low_lm_dati[31..0]);
           low_cbe_out[3..0]    = (low_lm_beni[3..0]);
        ELSE GENERATE
           low_data_out[31..0]   = low_lm_dati[31..0];
           low_cbe_out[3..0]     = (low_lm_beni[3..0]);
        END GENERATE;

        high_data_out[31..0]    = high_lm_dati[31..0] ;
        high_cbe_out[3..0]      = high_lm_beni[3..0] ;
---------------------------------------------------------------------------------------------------

---- Address/Command Byte Enable Input Register Clock Enable --------------------------------------
        ad_ir_ce_a              = MS_ADR or MS_ADR2;    
        ad_IR_ce_D              = (not MS_IDLE and not MS_REQ and not MR_LWAIT and not MR_LLWAIT and not MR_LLXFR);

        cben_ir_ce_a    = MS_ADR or MS_ADR2;    
        cben_ir_ce_d    = (MS_ENA OR MS_ADR or MS_DXFR);
                                                                                                        -- Added for parity checker -- msr64_io.scf  
                                                                                                        -- MS_DXFR because cben_ir_data = cben[3..0], cben_ir_data is not equal to l_beni[].  
                                                                                                        --      Therefore, l_beni[] is one clock before cben[] and that's why MS_DXFR.
---------------------------------------------------------------------------------------------------

---- PERRN Related Logic --------------------------------------------------------------------------     
        -- PERR Reported Set.  Used for Bit Number 8 of Configuration Status register
        perr_rep_setR.clk       = clk;
        perr_rep_setR.clrn      = rstn;
        perr_rep_setR           = perr and (MS_DXFR OR MS_TAR OR MS_TAR_R);     
        perr_rep_set            = perr_rep_setR;
        -- This is used to see if the correct PAR is detected
        -- This is active for one during a read cycle immediately after a PCI XFR
        perr_vldR.clk           = clk;
        perr_vldR.clrn          = rstn;
        IF(PCI_FAMILY_STRATIXII() or PCI_FAMILY_CYCLONE()) GENERATE
          perr_vld_trdy           = LCELL(trdy);
          perr_vldR               = irdy_or and MS_DXFR and not wr_rdn and perr_vld_trdy;  
        ELSE GENERATE
          perr_vldR               = irdy_or and MS_DXFR and not wr_rdn and trdy;  
        END GENERATE;
        
        
        
        perr_vld                = perr_vldR;    
        perr_oer.clk            = clk;
        perr_oer.clrn           = rstn;
        perr_oer                        = (MS_TAR OR MS_DXFR) and NOT wr_rdn;   
        perr_oe                         = perr_oer;
---------------------------------------------------------------------------------------------------             
        
---- Parity Output Enable Logic -------------------------------------------------------------------
--  par_oe is active after Address Phase and during a wr_rdn data phase
--
--      par_oer.clk                     = clk;
--      par_oer.clrn            = rstn;

--  gnt was removed from par_oe because if gnt was taken away in ms_ena you still have enough time to recover and 
--      tristate the par signal before the other master drives it.
--
--      par_oer                         =       (MS_ENA )                               
--                                              OR  (MS_ADR )
--                                              OR  (MS_ADR2)
--                                              OR  (MS_DXFR and wr_rdn)
--                                              OR  MS_PARK;    
--      par_oe                          = par_oer; 

--      par_oe                          =       (MS_ENA and gnt )                               
--                                              OR  (MS_ADR )
--                                              OR  (MS_ADR2)
--                                              OR  (MS_DXFR and wr_rdn)
--                                              OR  (MS_PARK) ;

par_oe_lc1                      =  ((MS_ADR2)
                                                OR  (MS_DXFR and wr_rdn)
--                                                OR  (MS_PARK)
                                                ) ;
                                                
                                                
                                                
---------------------------------------------------------------------------------------------------     
                
---- Master Output Signals Output Enable ----------------------------------------------------------     
        -- frame is enabled during One Clock before address phase until
        -- last data xfr                                                
        frame_oe                        = cbe_oe;
        req64_oe                        = cbe_oe;
        -- irdy is enabled starting in address phase until turn around
        irdy_oer.clk            = clk;
        irdy_oer.prn            = rstn;
        irdy_oer_lc1            = LCELL(MS_ADR OR  MS_ADR2 OR MS_DXFR);                                              
        irdy_oer                = not irdy_oer_lc1 and not(MS_ENA and gnt);      
        irdy_oe                 = not irdy_oer;
---------------------------------------------------------------------------------------------------     

--==== Address Output Enable Logic ================================================================

IF (OPTIMIZE_ADOE == "NO") GENERATE
  ad_oer.clk                              = clk;
  ad_oer.clrn                             = rstn;
  ad_oer.d                        =       (gnt AND MS_PARK)
                                          OR      (gnt AND MS_ENA)
                                          or      (dac_cyc_strobe)
                                          OR      (MS_DXFR  and wr_rdn AND (frame_or OR NOT irdy_or) )
                                          OR      ((MS_ADR or MS_ADR2) and wr_rdn)
                                          OR      ( gnt AND       (       (MS_REQ and idle_reg)
                                                                          OR      (MS_IDLE and idle_reg)
                                                                          )
                                                  )       
                                          OR      ( (NOT trdy AND NOT stop) AND (MS_DXFR and wr_rdn AND NOT mstr_abrt));   -- done ad_oer opt
                                                                                  
  ad_oe                           =  ad_oer;
ELSE GENERATE
        -- Address Output Enable Optimization
   ad_oer.clk                      = clk;
   ad_oer.clrn                     = rstn;
   ad_oer_lc1                      = (  MS_PARK OR MS_ENA);        
   ad_oer_lc2d                     = LCELL(
                                                                                   dac_cyc_strobe
                                                                                   OR      ad_oer_lc2b
                                                                                   OR      ad_oer_lc2c
                                                           );
   ad_oer_lc2a                     = LCELL(        (MS_REQ and idle_reg)
                                                                           OR (MS_IDLE and idle_reg) -- added to enable ad before par
                                                           );
   ad_oer_lc2b                     = LCELL(MS_DXFR  and wr_rdn AND (frame_or OR NOT irdy_or) );
   ad_oer_lc2c                     = LCELL((MS_ADR or MS_ADR2) and wr_rdn);                
   ad_oer_lc3                      = LCELL(MS_DXFR  and wr_rdn AND NOT mstr_abrt); 
   ad_oer_lc4          = LCELL (gnt and (ad_oer_lc1 OR ad_oer_lc2a) OR ad_oer_lc2d);

  IF(PCI_FAMILY_STRATIXII() or PCI_FAMILY_CYCLONE()) GENERATE
    lcell_trdy = LCELL(trdy);
    ad_oer_trdy = LCELL(trdy);
    ad_oer.d                        =  (NOT ad_oer_trdy AND NOT stop AND ad_oer_lc3) OR  ad_oer_lc4;
  ELSE GENERATE
    ad_oer.d                        =  (NOT trdy AND NOT stop AND ad_oer_lc3) OR  ad_oer_lc4;
  END GENERATE;

   ad_oe                           = ad_oer;
                                                                                
END GENERATE;                   
--=================================================================================================

--==== Command Byte Enable Output Enable ==========================================================
--      cben is enabled starting one clock before address phase untill
--      Turn Around State
--      cbe_oer                         =  (MS_REQ AND (park))
--                                              OR (gnt AND (MS_PARK and mstr_enable and (lm_req64 # lm_req32)))
--                                              OR (MS_ENA AND gnt)
--                                              OR (MS_ADR )
--                                              OR (MS_DXFR  AND (frame_or OR NOT irdy_or OR (NOT trdy AND NOT stop AND NOT mstr_abrt) ))
--                                              OR MS_PARK
--                                              OR MS_IDLE and park;-- added to enable the outputs early during park

cbe_oer_r1_lc1                  = LCELL (
                                                                        (MS_REQ  and idle_reg)
                                                                        OR (MS_IDLE and idle_reg)-- added to enable the outputs early during park
                                                                );
cbe_oer_r1_lc2                  = LCELL (
                                                                         (MS_DXFR  AND frame_or)
                                                                        OR (MS_DXFR  AND NOT irdy_or)
                                                                );

cbe_oer_r1_lc3                  =  LCELL(
                                                                        (MS_ADR)
                                                                        OR (MS_ADR2)
                                                                        OR cbe_oer_r1_lc2
                                                                 );     
                                                
cbe_oer_r2_lc1                  =  (MS_PARK);
cbe_oer_r2_d                    =       LCELL(
                                                                                cbe_oer_r2_lc1                           
                                                                                OR (MS_ENA)
                                                                        );
cbe_oer_r3_d                    = LCELL(MS_DXFR AND NOT mstr_abrt);                                                                                                                        
cbe_oer_not.clk         = clk;
cbe_oer_not.clrn        = rstn;
cbe_oer_lc2                 =       LCELL((gnt and (cbe_oer_r2_d OR cbe_oer_r1_lc1)) or cbe_oer_r1_lc3 );

IF(PCI_FAMILY_STRATIXII() or PCI_FAMILY_CYCLONE()) GENERATE
  cbe_oer_not_trdy = LCELL(trdy); 
  cbe_oer_not =  (NOT stop AND NOT cbe_oer_not_trdy and cbe_oer_r3_d)
               OR cbe_oer_lc2 ;
ELSE GENERATE
  cbe_oer_not  = (NOT stop AND NOT trdy and cbe_oer_r3_d)
               OR cbe_oer_lc2 ;
END GENERATE;

cbe_oer                         = cbe_oer_not;
cbe_oe                          = cbe_oer;
                
--=================================================================================================

---- MUX Select Logic for Data Paths --------------------------------------------------------------
        --Address Select

ad_sel                          = (MS_ENA OR MS_ADR OR MS_ADR2 OR (DXFR_write)) ;       

DXFR_write.clk = clk;
DXFR_write.clrn = rstn;

DXFR_write_lc1 = LCELL(
                                        (MS_DXFR and (frame_or) and (not irdy_or))
                                        OR (MS_DXFR and (frame_or) and (not mstr_abrt))
                                        OR (MS_DXFR and (not irdy_or) and (not mstr_abrt))
                                                );
DXFR_write_lc2 = LCELL(
                                                (MS_ADR and not dac_cyc)
                                                OR (MS_ADR2)
                                                );
DXFR_write_lc3 = LCELL(
                                                ((
                                        DXFR_write_lc2
                                        OR DXFR_write_lc1
                                                 )and wr_rdn)   


                                                );

DXFR_write_lc4a = LCELL(
                                                (MS_DXFR and frame_or)                                    
                                                OR (MS_DXFR and not irdy_or)                                              
                                                OR (MS_DXFR and not mstr_abrt)
                                        );

DXFR_write_lc4 = LCELL(DXFR_write_lc4a and wr_rdn);

IF(PCI_FAMILY_STRATIXII() or PCI_FAMILY_CYCLONE()) GENERATE
  DXFR_write_trdy = LCELL(trdy);
  DXFR_write =    DXFR_write_lc3 OR ( DXFR_write_lc4 and  not DXFR_write_trdy and not stop);
ELSE GENERATE
  DXFR_write =    DXFR_write_lc3 OR ( DXFR_write_lc4 and  not trdy and not stop);
END GENERATE;

MW_WAIT_32_d_lc_1a = LCELL(MW_DXFR_32 and not lm_rdynR and not last_xfr_lc1);
MW_WAIT_32_d_lc_1b = LCELL(MW_DXFR and not devsel_toR and not direct_xfr and not lm_rdynR);             
MW_WAIT_32_d_lc_1c = LCELL(
                                                MW_WAIT_32_d_lc_1b
                                                OR (MW_WAIT_32 )
                                        );
MW_WAIT_32_d_lc_1d = LCELL(
                                                (MW_WAIT and not direct_xfr and not devsel_toR)
                                                OR MW_WAIT_32_d_lc_1a
                                        );
-- Select the hold register data
WAIT_WAIT32.clk = clk;
WAIT_WAIT32.clrn = rstn;
WAIT_WAIT32_lc1 = LCELL(MW_DXFR and not devsel_toR and not lm_rdynR and direct_xfr);
WAIT_WAIT32_lc2 = LCELL((MW_DXFR_32 and not lm_rdynR)
                                                OR (MW_WAIT and not devsel_toR));
WAIT_WAIT32_lc3 = LCELL(        (
                                                        WAIT_WAIT32_lc1                                                                                 
                                                        OR WAIT_WAIT32_lc2
                                                 ) 
                                                OR MW_WAIT_32_d_lc_1c
                                                 );
                                                 
IF(PCI_FAMILY_STRATIXII() or PCI_FAMILY_CYCLONE()) GENERATE
  WAIT_WAIT32_trdy =  LCELL(trdy);
  WAIT_WAIT32 =  (WAIT_WAIT32_lc3 and not stop and not WAIT_WAIT32_trdy)
               OR (MW_WAIT_32_d_lc_1d and not stop and WAIT_WAIT32_trdy) ;
ELSE GENERATE
  WAIT_WAIT32 =  (WAIT_WAIT32_lc3 and not stop and not trdy)
               OR (MW_WAIT_32_d_lc_1d and not stop and trdy) ;
END GENERATE;



%- ************************************************************************************************
        As part of the requested changes to the P2P Version of the core requested by Cisco Andiamo,
        the command/byte enable data path was made to work exactly as the ad data path during master
        transactions to enable driving of the data along with the byte enables during master write 
        transactions.

   ************************************************************************************************     
-% 
                        
hr_dat_sel                      = (WAIT_WAIT32 OR MW_LAST or (dac_cyc_strobe));  

        -- Data output to the AD bus
			-- CBE hold register data select
--        hr_cbe_sel              = (dac_cyc_strobe) OR MS_ADR2 OR MW_WAIT;
        hr_cbe_sel              = MS_ADR2 OR hr_dat_sel;


        
---------------------------------------------------------------------------------------------------     
---- Address/Command Byte Enable Output Clock Enable ----------------------------------------------
ADOR_ena_lc1            = (MW_LXFR and mstr_wr_dxfr);
ADOR_ena                        = (ADOR_ena_lc or ADOR_ena_lc1);
IF (PCI_32 == "NO") GENERATE
   ADOR_ena_lc             = LCELL(MS_ENA or dac_cyc_strobe or MS_ADR2);
ELSE GENERATE
   ADOR_ena_lc             = MS_ENA;
END GENERATE;   

-- Hold register clock enable
IF (PCI_32 == "NO") GENERATE
   dati_hr_ena_lc          = LCELL(not MW_WAIT and not MW_WAIT_32 and MS_DXFR);
ELSE GENERATE
   dati_hr_ena_lc          = LCELL(not MW_WAIT and MS_DXFR);
END GENERATE;

dati_HR_ena                     = (dati_hr_ena_lc OR MS_ENA) ;

cbe_ce                  =       MS_ENA OR MS_ADR OR (MS_ADR2 and dac_cyc ); 
                                
cbe_HR_ena              =       MS_ENA OR MS_ADR OR (!MW_WAIT and not MW_WAIT_32  and MS_DXFR);
---------------------------------------------------------------------------------------------------     

---- Local Master Valid Data OUtput ---------------------------------------------------------------
        -- Local Master Data Output Valid
        -- This signal Indicates that valid data is availabe on the l_dato bus during Master Read
        -- It is asserted when the target asserts its trdy signal even if the master does not assert
        -- its irdy signal
lm_dato_vld.clk         = clk;
lm_dato_vld.clrn        = rstn;
lm_dato_vld_lc1         = LCELL(MR_LWAIT Or     MR_LLWAIT);
IF(PCI_FAMILY_STRATIXII() or PCI_FAMILY_CYCLONE()) GENERATE
lm_dato_vld_trdy        = LCELL(trdy);
lm_dato_vld.d           = (not wr_rdn and lm_dato_vld_trdy and MS_DXFR)
                       or lm_dato_vld_lc1;
ELSE GENERATE
lm_dato_vld.d           = (not wr_rdn and trdy and MS_DXFR)
                         or lm_dato_vld_lc1;
END GENERATE;


lm_dato_vld_out = lm_dato_vld;
-- Data Transfered between local and core 
lm_dxfrn = LCELL(not (not lm_rdynR and not lm_ackn));
---------------------------------------------------------------------------------------------------     

--==== LM_LDAT_ACKN and LM_HDAT_ACKN Logic for 32-bit PCI/64-bit Local Side =======================     
IF (PCI_32 == "NO") GENERATE
  WAIT_ndirect.clk = clk;
  WAIT_ndirect.clrn = rstn;
  WAIT_ndirect_lc = LCELL((MW_DXFR_32 and not lm_rdynR)OR (MW_WAIT and not devsel_toR));
  
  IF(PCI_FAMILY_STRATIXII() or PCI_FAMILY_CYCLONE()) GENERATE
    WAIT_ndirect_trdy = LCELL(trdy);
    WAIT_ndirect = WAIT_ndirect_lc and not direct_xfr and not stop and (not WAIT_ndirect_trdy);
  ELSE GENERATE
    WAIT_ndirect = WAIT_ndirect_lc and not direct_xfr and not stop and (not trdy);
  END GENERATE;
  
   
END GENERATE;

IF (PCI_32 == "NO") GENERATE
   hi_low_sel              = (dac_cyc_strobe) OR WAIT_ndirect or (MW_DXFR_32);     
ELSE GENERATE
   hi_low_sel              = GND;
END GENERATE;
        
--------- Non-Registered ---------------------------------------------------------

--      lm_ldata_ack                    = LCELL(
----                                                            (tgt_64_response  and not MR_IDLE and not cfg_cyc) 
--                                                                       ( !lm_lack and (not MR_IDLE)) 
--                                                                      or ((pure_32 or io_cyc or tgt_64_response) and (not MR_IDLE or not MW_IDLE))
--                                                                      or (lm_req64R and not MW_IDLE)
--                                                                      or (MW_LXFR or MW_HOLD)                                                                 
--                                                      );
--      lm_hdata_ack                    = LCELL(
--                                                              ((tgt_64_response)  and (not MR_IDLE or not MW_IDLE)) --and not cfg_cyc)
--                                                                      or (  lm_lack AND NOT MR_IDLE and not pure_32)
--                                                                      or (lm_req64R and not MW_IDLE)                                                                  
--                                                                      or ((MW_LXFR or MW_HOLD) and not pure_32)
--
--                                                      );
                                                        
-----------------------------------------------------------------------------------

IF(PCI_32 == "NO") GENERATE
        ---- LM_LDATA_ACKN ------------------------------------

--      Asserted during address phase for Read and Writes
--      In the case of not direct transfer it toggles every lm_dxfrn
--      In case of direct xfr it remains asserted until TS_TURN_AR for Writes and lm_ackn for the reads

--              lm_ldata_ack.clrn       = rstn ;
--              lm_ldata_ack.prn        = NOT MS_ADR;
--              lm_ldata_ack.clk        = clk;

--              lm_ldata_ack.ena        = not lm_dxfrn 
--                                                                              OR retry_det
--                                                                              OR tabrt_set
--                                                                              OR mstr_abrt
--                                                                              OR disc0_det
--                                                                              OR disc1_det
--                                                                              OR cfg_cyc
--                                                                              OR MS_ENA
--                                                                              OR MW_END
--                                                                              OR MR_END;
--
--              lm_ldata_ack.d          =       (       (NOT MR_IDLE AND NOT MR_LLXFR AND NOT MR_END) AND CASCADE (not lm_ldata_ack AND not tgt_64_response and not lm_dxfrn) ) -- Invert Term
--                                                      OR      (lm_ldata_ack and lm_dxfrn)                                                                                                                                                     -- Keep state until changed
--                                                      OR      (       (pure_32 or io_cyc or tgt_64_response) and CASCADE (NOT MR_IDLE AND NOT MR_LLXFR AND NOT MR_END) )              -- set for 64-Bit read transactions where target is 64-bit
--                                                      OR      (       (pure_32 or io_cyc or lm_req64R) and CASCADE (not MW_IDLE and not MW_END))                                              -- Set for 64-bit wr_rdn Transaction
--                                                      OR      (MS_ADR)                                                                                                                                                                                        -- Set during MS_ADR            
--                                                      OR      MS_ENA AND gnt                                                                                                                                                                          -- Set on Transfer to ADR
--                                                              ;
        

     lm_ldata_ack.clrn       = rstn ;
     lm_ldata_ack.clk        = clk;
     lm_ldata_ack_ena1 = LCELL(                 retry_det
                                                                     OR tabrt_set
                                                                     OR mstr_abrt
                                                                     OR disc0_det
                                                             );
     lm_ldata_ack_ena2       = LCELL(           %- disc1_det
                                                                     OR cfg_cyc 
                                                                     OR -% MW_END
                                                                     OR MR_END
                                                             );
     lm_ldata_ack_ena3       = LCELL(not lm_dxfrn 
                                                                     %- OR lm_ldata_ack_ena1 -%
                                                                     OR lm_ldata_ack_ena2
                                                                     OR MS_ENA
                                                             );
     lm_ldata_ack.ena        = lm_ldata_ack_ena3;

     lm_ldata_ack_lc1_cascade        =       not lm_ldata_ack AND not tgt_64_response;
     lm_ldata_ack_lc1        = LCELL(        (NOT MR_IDLE AND NOT MR_LLXFR AND NOT MR_END) AND lm_ldata_ack_lc1_cascade );
     lm_ldata_ack_lc2_cascade        =       NOT MR_IDLE AND NOT MR_LLXFR AND NOT MR_END;
     lm_ldata_ack_lc2        = LCELL(        (pure_32 or io_cyc or tgt_64_response) and lm_ldata_ack_lc2_cascade );
     lm_ldata_ack_lc3_cascade        =       not MW_IDLE and not MW_END;
     lm_ldata_ack_lc3        = LCELL(        (pure_32 or io_cyc or lm_req64R) and lm_ldata_ack_lc3_cascade);
     
     lm_ldata_ack_lc4        = LCELL(        lm_ldata_ack_lc1
                                                             OR      lm_ldata_ack_lc2
                                                             OR      lm_ldata_ack_lc3
                                                             OR      MS_ADR
                                                             );

     lm_ldata_ack.d          =       lm_ldata_ack_lc4
                                             OR      MS_ENA AND gnt  and no_op_reg2
                                                     ;
     
     lm_ldata_ackn                   = not lm_ldata_ack;
        -------------------------------------------------------
-- Asserted during 64-Bit wr_rdn Cycles
-- Asserted During 64-Bit Read Cycles if ack64 is asserted

      lm_hdata_ack.clk        = clk;
      lm_hdata_ack.clrn       = rstn ;
      
      lm_hdata_ack_ena1       = LCELL(--disc1_det OR 
                                         MW_END
                                                                      OR MR_END
                                                                      OR MS_ENA
                                                                      OR MS_ADR
                                                                      OR MS_DXFR
                                                              );
      lm_hdata_ack_ena2 = LCELL(not lm_dxfrn
                                                                      OR lm_ldata_ack_ena1
                                                                      OR lm_hdata_ack_ena1
                                                              );
      lm_hdata_ack.ena        = lm_hdata_ack_ena2;


      lm_hdata_ack_lc1        =       LCELL((lm_req64R) AND (((MS_ADR OR MS_ADR2) AND wr_rdn) ));
                
        
      lm_hdata_ack_lc2_cascade        =       MS_DXFR AND NOT MW_IDLE AND NOT MW_END AND wr_rdn;
      lm_hdata_ack_lc2        =       LCELL((lm_req64R) AND lm_hdata_ack_lc2_cascade);
      lm_hdata_ack_lc3_cascade        =       NOT MR_LLXFR AND NOT MR_END;
      lm_hdata_ack_lc3        =       LCELL(lm_hdata_ack and lm_dxfrn AND NOT MR_IDLE AND lm_hdata_ack_lc3_cascade);
      lm_hdata_ack_lc4_cascade        = NOT wr_rdn AND NOT MR_IDLE AND NOT MR_LLXFR AND NOT MR_END;
      lm_hdata_ack_lc4        =       LCELL(NOT lm_hdata_ack AND not direct_XFR and not lm_dxfrn AND 
                                                                                                        lm_hdata_ack_lc4_cascade);
                        
      lm_hdata_ack_lc5        =       LCELL   (       lm_hdata_ack_lc1
                                                                      OR      lm_hdata_ack_lc2
                                                                      OR      lm_hdata_ack_lc3
                                                                      OR      lm_hdata_ack_lc4
                                                                      );
      lm_hdata_ack_lc6        =       LCELL(NOt wr_rdn AND NOT MR_IDLE AND NOT MR_LLXFR AND NOT MR_END);

      lm_hdata_ack_lc7        =       LCELL   (       (lm_req64R and wr_rdn_set)
                                                                      OR      (lm_hdata_ack_lc6 and tgt_64_response)
                                                                      );
      
      lm_hdata_ack_lc8        =       LCELL   (       (lm_hdata_ack_lc5)
                                                                      OR      (lm_hdata_ack_lc7)      
                                                                      );
                                                                      
      lm_hdata_ack            =               lm_hdata_ack_lc8
                                              OR      (        lm_hdata_ack_lc6 and ack64);
                                              
      
      
                                                                                              
      lm_hdata_ackn                   = not lm_hdata_ack;                                                             
 END GENERATE;                   
--=================================================================================================
                
---- PCI Bus Request Output Register --------------------------------------------------------------
-- See Notice in MS_IDLE Optimization
--      req_or.d                =       (MS_IDLE AND mstr_enable and (lm_req64 # lm_req32) and MR_IDLE )
--                                      OR      (MS_REQ )
--                                      OR      (MS_ENA AND NOT gnt)            
--                                      OR      (MS_PARK and (lm_req64 # lm_req32) AND MR_IDLE and not gnt);    

--      req_or.d                =       (MS_REQ )
--                                      OR      (MS_IDLE AND l_req_vld)
--                                      OR      (MS_ENA AND NOT gnt)            
--                                      OR      (MS_PARK and l_req_vld and not gnt);    

-- Carry Chaine is added to speed up lm_req32n and lm_req64n in l_req_vld
req_or.clk                      = clk;
req_or.clrn                     = rstn;

req_or_lc1                      =   (MS_REQ )
                                        OR      (MS_IDLE AND l_req_vld);
                        
req_or_lc2                      =   (MS_ENA )
                                        OR      (MS_PARK and l_req_vld);                

req_or.d                        =       req_or_d;

  req_or_d  = LCELL(req_or_lc1 or       req_or_lc2 and not gnt);

req_or_out                      = req_or;
-------------------------------------------------------------------------------------------     
adr_phase.clk           = clk;
adr_phase.clrn          = rstn;
adr_phase                       = (MS_ENA and (gnt)) OR (MS_ADR and dac_cyc);

dac_cyc_strobe.clk      = clk;
dac_cyc_strobe.clrn     = rstn;
dac_cyc_strobe          = dac_cmd and MS_ENA and gnt and no_op_reg3;  

-- Used to endicate when the address phase is completed to trigger the data transfer phase
adr_phase_end_lc1       =       LCELL(MS_ADR AND dac_cyc);

adr_phase_end.clk       = clk;
adr_phase_end.clrn      = rstn;
adr_phase_end           =       not dac_cmd and MS_ENA AND gnt
                                                OR  adr_phase_end_lc1;
        
--==== Framen Output Register =====================================================================
        -- frame is asserted during address phase and deasserted
        -- during the last xfr


        %-                                                      

                                                                                                                        
        frame_or_lc2            = LCELL(        (MS_DXFR and wr_rdn and not (MW_LXFR and lm_rdynR))
                                                                OR      (MR_PXFR )
                                                                OR      (MR_DXFR )
                                                                OR      (MR_LWAIT AND not lm_rdyn)
                                                                );                                              
        
        frame_or_lc3            = LCELL(        (MW_DXFR AND not lm_rdynR AND direct_xfr AND last_xfr)
                                                                OR      (MW_WAIT and direct_xfr AND last_xfr)
                                                                OR      (MW_WAIT_32 and latcntr_toR)
                                                                OR      (MW_DXFR_32 and last_xfr_lc1)
                                                                OR      (MR_PXFR and not lm_rdyn AND last_xfr)
                                                                OR      (MR_DXFR and not lm_rdyn AND last_xfr)
                                                                ); 
-%      
IF (OPTIMIZE_FRAME == "NO") GENERATE
  frame_or.clk    = clk;
  frame_or.clrn   = rstn;
  frame_or                = frame_or_d;
  frame_out               = frame_OR;
  frame_or_d              = 	(MS_ENA and gnt) 
                          OR    (dac_cyc_strobe)
                          OR    (	(	NOT(	(	(MS_DXFR AND devsel_toR)
                                                OR	(MR_LLXFR)
                                                )       
                                           OR	(MW_LXFR AND not lm_rdynR and direct_xfr AND last_xfr)
                                           OR	((MR_IDLE AND adr_phase and not wr_rdn) AND last_xfr)  
                                           OR  	(( MR_LWAIT AND NOT lm_rdyn)AND last_xfr)  
                                           ) AND (frame_or and NOT MS_IDLE)
                                     )
                                	and	(	not	(	(	(MS_DXFR and wr_rdn and not MW_LXFR)
                                					OR 	(MW_LXFR AND NOT lm_rdynR)
													OR  (MR_PXFR )
													OR	(MR_DXFR )
													OR	(MR_LWAIT AND not lm_rdyn)
													) and stop
												)
										)
									and	(	not	(	(	(MW_DXFR AND not lm_rdynR AND last_xfr AND direct_xfr)
													OR	(MW_WAIT and last_xfr and direct_xfr)
                                                    OR	(MW_WAIT_32 and latcntr_toR)
                                                    OR	(MW_DXFR_32 and  last_xfr and not lm_last)
                                                    OR	(MR_PXFR AND last_xfr and not lm_rdyn)
                                                    OR	(MR_DXFR AND last_xfr and not lm_rdyn)
                                                    ) and trdy
												)
										)
								);       

ELSE GENERATE
--      frame_or_lc1            = (NOT  (       (       (MS_DXFR AND devsel_toR)
--                                                                      OR      (MR_LLXFR)
--                                                                      )
--                                                              OR      (MW_LXFR AND not lm_rdynR and direct_xfr AND last_xfr)
--                                                              OR      ((MR_IDLE AND adr_phase and not wr_rdn) AND last_xfr)  
--                                                              OR      (( MR_LWAIT AND NOT lm_rdyn)AND last_xfr)  
--                                                              ) AND (frame_or and NOT MS_IDLE)
--                                                              );

   frame_or_lc1a           = LCELL (       (       (MS_DXFR AND devsel_toR)
                                                                   OR      (MR_LLXFR)
                                                                   ) 
                                                           );
                                                                   
   frame_or_lc1b           = LCELL (MW_LXFR AND not lm_rdynR and direct_xfr);                                                      
   
   frame_or_lc1c_carry.cin = MR_LWAIT AND NOT lm_rdyn;
   frame_or_lc1c_carry.sin = VCC;
   
   frame_or_lc1c           = LCELL (       (       (MR_IDLE AND adr_phase and not wr_rdn)
                                                                   OR      frame_or_lc1c_carry.cout
                                                                   ) 
                                                           );
                                                           
   frame_or_lc1_cascade    =       NOT frame_or_lc1a AND frame_or and NOT MS_IDLE;
   frame_or_lc1            = LCELL( 	NOT  (	(frame_or_lc1b AND last_xfr)
                                             OR  (frame_or_lc1c AND last_xfr)  
                                             ) AND frame_or_lc1_cascade
                                             OR dac_cyc_strobe );
 
   frame_or_lc1            = LCELL(NOT     ((frame_or_lc1b AND last_xfr)
                                                                   OR      (frame_or_lc1c AND last_xfr)  
                                                                   ) AND frame_or_lc1_cascade
                                                           );


--      frame_or_lc2            = LCELL(        (MS_DXFR and wr_rdn and not (MW_LXFR and lm_rdynR))
--                                                              OR      (MR_PXFR )
--                                                              OR      (MR_DXFR )
--                                                              OR      (MR_LWAIT AND not lm_rdyn)
--                                                              );                                              

   frame_or_lc2a           = LCELL	(	(MS_DXFR and wr_rdn and not MW_LXFR)
   								  	OR 	(MW_LXFR AND NOT lm_rdynR));
   
   frame_or_lc2b           = LCELL (       (MR_PXFR )
                                                           OR      (MR_DXFR )
                                                           );
                                                                                                                   
   frame_or_lc2            = LCELL(        frame_or_lc2a
                                                           OR      frame_or_lc2b
                                                           OR      (MR_LWAIT AND not lm_rdyn)
                                                                );                                              
        
--      frame_or_lc3            = LCELL(        (MW_DXFR AND not lm_rdynR AND last_xfr AND direct_xfr)
--                                                              OR      (MW_WAIT and last_xfr and direct_xfr)
--                                                              OR      (MW_WAIT_32 and latcntr_toR)
--                                                              OR      (MW_DXFR_32 and  last_xfr and not lm_last)
--                                                              OR      (MR_PXFR AND last_xfr and not lm_rdyn)
--                                                              OR      (MR_DXFR AND last_xfr and not lm_rdyn)
--                                                              );
        
  frame_or_lc3a           = LCELL (       (MW_WAIT_32 and latcntr_toR)
                                                          OR      (MW_DXFR_32 and last_xfr_lc1)
                                                          );
                                                          
  frame_or_lc3b           = LCELL (       (MW_DXFR AND not lm_rdynR AND direct_xfr)
                                                          OR      (MW_WAIT and direct_xfr)
                                                          );
  
  frame_or_lc3c           = LCELL (       (MR_PXFR and not lm_rdyn)
                                                          OR      (MR_DXFR and not lm_rdyn)
                                                          );

  frame_or_lc3            = LCELL(        (frame_or_lc3b  AND last_xfr)
                                                                OR      frame_or_lc3a
                                                                OR      (frame_or_lc3c AND last_xfr)
                                                                );      
                                                                

        
        
   frame_or_not.clk                = clk;
   frame_or_not.prn                = rstn;
                   
   frame_or_not.d                  = frame_or_not_d;
   
   frame_out                               = NOT frame_or_not;
        
   IF(PCI_FAMILY_STRATIXII()) GENERATE     
     frame_or_cascade            = ((frame_or_lc3 and trdy) # (frame_or_lc2 and stop));
                                                                        
     frame_or_not_d              =     LCELL ( not(MS_ENA and gnt) )and  (not(frame_or_lc1) # frame_or_cascade);
   ELSE GENERATE
     frame_or_cascade            = LCELL((frame_or_lc3 and trdy) # (frame_or_lc2 and stop));
                                                                       
     frame_or_not_d              =      ( not(MS_ENA and gnt) )and  (not(frame_or_lc1) # frame_or_cascade);
   END GENERATE;

                                                                                   
   frame_or_fb1.clk                        = clk;
   frame_or_fb1.clrn               = rstn;

   frame_or_fb1                    =       (MS_ENA and gnt and no_op_reg1) 
                                                   OR      (dac_cyc_strobe )
                                                   ;

   frame_or_fb2.clk                = clk;
   frame_or_fb2.clrn               = rstn;

   frame_or_fb2_cascade    =       not (frame_or_lc3 and trdy and no_op_reg2);
   frame_or_fb2                    =       ( frame_or_lc1) 
                                                   AND (   not (frame_or_lc2 and stop))
                                                   AND frame_or_fb2_cascade;
                                                   
   frame_or_fb                             = frame_or_fb1 OR frame_or_fb2;
   
   frame_or                                = frame_or_fb;

END GENERATE;
        
--=================================================================================================

--==== Req64n Output Register =====================================================================
        -- req64 is asserted during address phase and deasserted
        -- during the last xfr, but only if a 64 bit transaction is requested from
        -- the local side
IF (OPTIMIZE_FRAME == "NO") GENERATE
   req64_or.clk            = clk;
   req64_or.clrn           = rstn;
   req64_or_d              = frame_or_d and lm_req64R;
   req64_or                = req64_or_d;
   req64_out               = req64_or;
ELSE GENERATE

  req64_or_lc1_cascade    =       NOT frame_or_lc1a and frame_or and NOT MS_IDLE AND lm_req64R;
  req64_or_lc1            = LCELL(NOT ((frame_or_lc1b AND last_xfr)
                                  OR  (frame_or_lc1c AND last_xfr)  
                                       ) AND req64_or_lc1_cascade
                                  OR (dac_cyc_strobe  and lm_req64R)                             
                                                                );
  req64_or_lc2            = LCELL(MS_ENA and lm_req64R);
  
  
  req64_out                       = req64_or;
  
  req64_or_not.clk        = clk;
  req64_or_not.prn        = rstn;
  req64_or_not.d          = req64_or_not_d;
  req64_or                        = NOT req64_or_not;
  
  IF(PCI_FAMILY_STRATIXII()) GENERATE
    req64_or_cascade  = ( (not(frame_or_lc3 and trdy)) and  (not(frame_or_lc2 and stop)));
  
    req64_or_not_d        =      LCELL( not(req64_or_lc2 and gnt)) and not( req64_or_lc1 and  req64_or_cascade);    
  ELSE GENERATE
    req64_or_cascade  = LCELL( (not(frame_or_lc3 and trdy)) and  (not(frame_or_lc2 and stop)));
  
    req64_or_not_d        =      ( not(req64_or_lc2 and gnt)) and not( req64_or_lc1 and  req64_or_cascade);    
  END GENERATE;         
END GENERATE;


--=================================================================================================

--==== Irdyn Output Register ======================================================================
        -- irdy is asserted in a write after devsel is received and there is data in the pipe
        -- irdy is asserted in a read whenever ad_ir does not have valid data

IF (OPTIMIZE_IRDY == "NO") GENERATE
                
   irdy_or.clk             = clk;
   irdy_or.clrn    = rstn;
   
   
   irdy_or.d               =               
                                                   (MR_PXFR AND NOT trdy)
                                           OR      (MR_DXFR AND NOT trdy)  
                                           OR      (MW_DXFR AND NOT (lm_rdynR AND trdy AND NOT stop))
                                           OR      (MW_LAST        AND NOT stop AND NOT trdy)
                                           OR      (MW_HOLD        and devsel)
                                           OR      (MW_WAIT)
                                           OR  (MW_WAIT_32)
                                           OR      (MW_DXFR_32)
                                           OR  (MW_DXFR_32 AND NOT trdy)                                                   
                                           OR      (MW_LXFR and not lm_rdynR and stop)
                                           OR      (MW_LXFR and not lm_rdynR and direct_xfr)
                                           OR      (MW_LXFR and not lm_rdynR and not direct_xfr and  devsel and ack64)
                                           OR      (MW_LXFR and not lm_rdynR and not direct_xfr and devsel and not ack64)
                                           OR  (MR_PXFR and stop)
                                           OR      (MR_DXFR and stop)
                                           OR      (MR_LPXFR       AND NOT stop AND NOT trdy)
                                           or      (MR_PXFR and not lm_rdyn)
                                           OR      (MR_LWAIT and not lm_rdyn)
                                           OR      (MR_DXFR and not lm_rdyn)
                                           OR      (MR_IDLE AND adr_phase_end AND NOT wr_rdn)
                                           OR      (MS_DXFR and devsel_toR and not cfg_cyc)
                                           ;
   irdy_out                        = irdy_or;

%-irdy_or.d               =               
                                                  (MR_PXFR AND NOT trdy)
                                          OR      (MR_DXFR AND NOT trdy)  
                                          OR      (MW_DXFR AND NOT trdy)
                                                                                                  
                                          OR      (MW_DXFR AND stop)
                                          OR      (MW_LXFR and not lm_rdynR and stop)
                                          OR  (MR_PXFR and stop)
                                          OR      (MR_DXFR and stop)

                                          OR      (MW_LAST        AND NOT stop AND NOT trdy)
                                          OR      (MR_LPXFR       AND NOT stop AND NOT trdy)

                                          OR      (MW_HOLD        and devsel)
                                          OR      (MW_LXFR and not lm_rdynR and not direct_xfr and  devsel )


                                          OR      (MW_DXFR AND NOT lm_rdynR)
                                          OR      (MW_WAIT)
                                          OR  (MW_WAIT_32)
                                          OR      (MW_DXFR_32)
                                          
                                          OR      (MW_LXFR and not lm_rdynR and direct_xfr)
                                          or      (MR_PXFR and not lm_rdyn)
                                          OR      (MR_LWAIT and not lm_rdyn)
                                          OR      (MR_DXFR and not lm_rdyn)
                                          OR      (MR_IDLE AND adr_phase_end AND NOT wr_rdn)
                                          OR      (MS_DXFR and devsel_toR and not cfg_cyc)
                                                        ;
-%
ELSE GENERATE
--              irdy_or.d               =               
--                                                              (irdy_or_lc7 AND NOT trdy)
--                                                              
--                                                      OR      (irdy_or_lc8 AND NOT stop AND NOT trdy)
--                                                      OR      (irdy_or_lc6 AND stop)
--                                                      
--                                                      OR      (irdy_or_lc5 AND devsel)
--                                                      
--                                                      
--                                                      OR      irdy_or_lc4
--                                                      ;




   irdy_or_lc1                     =       LCELL   (       (MW_DXFR AND NOT lm_rdynR)
                                                                   OR      (MW_WAIT)
                                                                   OR  (MW_WAIT_32)
                                                                   );
   irdy_or_lc2                     =       LCELL   (       (MR_PXFR and not lm_rdyn)
                                                                   OR      (MR_LWAIT and not lm_rdyn)
                                                                   OR      (MR_DXFR and not lm_rdyn)
                                                                   );
   irdy_or_lc3                     =       LCELL   (       (MW_DXFR_32)
                                                                   OR      (MR_IDLE AND adr_phase_end AND NOT wr_rdn)
                                                                   );
   irdy_or_lc4_cascade1    =       NOT     (MS_DXFR and devsel_toR and not cfg_cyc);
   irdy_or_lc4_cascade2    =       NOT     (       irdy_or_lc1
                                                                   OR      irdy_or_lc2
                                                                   OR      irdy_or_lc3
                                                                   )
                                                                   AND irdy_or_lc4_cascade1;
   
   irdy_or_lc4                     =       NOT     LCELL   (       NOT     (MW_LXFR and not lm_rdynR and direct_xfr and not dac_cyc_strobe)
                                                                           AND irdy_or_lc4_cascade2
                                                                           );
           
   irdy_or_lc5                     =       LCELL   (       (MW_HOLD)
                                                                   OR      (MW_LXFR and not lm_rdynR and not direct_xfr)
                                                                   );
                                                                   
   irdy_or_lc6a            = LCELL         (       (MR_PXFR)
                                                                   OR      (MR_DXFR)
                                                                   );
                                                                   
   irdy_or_lc6                     =       LCELL   (       (MW_LXFR and not lm_rdynR)
                                                                   OR  (MW_DXFR)
                                                                   OR      (irdy_or_lc6a)
                                                                   );
                                                                   
   
   -- ZA: Added the logic this way so that it does not affect already worked out timing optimization 09/03/03
                                                                   
   irdy_or_lc7                     =       LCELL   (       (MR_PXFR)
                                                                   OR      (MR_DXFR)
                                                                   OR      (MW_DXFR)
                                                                   );
                                                                   
   irdy_or_lc8                     =       LCELL   (       (MW_LAST)
                                                                        OR      (MR_LPXFR)
                                                                        );
                                                                        
                                                                        
   irdy_or_lc9                        =       LCELL   (NOT irdy_or_lc7 AND NOT irdy_or_lc8);
        
   irdy_or_lc10                    =       LCELL   (NOT irdy_or_lc7 AND NOT irdy_or_lc6);                                                                  
                                                                        


   irdy_or_not.clk             =       clk;
   irdy_or_not.prn         =       rstn;
   
   irdy_or_not.d           =       irdy_or_not_d;
   
   irdy_or_feedback.clk = clk;
   irdy_or_feedback.clrn = rstn;
   irdy_or_feedback.d  = irdy_or_feedback_d;
   
   
   
   irdy_or                         =       irdy_or_feedback;
   irdy_out                        =       NOT irdy_or_not;
   
   irdy_or_cascade = LCELL((trdy AND NOT stop) OR ( irdy_or_lc9 AND NOT stop) OR  (irdy_or_lc10 AND  stop) );
   
   
   irdy_or_not_d   = (NOT irdy_or_lc5 OR NOT devsel)       AND      (NOT irdy_or_lc4)      AND irdy_or_cascade;
   
   
   
   
   
   IF(PCI_FAMILY_STRATIXII() OR PCI_FAMILY_CYCLONE()) GENERATE
     IF(PCI_FAMILY_STRATIXII()) GENERATE
       irdy_feedback_trdy      = LCELL(trdy);
       irdy_feedback_cascade1  = (((irdy_or_lc8 AND NOT stop) OR (irdy_or_lc7) ) and not irdy_feedback_trdy);
       irdy_feedback_cascade2  =  ( irdy_feedback_cascade1 
                                    OR  (irdy_or_lc6 AND stop));
     ELSE GENERATE
       irdy_feedback_trdy      = LCELL(trdy);
       irdy_feedback_cascade1  = LCELL(((irdy_or_lc8 AND NOT stop) OR (irdy_or_lc7) ) and not irdy_feedback_trdy);
       irdy_feedback_cascade2  =  ( irdy_feedback_cascade1 
                                    OR  (irdy_or_lc6 AND stop));
     END GENERATE;
     
   ELSE GENERATE
      irdy_feedback_cascade1  = LCELL(((irdy_or_lc8 AND NOT stop) OR (irdy_or_lc7) ) and not trdy);
      irdy_feedback_cascade2  = LCELL ( irdy_feedback_cascade1 
                                    OR  (irdy_or_lc6 AND stop));
           
   END GENERATE;
        
   irdy_or_feedback_d              =       (irdy_or_lc5 AND devsel)
                                        OR      irdy_or_lc4     OR irdy_feedback_cascade2;
END GENERATE;
--=================================================================================================

--==== Lm_ackn Output Register ====================================================================
        -- lm_ack is asserted in a write after devsel is received or there is no data in the pipe
        -- lm_ack is asserted in a read whenever there is data in the pipe
IF (OPTIMIZE_ACK == "NO") GENERATE
   lm_ack_or.clk           = clk;
   lm_ack_or.clrn          = rstn;
   
   lm_ack_or                       =       MW_DXFR_32 AND lm_rdynR AND NOT last_xfr AND NOT trdy AND NOT stop 
                                           OR      MR_LLWAIT 
                                           OR      MR_LWAIT
                                           OR      MW_WAIT_32 AND NOT last_xfr AND trdy AND NOT stop 
                                           OR      MW_DXFR AND NOT last_xfr AND NOT devsel_toR AND trdy AND NOT stop 
                                           OR      MW_WAIT AND NOT last_xfr AND direct_xfr AND trdy AND NOT stop  
                                           
                                           OR      MW_LXFR AND NOT last_xfr AND NOT devsel_toR AND direct_xfr AND NOT stop  
                                           OR      MW_HOLD AND NOT lm_rdynR AND NOT last_xfr AND NOT devsel_toR AND direct_xfr AND NOT stop  
                                           OR      MW_LXFR AND lm_rdynR AND NOT devsel_toR AND NOT stop 
                                           OR      MW_DXFR AND lm_rdynR AND NOT devsel_toR AND NOT stop 
                                           OR      MW_DXFR_32 AND lm_rdynR AND NOT last_xfr_lc1 AND NOT stop       
                                                                                   
                                           OR      MW_LXFR AND NOT last_xfr AND NOT devsel_toR AND devsel AND NOT stop
                                           OR      MW_HOLD AND NOT devsel_toR AND devsel AND NOT stop
                                           OR      MR_DXFR AND trdy 
                                           OR      MR_PXFR AND trdy AND !devsel_toR 
                                           OR      MR_LPXFR AND trdy AND !devsel_toR 
                                           OR      MW_LXFR AND lm_rdynR AND trdy 
                                           
                                           OR      MS_ENA AND MW_IDLE AND low_lm_beni0 AND !dac_cyc_reg_set AND gnt 
                                           OR      MS_ENA AND MW_IDLE AND wr_rdn AND gnt
                                           OR      wr_rdn AND dac_cyc_strobe;

   lm_ackn                 = NOT lm_ack_or;



   
           
   
ELSE GENERATE

  %-lm_ack_or.clk         = clk;
  lm_ack_or.clrn          = rstn;
  
  lm_ack_or                       =       MW_DXFR_32 AND lm_rdynR AND NOT last_xfr AND NOT trdy AND NOT stop -- r1
  
                                          OR      MW_WAIT_32 AND NOT last_xfr AND trdy AND NOT stop                                       -- r2
                                          OR      MW_DXFR AND NOT last_xfr AND NOT devsel_toR AND trdy AND NOT stop 
                                          OR      MW_WAIT AND NOT last_xfr AND direct_xfr AND trdy AND NOT stop  
                                          
                                          OR      MW_LXFR AND NOT last_xfr AND NOT devsel_toR AND direct_xfr AND NOT stop  -- r3
                                          OR      MW_HOLD AND NOT lm_rdynR AND NOT last_xfr AND NOT devsel_toR AND direct_xfr AND NOT stop  
                                          OR      MW_LXFR AND lm_rdynR AND NOT devsel_toR AND NOT stop 
                                          OR      MW_DXFR AND lm_rdynR AND NOT devsel_toR AND NOT stop 
                                          OR      MW_DXFR_32 AND lm_rdynR AND NOT last_xfr_lc1 AND NOT stop       
                                                                                  
                                          OR      MW_LXFR AND NOT last_xfr AND NOT devsel_toR AND devsel AND NOT stop                     -- r3
                                          OR      MW_HOLD AND NOT devsel_toR AND devsel AND NOT stop

                                          OR      MR_DXFR AND trdy                                                                                                                -- R1
                                          OR      MR_PXFR AND trdy AND !devsel_toR 
                                          OR      MR_LPXFR AND trdy AND !devsel_toR 
                                          OR      MW_LXFR AND lm_rdynR AND trdy 
                                          
                                          OR      MS_ENA AND MW_IDLE AND low_lm_beni0 AND !dac_cyc_reg_set AND gnt                --r4
                                          OR      MS_ENA AND MW_IDLE AND wr_rdn AND gnt

                                          OR      MR_LLWAIT                                                                                                                               --r4
                                          OR      MR_LWAIT
                                          OR      wr_rdn AND dac_cyc_strobe;

-%
   lm_ack_or_r1.clk        = clk;
   lm_ack_or_r1.clrn       = rstn;
   lm_ack_or_r1.d          = lm_ack_or_r1_d;
           lm_ack_or_r1_cascade    =       NOT trdy AND lm_rdynR;
           lm_ack_or_r1_d          =       (MW_DXFR_32  AND NOT last_xfr AND NOT stop) 
                                           AND lm_ack_or_r1_cascade;
   
   lm_ack_or_r2.clk        = clk;
   lm_ack_or_r2.clrn       = rstn;
   lm_ack_or_r2.d          = lm_ack_or_r2_d;
   
   lm_ack_or_lc1           =       LCELL   (       MW_WAIT_32 
                                                                   OR      MW_DXFR AND NOT devsel_toR 
                                                                   )
                                           ;
                                           
           -- Moved last_xfr out of lm_ack_or_r2 and into lm_ack_or_lc2
           -- for stratix cascade chain
           -- MH
   lm_ack_or_lc2           =       (       lm_ack_or_lc1  
                                                           OR      MW_WAIT AND direct_xfr
                                                           ) AND NOT last_xfr;
                                                           
   lm_ack_or_lc3_cascade   =       NOT     (       MR_DXFR 
                                                                   OR      MR_PXFR AND !devsel_toR 
                                                                   OR      MR_LPXFR AND !devsel_toR
                                                                   );
   lm_ack_or_lc3           =                       LCELL(  lm_ack_or_lc3_cascade
                                                                   AND     (       NOT     (       MW_LXFR AND lm_rdynR)
                                                                                           )
                                                                   );
                                                                   
   lm_ack_or_r2_cascade    =        (trdy and no_op_reg[2] and no_op_reg[3] and no_op_reg[4]);
   lm_ack_or_r2_d          =       (       lm_ack_or_lc2 AND NOT stop OR   NOT lm_ack_or_lc3
                                                   ) AND lm_ack_or_r2_cascade;
   
   lm_ack_or_r3.clk        = clk;
   lm_ack_or_r3.clrn       = rstn;
   lm_ack_or_r3.d          = lm_ack_or_r3_d;
   
   lm_ack_or_lc4           =       LCELL   (       MW_LXFR AND NOT last_xfr AND NOT devsel_toR
                                                                   OR      MW_HOLD AND NOT devsel_toR
                                                                   );
   lm_ack_or_lc5_cascade   =       MW_LXFR OR MW_HOLD AND NOT lm_rdynR;
   lm_ack_or_lc5           =       LCELL   (       
                                                                                   (NOT last_xfr AND NOT devsel_toR AND direct_xfr)
                                                                                   AND lm_ack_or_lc5_cascade
                                                                           );
                                                                   
   lm_ack_or_lc6           =       LCELL   (       MW_LXFR 
                                                                   OR      MW_DXFR 
                                                                   OR      MW_DXFR_32 AND NOT last_xfr_lc1
                                                                   );
                                                                   
   lm_ack_or_lc7           =       LCELL   (       lm_ack_or_lc6 AND lm_rdynR AND NOT devsel_toR 
                                                                   );
   lm_ack_or_lc10      =   LCELL ( lm_ack_or_lc5
                                                   OR      lm_ack_or_lc7 );                                
                                                   
   lm_ack_or_r3_d          =       (       lm_ack_or_lc10
                                                   
                                                   OR      lm_ack_or_lc4 AND devsel
                                                   ) AND ( NOT stop );
   
   lm_ack_or_r4.clk        = clk;
   lm_ack_or_r4.clrn       = rstn;
   lm_ack_or_r4.d          = lm_ack_or_r4_d;
   
   lm_ack_or_lc8           =       LCELL   (       MR_LLWAIT                                                                                                                               
                                                                   OR      MR_LWAIT
                                                                   OR      wr_rdn AND dac_cyc_strobe
                                                                   );
                                           
   lm_ack_or_lc9           =       LCELL   (       MW_IDLE AND low_lm_beni0 AND !dac_cyc_reg_set           
                                                                   OR      MW_IDLE AND wr_rdn
                                                                   );
   
   lm_ack_or_r4_d          =       MS_ENA AND lm_ack_or_lc9 AND gnt                
                                           OR      lm_ack_or_lc8                                                                                                                           
                                           ;

   lm_ack_or                       =       LCELL   (       lm_ack_or_r1
                                                                   OR      lm_ack_or_r2
                                                                   OR      lm_ack_or_r3
                                                                   OR      lm_ack_or_r4
                                                                   );
   lm_ackn                         =       NOT lm_ack_or;
END GENERATE;


--=================================================================================================

--==== Lm_adr_ackn ================================================================================     
        -- Address Acknowledge to the Local Side
        -- This signal will get set just before transferring to MS_ADR

lm_adr_ack_R.clk = clk;
lm_adr_ack_R.clrn = rstn;

lm_adr_ack_R_lc1 = LCELL(
                                                        (lm_adr_ack_R and not MS_ENA)
                                                        OR (MS_REQ and park)
                                                );
lm_adr_ack_R_lc2 = LCELL(
                                                        (MS_PARK and (lm_req64 or lm_req32) and MR_IDLE)
                                                );
lm_adr_ack_R.d = lm_adr_ack_R_lc1
                                        OR (lm_adr_ack_R AND not gnt)
                                        OR (lm_adr_ack_R_lc2 AND gnt);

lm_adr_ack = lm_adr_ack_R;
--=================================================================================================
        
--==== Local Master Status Bus ====================================================================
lm_tsr0                 = MS_REQ;                               -- 0: Master is requesting the Bus
lm_tsr1                 = MS_ENA ;                              -- 1: Master has been Granted the bus
lm_tsr2                 = MS_ADR OR MS_ADR2;    -- 2: Master is Transferring data
lm_tsr3                 = MS_DXFR OR MS_TAR;    -- 3: Master is Transferring data
lm_tsr4                 = latcntr_toR;                  -- 4: Latency Timer has expired
lm_tsr5                 = retry_det;                    -- 5: retry
lm_tsr6                 = disc0_det;                    -- 6: Disconnect with 0 Data Transfers
lm_tsr7                 = disc1_det;                    -- 7: Disconnect with 1 Data Transfers
lm_tsr8                 = pxfr_det;                             -- 8: Successful PCI Data Phase is done

IF (PCI_32 == "NO") GENERATE
   lm_tsr9         = tgt_64_response;      
ELSE GENERATE
   lm_tsr9         = GND;
END GENERATE;

lm_tsr10				= mstr_abrt_det;
lm_tsr11				= latcntr_toR_mwi;
lm_tsr12				= targ_abrt_det OR tabrt_set; -- PCI to Avalon needs it to be one clock earlier
													  -- so I am using an or gate with tabrt_set

--=================================================================================================


---- Main Master State machine --------------------------------------------------------------------
IF (OPTIMIZE_MSTR == "NO") GENERATE
   Assert REPORT "NOT OPTIMIZING MASTER"
   Severity Warning;

   MW_WAIT_32_d_lc_1a = LCELL(MW_DXFR_32 and not lm_rdynR and not (last_xfr_lc1));
   MW_WAIT_32_d_lc_1b = LCELL(MW_DXFR and not devsel_toR and not direct_xfr and not lm_rdynR);             
   MW_WAIT_32_d_lc_1c = LCELL(
                                                   MW_WAIT_32_d_lc_1b
                                                   OR (MW_WAIT_32 )
                                           );

   MW_WAIT_32_d_lc_1d = LCELL(
                                                   (MW_WAIT and not direct_xfr and not devsel_toR)
                                                   OR MW_WAIT_32_d_lc_1a
                                           );
   mstr_sm.clk                     = clk;
   mstr_sm.reset           = not rstn;
        
   CASE mstr_sm IS 
                -- Master IDLE 
                WHEN MS_IDLE     =>     IF(mstr_enable and (lm_req64 # lm_req32) and MR_IDLE) THEN
                                                                mstr_sm         = MS_REQ;
                                                                MS_REQ_d        = VCC;
                                                        ELSIF (park) THEN
                                                                mstr_sm         = MS_PARK;
                                                                MS_PARK_d       = VCC;
                                                        ELSE
                                                                mstr_sm         = MS_IDLE;
                                                                MS_IDLE_d       = VCC;
                                                        END IF;                                         
                -- Master Request.  Master Asserting reqn PCI Output                    
                WHEN MS_REQ             =>      IF (park) THEN
                                                                mstr_sm         = MS_ENA;
                                                                MS_ENA_d        = VCC;
                                                        ELSE
                                                                mstr_sm         = MS_REQ;
                                                                MS_REQ_d        = VCC;
                                                        END IF;
                -- Master Enable.  All Output enables for PCI signals are Turned ON
                WHEN MS_ENA     =>      IF (gnt) THEN
                                                                mstr_sm         = MS_ADR;
                                                                MS_ADR_d        = VCC;
                                                        ELSE
                                                                mstr_sm         = MS_REQ;
                                                                MS_REQ_d        = VCC;
                                                        END IF;
                -- Master Address.  Address Phase
                WHEN MS_ADR     =>  IF (not dac_cyc) THEN
                                                                mstr_sm         = MS_DXFR;
                                                                MS_DXFR_d       = VCC;
                                                        ELSE 
                                                                mstr_sm         = MS_ADR2;
                                                                MS_ADR2_d       = VCC;
                                                        END IF;
                -- Master Address.  Dual Address Cycle for 64-bit Addressing
                WHEN MS_ADR2    =>  mstr_sm                     = MS_DXFR;
                                                        MS_DXFR_d               = VCC;
                -- Master Park.  Arbitor Requested Parking of Bus, All Output Enables
                -- Are turned on and All control Signals are De-Asserted.
                WHEN MS_PARK    =>      IF (gnt and (lm_req64 # lm_req32) and MR_IDLE) THEN
                                                                mstr_sm         = MS_ENA;                       -- I used MS_ENA because the AD_ce would use this 
                                                                MS_ENA_d        = VCC;                          -- transition.
                                                        
                                                        ELSIF (not gnt and (lm_req64 # lm_req32) and MR_IDLE) THEN
                                                                mstr_sm         = MS_REQ;
                                                                MS_REQ_d        = VCC;
                                                                
                                                        ELSIF (not gnt) THEN
                                                                mstr_sm         = MS_IDLE;
                                                                MS_IDLE_d       = VCC;
                                                                
                                                        ELSE
                                                                mstr_sm         = MS_PARK;
                                                                MS_PARK_d       = VCC;
                                                        END IF;
                -- Maste Data Transfer.  Read/Write State Machine is Active.
                WHEN MS_DXFR    =>      IF (mstr_done) THEN
                                                                mstr_sm         = MS_TAR;
                                                                MS_TAR_d        = VCC;
                                                        ELSE
                                                                mstr_sm         = MS_DXFR;
                                                                MS_DXFR_d       = VCC;
                                                        END IF;
                -- Master Turn Around State.  Deassert All PCI Signals
                WHEN MS_TAR             =>      mstr_sm         = MS_IDLE;
                                                        MS_IDLE_d       = VCC;
                                                        
        
        END CASE;
        
        
        -- Master Write State Machine

        mw_sm.clk                       = clk;
        mw_sm.reset                     = not rstn;
        
                
IF (VERSION_1_0_COMPATIBLE == "YES") GENERATE
                CASE mw_sm IS

                -- Master Write Idle
                WHEN MW_IDLE    =>      IF (MS_ENA AND gnt and (low_lm_beni[0])) THEN   
                                                                mw_sm           = MW_LXFR;
                                                                MW_LXFR_d       = VCC;
                                                        ELSE
                                                                mw_sm           = MW_IDLE;
                                                                MW_IDLE_d       = VCC;
                                                        END IF;
                --
                -- Master Write Local XFR.  Pipe is Empty
                -- Waiting for the first word to be recieved from the local side
                -- frame is asserted, irdy is deasserted, lm_ack is asserted.
                --

        
                WHEN MW_LXFR    =>      
                
                        IF (IRDY_SPEEDUP == "YES") GENERATE
                
                                        IF (stop) THEN                                          -- Disconnect
                                                                mw_sm           = MW_END;
                                                                MW_END_d        = VCC;
                                                ELSIF (devsel_toR) THEN                         -- Master Abort
                                                                mw_sm           = MW_END;
                                                                MW_END_d        = VCC;
                                                ELSIF   (!lm_rdynR and stop)	THEN							      				
                                                                mw_sm                   = MW_LAST;
                                                                MW_LAST_d               = VCC;
                                                ELSIF ((!lm_rdynR or retry_det) and !direct_xfr and not devsel) THEN           
                                                                mw_sm                   = MW_HOLD;
                                                                MW_HOLD_d               = VCC;
                                                ELSIF (!lm_rdynR and !direct_xfr and devsel and not ack64) THEN         -- Local side is ready, data is transferred
                                                                mw_sm                   = MW_DXFR_32;
                                                                MW_DXFR_32_d    = VCC;
                                                ELSIF (         (!lm_rdynR and direct_xfr and !last_xfr)                                        -- It is a direct transfer and it is not the last transfer
                                                          OR    (!lm_rdynR and !direct_xfr and !last_xfr and ack64)     -- Needed since direct xfr gets asserted one clock afer ack64
                                                          ) THEN
                                                                mw_sm           = MW_DXFR;
                                                                MW_DXFR_d       = VCC;
                                                ELSIF (!lm_rdynR and direct_xfr and last_xfr) THEN                                      -- It is a direct transfer and it is a last transfer
                                                                mw_sm           = MW_LAST;
                                                                MW_LAST_d       = VCC;
                                                ELSE                                                            -- Local Side needs to transfer the data
                                                                mw_sm           = MW_LXFR;
                                                                MW_LXFR_d       = VCC;
                                                END IF;
                        ELSE GENERATE
        
                                                IF (stop) THEN                                          -- Disconnect
                                                                mw_sm           = MW_END;
                                                                MW_END_d        = VCC;
                                                ELSIF (devsel_toR) THEN                         -- Master Abort
                                                                mw_sm           = MW_END;
                                                                MW_END_d        = VCC;
                                                ELSIF   (!lm_rdynR and stop)	THEN							      				
                                                                mw_sm                   = MW_LAST;
                                                                MW_LAST_d               = VCC;
                                                ELSIF (!lm_rdynR and !direct_xfr and devselR) THEN              -- Local side is ready, data is transferred
                                                                mw_sm                   = MW_DXFR_32;
                                                                MW_DXFR_32_d    = VCC;
                                                ELSIF (!lm_rdynR and !direct_xfr and not devselR) THEN          
                                                                mw_sm                   = MW_HOLD;
                                                                MW_HOLD_d               = VCC;
                                                ELSIF (!lm_rdynR and direct_xfr and !last_xfr) THEN                                     -- It is a direct transfer adn it is not the last transfer
                                                                mw_sm           = MW_DXFR;
                                                                MW_DXFR_d       = VCC;
                                                ELSIF (!lm_rdynR and direct_xfr and last_xfr) THEN                                      -- It is a direct transfer and it is a last transfer
                                                                mw_sm           = MW_LAST;
                                                                MW_LAST_d       = VCC;
                                                ELSE                                                            -- Local Side needs to transfer the data
                                                                mw_sm           = MW_LXFR;
                                                                MW_LXFR_d       = VCC;
                                                END IF;
        
                        END GENERATE;
                                                    
                -- Master Write Data Xfr. ( Only AD_OR Has valid Data)
                -- frame is asserted, irdy is asserted, lm_ackn is asserted                     

                WHEN MW_DXFR    =>      IF (stop) THEN                                          -- Disconnect
                                                                mw_sm           = MW_END;
                                                                MW_END_d        = VCC;
                                                        ELSIF (devsel_toR) THEN                         -- Master Abort
                                                                mw_sm           = MW_END;
                                                                MW_END_d        = VCC;
                                                        ELSIF (lm_rdynR and trdy) THEN
                                                                                mw_sm           = MW_LXFR;
                                                                                MW_LXFR_d       = VCC;
                                                        ELSIF (lm_rdynR and not trdy and not last_xfr) THEN
                                                                                mw_sm           = MW_DXFR;
                                                                                MW_DXFR_d       = VCC;
                                                        ELSIF (!direct_xfr and trdy) THEN
                                                                                mw_sm                   = MW_DXFR_32;
                                                                                MW_DXFR_32_d    = VCC;
                                                        ELSIF (!direct_xfr and not trdy) THEN
                                                                                mw_sm                   = MW_WAIT_32;
                                                                                MW_WAIT_32_d    = VCC;
                                                        ELSIF (!last_xfr and trdy) THEN
                                                                                mw_sm           = MW_DXFR;
                                                                                MW_DXFR_d       = VCC;
                                                        ELSIF (not trdy) THEN
                                                                                mw_sm           = MW_WAIT;
                                                                                MW_WAIT_d       = VCC;
                                                                                
                                                        ELSIF (last_xfr and trdy) THEN
                                                                                mw_sm           = MW_LAST;
                                                                                MW_LAST_d       = VCC;
                                                        ELSE
                                                                                mw_sm           = MW_DXFR;
                                                                                MW_DXFR_d       = VCC;
                                                        END IF;
                                                        
                                                        

                -- Master Write Wait.  PCI Asserted wait Both AD_OR and AD_HR have vld Data
                -- frame is asserted, irdy is asserted, lm_ackn is deasserted

                WHEN MW_WAIT    =>      IF (stop) THEN                                          -- Disconnect
                                                                mw_sm           = MW_END;
                                                                MW_END_d        = VCC;
                                                        ELSIF (devsel_toR) THEN
                                                                mw_sm           = MW_END;
                                                                MW_END_d        = VCC;
                                                        ELSIF (trdy and !direct_xfr) THEN
                                                                        mw_sm                   = MW_WAIT_32;
                                                                        MW_WAIT_32_d    = VCC;
                                                        ELSIF (trdy and direct_xfr and !last_xfr) THEN
                                                                        mw_sm           = MW_DXFR;
                                                                        MW_DXFR_d       = VCC;
                                                        ELSIF  (trdy and direct_xfr and last_xfr) THEN
                                                                        mw_sm           = MW_LAST;
                                                                        MW_LAST_d       = VCC;
                                                        ELSE
                                                                mw_sm           = MW_WAIT;
                                                                MW_WAIT_d       = VCC;
                                                        END IF;
                                                        
                                
                -- Master Write Last XFR.  Final Data Phase.  Only AD_OR Has VLD Data
                -- frame is deasserted, irdy is asserted, lm_ackn is deasserted

                WHEN MW_LAST    =>      IF (trdy) THEN
                                                                mw_sm           = MW_END;
                                                                MW_END_d        = VCC;
                                                        ELSIF (devsel_toR) THEN                         -- Master Abort
                                                                mw_sm           = MW_END;
                                                                MW_END_d        = VCC;
                                                        ELSIF(not trdy and stop) THEN
                                                                mw_sm           = MW_END;
                                                                MW_END_d        = VCC;
                                                        ELSE
                                                                mw_sm           = MW_LAST;
                                                                MW_LAST_d       = VCC;
                                                        END IF;

                -- Master Write Hold.  Wait for devsel.  Only AD_OR Has VLD Data
                -- frame is asserted, irdy is deasserted, lm_ackn is deasserted

        
                WHEN MW_HOLD            =>      
                                                
                        IF (IRDY_SPEEDUP == "YES") GENERATE
                                                IF (stop) THEN
                                                                mw_sm           = MW_END;
                                                                MW_END_d                = VCC;
                                                ELSIF (devsel_toR) THEN
                                                                mw_sm           = MW_END;
                                                                MW_END_d        = VCC;
                                                ELSIF (devsel and not ack64) THEN
                                                                mw_sm           = MW_DXFR_32;
                                                                MW_DXFR_32_d= VCC;
                                                ELSIF (devsel and ack64 ) THEN
                                                                mw_sm           = MW_DXFR;
                                                                MW_DXFR_d       = VCC;
                                                ELSE
                                                                mw_sm           = MW_HOLD;
                                                                MW_HOLD_d       = VCC;
                                                END IF;
                        ELSE GENERATE
        
                                                
                                                IF (stop) THEN
                                                                mw_sm           = MW_END;
                                                                MW_END_d                = VCC;
                                                ELSIF (devsel_toR) THEN
                                                                mw_sm           = MW_END;
                                                                MW_END_d        = VCC;
                                                ELSIF (devselR and ack64R) THEN
                                                                mw_sm           = MW_DXFR;
                                                                MW_DXFR_d       = VCC;
                                                ELSIF (devselR and not ack64R) THEN
                                                                mw_sm           = MW_DXFR_32;
                                                                MW_DXFR_32_d	= VCC;
                                                ELSE
                                                                mw_sm           = MW_HOLD;
                                                                MW_HOLD_d       = VCC;
                                                END IF;
                        END GENERATE;
                                                
                -- Master Write 32 bit Data Transfer.  Transfer lower DWORD only.  AD_OR High and Low Has VLD Data
                -- AD_HR Are empty
                -- frame is asserted, irdy is asserted, lm_ackn is asserted except during the last QWORD XFR.

                WHEN MW_DXFR_32         =>      IF (stop) THEN                                          -- Disconnect
                                                                mw_sm                   = MW_END;
                                                                MW_END_d                = VCC;
                                                ELSIF (!trdy and !lm_dxfrn) THEN                        -- PCI wait, Local ready
                                                                mw_sm                   = MW_WAIT;
                                                                MW_WAIT_d               = VCC;
                                                ELSIF (!trdy and lm_dxfrn) THEN                         -- PCI wait, Local wait
                                                                mw_sm                   = MW_DXFR_32;
                                                                MW_DXFR_32_d    = VCC;
                                                
                                                -- Since this is 32/64 xfr.  One more dword must be xferred before going to last
                                                ELSIF (trdy  and (last_xfr_lc1)) THEN   -- pci ready, local wait, last xfr
                                                                mw_sm                   = MW_LAST;              -- mmbw64_pwpd_1a.scf
                                                                MW_LAST_d               = VCC;
                                                                
                                                ELSIF (trdy and !lm_dxfrn) THEN                         -- PCI ready, local ready
                                                                mw_sm                   = MW_WAIT_32;
                                                                MW_WAIT_32_d    = VCC;
                                                ELSE --trdy and lm_rdynR and (!last_xfr or lm_last)
                                                                mw_sm                   = MW_DXFR;
                                                                MW_DXFR_d               = VCC;
                                                END IF;
                -- Master Write Wait 32 bit Data Transfer.  Transfer high bits from previous word.
                -- AD_OR High and Low Has VLD Data and AD_HR Low has Data
                -- frame is asserted, irdy is asserted, lm_ackn is deasserted

                WHEN MW_WAIT_32 =>      IF (stop) THEN
                                                                mw_sm                   = MW_END;
                                                                MW_END_d                = VCC;
                                                ELSIF (trdy and not latcntr_toR) THEN
                                                                mw_sm                   = MW_DXFR_32;
                                                                MW_DXFR_32_d    = VCC;
                                                ELSIF  (trdy and latcntr_toR) THEN
                                                                mw_sm           = MW_LAST;
                                                                MW_LAST_d       = VCC;
                                                ELSE
                                                                mw_sm                   = MW_WAIT_32;
                                                                MW_WAIT_32_d    = VCC;
                                                END IF;
                                                
                                                
                -- Master Write End.  All data has been transferred
                WHEN MW_END             =>      mw_sm           = MW_IDLE;
                                                        MW_IDLE_d       = VCC;
                                                        
        END CASE;

ELSE GENERATE

                CASE mw_sm IS

                -- Master Write Idle
                WHEN MW_IDLE    =>      IF (MS_ENA and gnt and (low_lm_beni[0] and not dac_cyc_reg_set) )THEN   
                                                        
                                                                mw_sm           = MW_LXFR;
                                                                MW_LXFR_d       = VCC;
                                                        ELSIF (MS_ENA and gnt and (high_lm_beni[0] and dac_cyc_reg_set )) THEN
                                                                mw_sm           = MW_LXFR;
                                                                MW_LXFR_d       = VCC;
                                                        ELSE
                                                                mw_sm           = MW_IDLE;
                                                                MW_IDLE_d       = VCC;
                                                        END IF;
                --
                -- Master Write Local XFR.  Pipe is Empty
                -- Waiting for the first word to be recieved from the local side
                -- frame is asserted, irdy is deasserted, lm_ack is asserted.
                --
        
                WHEN MW_LXFR    =>
                        
                                                
                        IF (IRDY_SPEEDUP == "YES") GENERATE
                                               
                                                IF (devsel_toR) THEN                                                       -- Master Abort
                                                     mw_sm                   = MW_END;
                                                     MW_END_d                = VCC;
                                                ELSIF (	(!lm_rdynR  and !direct_xfr and not devsel)                     -- Local side xfrerred data, Target did not respond     
                                                      or (retry_det)) THEN          
                                                     mw_sm                   = MW_HOLD;
                                                     MW_HOLD_d               = VCC;
                                                ELSIF (!lm_rdynR and stop)	THEN							      				
                                                     mw_sm                   = MW_LAST;
                                                     MW_LAST_d               = VCC;
                                                ELSIF (!lm_rdynR and !direct_xfr and devsel AND not ack64) THEN            -- Local side is ready, data is transferred
                                                     mw_sm                   = MW_DXFR_32;
                                                     MW_DXFR_32_d    = VCC;
                                                ELSIF (   (!lm_rdynR and direct_xfr and !last_xfr and not dac_cyc_strobe)  -- It is a direct transfer and it is not the last transfer
                                                      OR  (!lm_rdynR and !direct_xfr and !last_xfr and ack64)) THEN        -- Needed since direct xfr gets asserted one clock afer ack64
                                                     mw_sm           = MW_DXFR;
                                                     MW_DXFR_d       = VCC;
                                                ELSIF (   (!lm_rdynR and direct_xfr and last_xfr and not dac_cyc_strobe)   -- It is a direct transfer and it is a last transfer
                                                      OR  (!lm_rdynR and !direct_xfr and last_xfr and ack64)) THEN         -- Needed since direct xfr gets asserted one clock afer ack64
                                                     mw_sm                   = MW_LAST;
                                                     MW_LAST_d               = VCC;
                                                ELSE                                                                       -- Local Side needs to transfer the data
                                                     mw_sm                   = MW_LXFR;
                                                     MW_LXFR_d               = VCC;
                                                END IF;
                        ELSE GENERATE
        
                                                IF (stop) THEN                                                             -- Disconnect
                                                                mw_sm                   = MW_END;
                                                                MW_END_d                = VCC;
                                                ELSIF (devsel_toR) THEN                                                    -- Master Abort
                                                                mw_sm                   = MW_END;
                                                                MW_END_d                = VCC;
                                                ELSIF   (!lm_rdynR and stop)	THEN							      				
                                                                mw_sm                   = MW_LAST;
                                                                MW_LAST_d               = VCC;
                                                ELSIF (!lm_rdynR and !direct_xfr and devselR) THEN                         -- Local side is ready, data is transferred
                                                                mw_sm                   = MW_DXFR_32;
                                                                MW_DXFR_32_d    = VCC;
                                                ELSIF (!lm_rdynR and !direct_xfr and not devselR) THEN                     -- Local side xfrerred data, Target did not respond     
                                                                mw_sm                   = MW_HOLD;
                                                                MW_HOLD_d               = VCC;
                                                ELSIF (!lm_rdynR and direct_xfr and !last_xfr) THEN                        -- It is a direct transfer and it is not the last transfer
                                                                mw_sm                   = MW_DXFR;
                                                                MW_DXFR_d               = VCC;
                                                ELSIF (!lm_rdynR and direct_xfr and last_xfr) THEN                         -- It is a direct transfer and it is a last transfer
                                                                mw_sm                   = MW_LAST;
                                                                MW_LAST_d               = VCC;
                                                ELSE                                                                       -- Local Side needs to transfer the data
                                                                mw_sm                   = MW_LXFR;
                                                                MW_LXFR_d               = VCC;
                                                END IF;
                        END GENERATE;
                                                            
                -- Master Write Data Xfr. ( Only AD_OR Has valid Data)
                -- frame is asserted, irdy is asserted, lm_ackn is asserted                     

                WHEN MW_DXFR    =>      IF (stop) THEN                                                                     -- Disconnect
                                                                mw_sm           = MW_END;
                                                                MW_END_d        = VCC;
                                                        ELSIF (devsel_toR) THEN                                            -- Master Abort
                                                                mw_sm           = MW_END;
                                                                MW_END_d        = VCC;
                                                        ELSIF (lm_rdynR and trdy) THEN                                     -- PCI xfr and Not Loc Xfr
                                                                                mw_sm           = MW_LXFR;
                                                                                MW_LXFR_d       = VCC;
                                                        ELSIF (lm_rdynR and not trdy and not last_xfr) THEN                -- PCI Wait, Loc Wait, Not Last Xfr
                                                                                mw_sm           = MW_DXFR;
                                                                                MW_DXFR_d       = VCC;
                                                        ELSIF (!direct_xfr and trdy) THEN                                  -- Not direct xfr and PCI XFR
                                                                                mw_sm                   = MW_DXFR_32;
                                                                                MW_DXFR_32_d    = VCC;
                                                        ELSIF (!direct_xfr and not trdy) THEN                              -- Not Direct xfr and PCI Wait
                                                                                mw_sm                   = MW_WAIT_32;
                                                                                MW_WAIT_32_d    = VCC;
                                                        ELSIF (!last_xfr and trdy) THEN                                    --
                                                                                mw_sm           = MW_DXFR;
                                                                                MW_DXFR_d       = VCC;
                                                        ELSIF (not trdy) THEN
                                                                                mw_sm           = MW_WAIT;
                                                                                MW_WAIT_d       = VCC;
                                                        ELSIF (last_xfr and trdy) THEN
                                                                                mw_sm           = MW_LAST;
                                                                                MW_LAST_d       = VCC;
                                                        ELSE
                                                                                mw_sm           = MW_DXFR;
                                                                                MW_DXFR_d       = VCC;
                                                        END IF;
                                                        
                                                        

                -- Master Write Wait.  PCI Asserted wait Both AD_OR and AD_HR have vld Data
                -- frame is asserted, irdy is asserted, lm_ackn is deasserted

                WHEN MW_WAIT    =>      IF (stop) THEN                                                                     -- Disconnect
                                                                mw_sm           = MW_END;
                                                                MW_END_d        = VCC;
                                                        ELSIF (devsel_toR) THEN
                                                                mw_sm           = MW_END;
                                                                MW_END_d        = VCC;
                                                        ELSIF (trdy and !direct_xfr) THEN
                                                                        mw_sm                   = MW_WAIT_32;
                                                                        MW_WAIT_32_d    = VCC;
                                                        ELSIF (trdy and direct_xfr and !last_xfr) THEN
                                                                        mw_sm           = MW_DXFR;
                                                                        MW_DXFR_d       = VCC;
                                                        ELSIF  (trdy and direct_xfr and last_xfr) THEN
                                                                        mw_sm           = MW_LAST;
                                                                        MW_LAST_d       = VCC;
                                                        ELSE
                                                                mw_sm           = MW_WAIT;
                                                                MW_WAIT_d       = VCC;
                                                        END IF;
                                                                                        
                                
                -- Master Write Last XFR.  Final Data Phase.  Only AD_OR Has VLD Data
                -- frame is deasserted, irdy is asserted, lm_ackn is deasserted

                WHEN MW_LAST    =>      IF (trdy) THEN
                                                                mw_sm           = MW_END;
                                                                MW_END_d        = VCC;
                                                        ELSIF (devsel_toR) THEN                         -- Master Abort
                                                                mw_sm           = MW_END;
                                                                MW_END_d        = VCC;
                                                        ELSIF(not trdy and stop) THEN
                                                                mw_sm           = MW_END;
                                                                MW_END_d        = VCC;
                                                        ELSE
                                                                mw_sm           = MW_LAST;
                                                                MW_LAST_d       = VCC;
                                                        END IF;

                -- Master Write Hold.  Wait for devsel.  Only AD_OR Has VLD Data
                -- frame is asserted, irdy is deasserted, lm_ackn is deasserted

        
                WHEN MW_HOLD            =>      
                        IF (IRDY_SPEEDUP == "YES") GENERATE
                                                
                                                IF (stop) THEN
                                                                mw_sm           = MW_END;
                                                                MW_END_d                = VCC;
                                                                
                                                ELSIF (devsel_toR) THEN
                                                                mw_sm           = MW_END;
                                                                MW_END_d        = VCC;
                                                                
                                                ELSIF (devsel and not ack64) THEN
                                                                        mw_sm           = MW_DXFR_32;
                                                                        MW_DXFR_32_d= VCC;
                                                                        
                                                ELSIF (devsel and ack64) THEN
                                                                        mw_sm           = MW_DXFR;
                                                                        MW_DXFR_d       = VCC;
                                                ELSE
                                                                mw_sm           = MW_HOLD;
                                                                MW_HOLD_d       = VCC;
                                                END IF;
                                                
                        ELSE GENERATE
        
                                                IF (stop) THEN
                                                                mw_sm           = MW_END;
                                                                MW_END_d                = VCC;
                                                ELSIF (devsel_toR) THEN
                                                                mw_sm           = MW_END;
                                                                MW_END_d        = VCC;
                                                ELSIF (devselR and ack64R) THEN
                                                                        mw_sm           = MW_DXFR;
                                                                        MW_DXFR_d       = VCC;
                                                ELSIF (devselR and not ack64R) THEN
                                                                        mw_sm           = MW_DXFR_32;
                                                                        MW_DXFR_32_d= VCC;
                                                ELSE
                                                                mw_sm           = MW_HOLD;
                                                                MW_HOLD_d       = VCC;
                                                END IF;
                        END GENERATE;
                                                
                -- Master Write 32 bit Data Transfer.  Transfer lower DWORD only.  AD_OR High and Low Has VLD Data
                -- AD_HR Are empty
                -- frame is asserted, irdy is asserted, lm_ackn is asserted except during the last QWORD XFR.

                WHEN MW_DXFR_32         =>      IF (stop) THEN                                          -- Disconnect
                                                                mw_sm                   = MW_END;
                                                                MW_END_d                = VCC;
                                                ELSIF (!trdy and !lm_dxfrn) THEN                        -- PCI wait, Local ready
                                                                mw_sm                   = MW_WAIT;
                                                                MW_WAIT_d               = VCC;
                                                ELSIF (!trdy and lm_dxfrn) THEN                         -- PCI wait, Local wait
                                                                mw_sm                   = MW_DXFR_32;
                                                                MW_DXFR_32_d    = VCC;
                                                
                                                -- Since this is 32/64 xfr.  One more dword must be xferred before going to last
                                                ELSIF (trdy  and (last_xfr_lc1)) THEN   -- pci ready, local wait, last xfr
                                                                mw_sm                   = MW_LAST;              -- mmbw64_pwpd_1a.scf
                                                                MW_LAST_d               = VCC;
                                                                
                                                ELSIF (trdy and !lm_dxfrn) THEN                         -- PCI ready, local ready
                                                                mw_sm                   = MW_WAIT_32;
                                                                MW_WAIT_32_d    = VCC;
                                                ELSE --trdy and lm_dxfrn and (!last_xfr or lm_last)
                                                                mw_sm                   = MW_DXFR;
                                                                MW_DXFR_d               = VCC;
                                                END IF;


                -- Master Write Wait 32 bit Data Transfer.  Transfer high bits from previous word.
                -- AD_OR High and Low Has VLD Data and AD_HR Low has Data
                -- frame is asserted, irdy is asserted, lm_ackn is deasserted

                WHEN MW_WAIT_32 =>      IF (stop) THEN
                                                                mw_sm                   = MW_END;
                                                                MW_END_d                = VCC;
                                                ELSIF (trdy and not latcntr_toR) THEN
                                                                mw_sm                   = MW_DXFR_32;
                                                                MW_DXFR_32_d    = VCC;
                                                ELSIF  (trdy and latcntr_toR) THEN
                                                                mw_sm           = MW_LAST;
                                                                MW_LAST_d       = VCC;
                                                ELSE
                                                                mw_sm                   = MW_WAIT_32;
                                                                MW_WAIT_32_d    = VCC;
                                                END IF;
                                                
                                                
                -- Master Write End.  All data has been transferred
                WHEN MW_END             =>      mw_sm           = MW_IDLE;
                                                        MW_IDLE_d       = VCC;
                                                        
        END CASE;
END GENERATE;
        
-- Master Read state machine

        mr_sm.clk               = clk;
        mr_sm.reset             = not rstn;
        
        case mr_sm IS
        
                WHEN MR_IDLE    =>      IF (MS_ADR and NOT wr_rdn and not last_xfr and not dac_cyc) THEN
                                                                mr_sm           = MR_PXFR;
                                                                MR_PXFR_d       = VCC;
                                                        ELSIF (MS_ADR and not wr_rdn and last_xfr and not dac_cyc) THEN
                                                                mr_sm           = MR_LPXFR;
                                                                MR_LPXFR_d      = VCC;
                                                        ELSIF (MS_ADR2 and NOT wr_rdn and not last_xfr and dac_cyc) THEN
                                                                mr_sm           = MR_PXFR;
                                                                MR_PXFR_d       = VCC;
                                                        ELSIF (MS_ADR2 and not wr_rdn and last_xfr and dac_cyc) THEN
                                                                mr_sm           = MR_LPXFR;
                                                                MR_LPXFR_d      = VCC;
                                                        ELSE
                                                                mr_sm           = MR_IDLE;
                                                                MR_IDLE_d       = VCC;
                                                        END IF;
                                                        
                -- Wait to recieve First PCI WORD
                -- irdy is asserted, Frame is asserted, and lm_ack is deasserted
                WHEN MR_PXFR    =>      IF (devsel_toR) THEN
                                                                mr_sm           = MR_END;                       -- End State Machine
                                                                MR_END_d        = VCC;
                                                        ELSIF (not trdy and stop) THEN
                                                                mr_sm           = MR_END;                       -- Disconnect without Data
                                                                MR_END_d        = VCC;
                                                        ELSIF (not trdy and not stop) THEN
                                                                mr_sm           = MR_PXFR;                      -- PCI not ready
                                                                MR_PXFR_d       = VCC;
                                                        ELSIF (stop and lm_rdyn and trdy) THEN
                                                                mr_sm           = MR_LLWAIT;            -- Disconnect with data
                                                                MR_LLWAIT_d     = VCC;
                                                        ELSIF (not stop and lm_rdyn and trdy) THEN
                                                                mr_sm           = MR_LWAIT;                     -- Normal Local Side wait
                                                                MR_LWAIT_d      = VCC;
                                                        ELSIF (not last_xfr and not stop and not lm_rdyn and trdy) THEN
                                                                mr_sm           = MR_DXFR;                      -- Normal data xfr both sides are ready
                                                                MR_DXFR_d       = VCC;
                                                        ELSIF (last_xfr and not stop and not lm_rdyn and trdy) THEN
                                                                mr_sm           = MR_LPXFR;                     -- Last PCI xfr
                                                                MR_LPXFR_d      = VCC;
                                                        ELSE                                                            -- stop and lm_busy and trdy
                                                                mr_sm           = MR_LLXFR;                     -- Last Local Xfr
                                                                MR_LLXFR_d      = VCC;
                                                        END IF;
                                                        
                                                        
                                                        
                                                        
                -- Normal PCI XFR, Local not asserting Wait and PCI not asserting wait
                -- irdy is asserted, frame is asserted and lm_ack is asserted
                WHEN MR_DXFR    =>      IF (not trdy and stop) THEN
                                                                mr_sm           = MR_END;                               -- Disconnect without data
                                                                MR_END_d        = VCC;
                                                        ELSIF (not trdy and not stop) THEN
                                                                mr_sm           = MR_PXFR;                              -- PCI Wait Pipe is empty
                                                                MR_PXFR_d       = VCC;
                                                        ELSIF (lm_rdyn and trdy and stop) THEN
                                                                mr_sm           = MR_LLWAIT;                    -- Last Local Wait
                                                                MR_LLWAIT_d     = VCC;
                                                        ELSIF ( lm_rdyn and trdy and not stop) THEN
                                                                mr_sm           = MR_LWAIT;                             -- Local Wait
                                                                MR_LWAIT_d      = VCC;
                                                        ELSIF ( not last_xfr and not lm_rdyn and trdy and not stop) THEN
                                                                mr_sm           = MR_DXFR;                              -- Normal Data Transfer
                                                                mr_DXFR_d       = VCC;
                                                        ELSIF ( last_xfr and not lm_rdyn and trdy and not stop) THEN
                                                                mr_sm           = MR_LPXFR;                             -- Last PCI Transfer requested by master
                                                                MR_LPXFR_d      = VCC;
                                                        ELSE
                                                                mr_sm           = MR_LLXFR;                             -- Last Local Wait
                                                                MR_LLXFR_d      = VCC;
                                                        END IF;

                --
                -- Last PCI Transfer. Pipe is empty and waiting for last PCI xfr.
                -- This will be entered only if last xfr is initiated by master not target
                -- irdy is asserted, frame is deasserted
                -- lm_ack is asserted at the transition to this state.MR_LPXFR_d and not MR_LPXFR
                --
                
                WHEN MR_LPXFR   =>      IF (devsel_toR) THEN
                                                                mr_sm           = MR_END;                               -- End State Machine
                                                                MR_END_d        = VCC;
                                                        ELSIF (not trdy and stop) THEN
                                                                mr_sm           = MR_END;                               -- Disconnect without data
                                                                MR_END_d        = VCC;
                                                        ELSIF (not lm_rdyn and trdy) THEN                               -- Both PCI and Local are ready
                                                                mr_sm           = MR_LLXFR;                             -- Last Local Transfer
                                                                MR_LLXFR_d      = VCC;
                                                        ELSIF (lm_rdyn and trdy) THEN           -- PCI is ready but not local 
                                                                mr_sm           = MR_LLWAIT;                    -- Last Local Wait 
                                                                MR_LLWAIT_d     = VCC;
                                                        ELSE
                                                                mr_sm           = MR_LPXFR;
                                                                MR_LPXFR_d      = VCC;
                                                        END IF;
                --
                -- Local Wait:  Pipe has data but local side is busy
                -- irdy is deasserted, frame is asserted, lm_ack is deasserted
                --
                WHEN MR_LWAIT   =>      IF (lm_rdyn) THEN
                                                                mr_sm           = MR_LWAIT;                             -- Local Wait
                                                                MR_LWAIT_d      = VCC; 
                                                        ELSIF (not last_xfr and not stop) THEN
                                                                mr_sm           = MR_PXFR;                              -- PCI wait
                                                                MR_PXFR_d       = VCC;
                                                        ELSE
                                                                mr_sm           = MR_LPXFR;                             -- PCI Wait
                                                                MR_LPXFR_d      = VCC;
                                                        END IF;
                --                                      
                -- last Local Wait.  Waiting for local side to xfr last data
                -- irdy is deasserted, frame is asserted, lm_ack is deasserted
                --
                WHEN MR_LLWAIT  =>      IF (not lm_rdyn) THEN
                                                                mr_sm           = MR_LLXFR;
                                                                MR_LLXFR_d      = VCC;
                                                        ELSE
                                                                mr_sm           = MR_LLWAIT;
                                                                MR_LLWAIT_d     = VCC;
                                                        END IF;
                                                        
                --                                      
                -- last Local Transfer
                -- irdy is deasserted, frame is deasserted, lm_ack is asserted
                --
                 
                WHEN MR_LLXFR   =>      mr_sm           = MR_END;
                                                        MR_END_d        = VCC;
                                                        
                WHEN MR_END             =>      mr_sm           = MR_IDLE;
                                                        MR_IDLE_d       = VCC;

        
                                                                                        
        
        END CASE;
        
        
ELSE GENERATE


        Assert REPORT "------------- *** OPTIMIZING MASTER *** -----------------"
        Severity Debug;
        
        
---------- Master State Machine -------------------------------------------------

        MS_IDLE_not.clk         = clk;
        MS_REQ.clk              = clk;
        MS_ENA.clk              = clk;
        MS_ADR.clk              = clk;
        MS_ADR2.clk             = clk;
        MS_PARK.clk             = clk;
        MS_DXFR.clk             = clk;
        MS_TAR.clk              = clk;
        
        
        MS_IDLE_not.clrn                = rstn;
        MS_REQ.clrn             = rstn;
        MS_ENA.clrn             = rstn;
        MS_ADR.clrn             = rstn;
        MS_ADR2.clrn            = rstn;
        MS_PARK.clrn            = rstn;
        MS_DXFR.clrn            = rstn;
        MS_TAR.clrn             = rstn;

        MS_IDLE_not.d           = not   MS_IDLE_d;
        MS_REQ.d                = MS_REQ_d;
        MS_ENA.d                = MS_ENA_d;
        MS_ADR.d                = MS_ADR_d;
        MS_ADR2.d               = MS_ADR2_d;
        MS_PARK.d               = MS_PARK_d;
        MS_DXFR.d               = MS_DXFR_d;
        MS_TAR.d                = MS_TAR_d;
                                                
                                                
%-                                              
                                
        
        MS_PARK_d = (MS_IDLE and not ((mstr_enable and (lm_req64 # lm_req32))) and (park))
                                OR (MS_PARK and not ((gnt and (lm_req64 # lm_req32))) and not ((not gnt and (lm_req64 # lm_req32))) and not ((not gnt)));
                                
        MS_DXFR_d = (MS_ADR)
                                OR (MS_DXFR and not (mstr_done));
                                
        MS_TAR_d = (MS_DXFR and mstr_done);
-%


----------------------------------------------------------------

-- Notice that I made the transition from MS_PARK to include mstr_enable to reduce logic. This is 
-- Possible becuase it is not possible to change mstr_enable in the MS_PARK state except when using 
-- non-PCI cycles to modify configuration space.  If the system writes a 0 to mstr_enable bit using 
-- configuration cycles the state machine will go to MS_IDLE when grant goes off.
        
--      MS_IDLE_d               =       (MS_IDLE and not (mstr_enable and (lm_req64 or lm_req32) and MR_IDLE) and  not park )
--                                      OR      (MS_TAR)
--                                      OR      (MS_PARK and not ((lm_req64 or lm_req32) and MR_IDLE) and (not gnt));
                                
--  replaced l_req_vld with l_req_vld
--      l_req_vld               =       (mstr_enable and (lm_req64 or lm_req32) and MR_IDLE);
        
        MS_IDLE = not MS_IDLE_not;
        
        MS_IDLE_lc1             =       LCELL   (       MS_IDLE AND NOT l_req_vld AND NOT park 
                                                                OR      MS_TAR
                                                                );
        
        MS_IDLE_d               =       MS_IDLE_lc1
                                        OR      MS_PARK AND NOT l_req_vld AND NOT gnt;


-----------------------------------------------------------------                               
-- See notice in MS_IDLE_d Optimized Code
-- Carry chain is needed for lm_req64n and lm_req32n speed
--      MS_REQ_d                =       (MS_IDLE and l_req_vld)
--                                      OR      (MS_REQ and not park)
--                                      OR      (MS_ENA and not gnt)
--                                      OR      (MS_PARK and not gnt and l_req_vld);

        MS_REQ_d_lc1    =       (MS_REQ AND not park)
                                        OR      (MS_IDLE ANd l_req_vld);
                                        
        MS_REQ_d_lc2    =       (MS_ENA )
                                        OR      (MS_PARK and l_req_vld);
                                                                        
        MS_REQ_d                =       (MS_REQ_d_lc1)
                                        OR      (MS_REQ_d_lc2 AND not gnt);


                                

-----------------------------------------------------------------                               
-- See notice in MS_IDLE_d Optimized Code
                                
--      MS_ENA_d                =       (MS_REQ and park)
--                                      OR      (MS_PARK and  gnt and (lm_req64 or lm_req32) and MR_IDLE);

        MS_ENA_d_lc             = LCELL(MS_REQ and park);

        MS_ENA_d                =       MS_ENA_d_lc                                             -- Should be implemented in the same cell as Carry of MS_REQ_d
                                        OR      (MS_PARK AND gnt AND l_req_vld);

                                
-----------------------------------------------------------------                               
                                
        MS_ADR_d = (MS_ENA and gnt and no_op_reg4);

-----------------------------------------------------------------                               
                                
        MS_ADR2_d = (MS_ADR and dac_cyc);

        
-----------------------------------------------------------------       
--      MS_PARK_d       =       (MS_IDLE and not ( mstr_enable and (lm_req64 # lm_req32) and MR_IDLE ) and gnt)
--                              OR      (MS_PARK and not ( (lm_req64 # lm_req32) and MR_IDLE ) and gnt );
                                                
        
        MS_PARK_d       =       LCELL(MS_IDLE AND not l_req_vld AND park)
                                OR      MS_PARK AND not l_req_vld AND gnt;

                                
----------------------------------------------------------------
        -- Master Done
--      mstr_done               =  not frame_or and irdy_or and (trdy or stop or mstr_abrt);
--      mstr_done               =  (not frame_or and irdy_or and (trdy or stop)) 
--                                      or (not frame_or and irdy_or and mstr_abrt);


--      MS_DXFR_d = (MS_ADR)
--                              OR (MS_DXFR and not (mstr_done));
                                
--      MS_DXFR_d = (MS_ADR)
--                              OR (MS_DXFR and not ( (not frame_or and irdy_or and (trdy or stop))or (not frame_or and irdy_or and mstr_abrt));
                                
--      MS_DXFR_d = (MS_ADR)
--                              OR (MS_DXFR and not (not frame_or and irdy_or and (trdy or stop)) 
--                                                and not (not frame_or and irdy_or and mstr_abrt);
                                                  
--      MS_DXFR_d = (MS_ADR)
--                              OR (MS_DXFR and (frame_or or not irdy_or or not (trdy or stop)) 
--                                                and (frame_or or not irdy_or or not mstr_abrt));

ms_dxfr_lc1a    = LCELL ((MS_ADR and not dac_cyc) OR (MS_ADR2));


ms_dxfr_lc1b =  LCELL(MS_DXFR and frame_or and not irdy_or);

ms_dxfr_lc1c    =  LCELL(
                                                (MS_DXFR and frame_or and not mstr_abrt)
                                        OR (MS_DXFR and (not irdy_or) and (not mstr_abrt))
                                                );
ms_dxfr_lc1    =  LCELL(ms_dxfr_lc1a or ms_dxfr_lc1b    or ms_dxfr_lc1c);       

ms_dxfr_lc2    = LCELL(
                                                        (MS_DXFR and frame_or)                                    
                                                        OR (MS_DXFR and not irdy_or)                                              
                                                        OR (MS_DXFR and not mstr_abrt)
                                                );
IF(PCI_FAMILY_STRATIXII() or PCI_FAMILY_CYCLONE()) GENERATE
  MS_DXFR_trdy = LCELL(trdy);
  MS_DXFR_d = ms_dxfr_lc1 OR(ms_dxfr_lc2 and not MS_DXFR_trdy and not stop);
ELSE GENERATE
  MS_DXFR_d = ms_dxfr_lc1 OR(ms_dxfr_lc2 and not trdy and not stop);
END GENERATE;                                               
                                                
 
----------------------------------------------------------------                                
                                
--      MS_TAR_d = (MS_DXFR and mstr_done);


ms_tar_cascade  =LCELL( mstr_abrt or trdy);

MS_TAR_d = LCELL(MS_DXFR and not frame_or and irdy_or) and (ms_tar_cascade or stop );

        
        
---------- Master Write State Machine -----------------------------------------
MW_IDLE                         = not MW_IDLE_not;
MW_IDLE_not.clk         = clk;
MW_IDLE_not.clrn        = rstn;
MW_IDLE_not.d           = NOT MW_IDLE_d;
        
        

IF (VERSION_1_0_COMPATIBLE == "YES") GENERATE   
        MW_IDLE_d = (
                                                (MW_IDLE and not (LCELL(MS_ENA and low_lm_beni[0]) AND gnt))
                                                OR (MW_END)
                                        );
ELSE GENERATE
--      MW_IDLE_d       =       MW_IDLE AND NOT gnt 
--                              OR      MW_IDLE AND NOT high_lm_beni0 AND dac_cyc_reg_set 
--                              OR      MW_IDLE AND NOT low_lm_beni0 AND NOT dac_cyc_reg_set 
--                              OR      MW_IDLE AND NOT MS_ENA 
--                              OR      MW_END ;

                MW_IDLE_lc1_cascade             =       MW_IDLE and no_op_prst_reg;
                MW_IDLE_lc1             = LCELL (       (       NOT high_lm_beni0 AND dac_cyc_reg_set 
                                                                OR      NOT low_lm_beni0 AND NOT dac_cyc_reg_set 
                                                                OR      NOT MS_ENA
                                                                ) AND MW_IDLE_lc1_cascade
                                                        );
                                                        
        MW_IDLE_d       =       MW_IDLE and not gnt
                                OR      MW_IDLE_lc1
                                OR      MW_END;
END GENERATE;
-------------------------------------------------------------------------
                                
IF (VERSION_1_0_COMPATIBLE == "YES") GENERATE
        MW_LXFR_r1.clk = clk;
        MW_LXFR_r1.clrn = rstn;
        MW_LXFR_r1_d = (LCELL(
                                        (MW_IDLE and (MS_ENA and (low_lm_beni[0] )))
                                  )     AND gnt)                                
                                OR (LCELL(
                                                        (MW_LXFR and not (devsel_toR) and (lm_rdynR))
                                                ));--and not (stop));
        MW_LXFR_r1.d = MW_LXFR_r1_d;
        
        MW_LXFR_r2.clk          = clk;
        MW_LXFR_r2.clrn         = rstn; 
        
        MW_LXFR_r2_d_lc1        = LCELL(MW_DXFR and not devsel_toR and lm_rdynR);
        
                        MW_LXFR_r2_d            = MW_LXFR_r2_d_lc1 and not stop and trdy;
        MW_LXFR_r2.d            = MW_LXFR_r2_d;
        
        MW_LXFR_d                       = MW_LXFR_r1_d or MW_LXFR_r2_d; 
        MW_LXFR                         = LCELL(MW_LXFR_r1 or MW_LXFR_r2);


ELSE GENERATE   
                                         
                                        
-- MW_LXFR_d =                  MW_IDLE and MS_ENA and gnt and low_lm_beni[0] and not dac_cyc_reg_set 
--                        OR   MW_IDLE and MS_ENA and gnt and (high_lm_beni[0] and dac_cyc_reg_set )
--                        OR   MW_LXFR and not devsel_toR and lm_rdynR and !retry_det
--                        OR   MW_LXFR and direct_xfr and !retry_det and dac_cyc_strobe and !stop and not devsel_toR
--                        OR   MW_DXFR   and !stop and !devsel_toR and lm_rdynR and trdy;
   
 MW_LXFR_lc1 = MW_IDLE and no_op_reg1;
 
 MW_LXFR_lc2 = (MS_ENA  and low_lm_beni[0] and not dac_cyc_reg_set
                   OR MS_ENA  and high_lm_beni[0] and dac_cyc_reg_set) and MW_LXFR_lc1;
                   
 MW_LXFR_r1.d = MW_LXFR_lc2 and gnt;
 
 MW_LXFR_lc3 = MW_LXFR and not devsel_toR and lm_rdynR and !retry_det;
 MW_LXFR_lc4 = MW_LXFR and direct_xfr and !retry_det and dac_cyc_strobe;
 
 MW_LXFR_r2.d = MW_LXFR_lc3 or (MW_LXFR_lc4 and !stop and not devsel_toR);
 
 MW_LXFR_lc5 = MW_DXFR and !devsel_toR and lm_rdynR;
 
  IF(PCI_FAMILY_STRATIXII() or PCI_FAMILY_CYCLONE()) GENERATE
    MW_LXFR_trdy = LCELL(trdy);
    MW_LXFR_r3.d = MW_LXFR_lc5 and !stop and MW_LXFR_trdy;
  ELSE GENERATE
    MW_LXFR_r3.d = MW_LXFR_lc5 and !stop and trdy;
  END GENERATE;
  
  MW_LXFR_r[3..1].clk = clk;
  MW_LXFR_r[3..1].clrn = rstn;
  
  MW_LXFR = lcell( MW_LXFR_r1 or MW_LXFR_r2 OR MW_LXFR_r3);
END GENERATE;

---------------------------------------------------------------------------

                                                

--      MW_DXFR_d       =       MW_DXFR_32 AND NOT stop AND trdy AND lm_rdynR AND NOT last_xfr_lc1
--                              OR      MW_DXFR AND NOT stop AND trdy AND NOT lm_rdynR AND direct_xfr AND NOT last_xfr 
--                              OR      MW_WAIT AND NOT stop AND trdy AND direct_xfr AND NOT last_xfr AND NOT devsel_toR -- devsel_toR not needed
--       
--                              OR      MW_LXFR AND NOT lm_rdynR AND direct_xfr AND NOT last_xfr AND NOT devsel_toR AND NOT stop 
--                              OR      MW_LXFR AND ack64 AND NOT lm_rdynR and not direct_xfr AND NOT last_xfr AND NOT devsel_toR AND not Stop

 
--                              OR      MW_HOLD AND ack64 AND NOT stop AND NOT devsel_toR 
--      
--                              OR      MW_DXFR AND NOT stop AND NOT trdy AND lm_rdynR AND NOT last_xfr AND NOT devsel_toR;


MW_DXFR_r1.clk          = clk;
MW_DXFR_r1.clrn         = rstn;
MW_DXFR_r1.d            = MW_DXFR_r1_d;

MW_DXFR_lc1                     = LCELL (MW_DXFR_32 AND lm_dxfrn AND NOT last_xfr_lc1);

MW_DXFR_lc2                     =       LCELL   (       (       MW_DXFR AND NOT lm_rdynR AND direct_xfr)
                                                                OR      (MW_WAIT AND direct_xfr )
                                                                );

IF(PCI_FAMILY_STRATIXII() OR PCI_FAMILY_CYCLONE()) GENERATE
  IF(PCI_FAMILY_STRATIXII()) GENERATE
    MW_DXFR_r1_trdy         =        LCELL(trdy);
    MW_DXFR_r1_cascade      =        (MW_DXFR_r1_trdy AND NOT stop);
  ELSE GENERATE
    MW_DXFR_r1_trdy         =        LCELL(trdy);
    MW_DXFR_r1_cascade      =        LCELL(MW_DXFR_r1_trdy AND NOT stop);
  END GENERATE;
ELSE GENERATE
  MW_DXFR_r1_cascade      =        LCELL(trdy AND NOT stop);
END GENERATE;        

                                             
MW_DXFR_r1_d            =       (MW_DXFR_lc1
                        OR      MW_DXFR_lc2 AND NOT last_xfr
                                ) AND MW_DXFR_r1_cascade;

--MW_DXFR_lc3 = direct_xfr AND NOT last_xfr and not dac_cyc_strobe;
--MW_DXFR_r2.clk          = clk;
--MW_DXFR_r2.clrn         = rstn;
--MW_DXFR_r2.d            = MW_DXFR_r2_d;
--
--MW_DXFR_r2_cascade              =       MW_LXFR AND NOT devsel_toR AND NOT lm_rdynR;
--MW_DXFR_r2_d            =       ( MW_DXFR_lc3 OR ack64  AND NOT last_xfr
--                                                ) AND MW_DXFR_r2_cascade;

--MW_DXFR_lc3 			=  MW_LXFR AND NOT lm_rdynR AND NOT last_xfr AND NOT devsel_toR AND direct_xfr      AND NOT stop 
--                        OR MW_LXFR AND NOT lm_rdynR AND NOT last_xfr AND NOT devsel_toR AND NOT direct_xfr  AND ack64 AND not Stop;


MW_DXFR_lc3 			=  LCELL(MW_LXFR AND NOT lm_rdynR AND NOT last_xfr AND NOT devsel_toR);
MW_DXFR_r2.clk          = clk;
MW_DXFR_r2.clrn         = rstn;
MW_DXFR_r2.d            = MW_DXFR_r2_d;

MW_DXFR_r2_d            =   ( MW_DXFR_lc3 AND direct_xfr AND NOT stop)
						OR	( MW_DXFR_lc3 AND NOT direct_xfr AND ack64 AND not stop);

        
IF(PCI_32 == "NO") GENERATE
   MW_DXFR_r3.clk          = clk;
   MW_DXFR_r3.clrn         = rstn;
   MW_DXFR_r3.d            = MW_DXFR_r3_d;
   
   MW_DXFR_r3_d            =       MW_HOLD AND NOT devsel_toR AND ack64 AND NOT stop;
END GENERATE;
        
        
MW_DXFR_r4.clk          = clk;
MW_DXFR_r4.clrn         = rstn;
MW_DXFR_r4.d            = MW_DXFR_r4_d;

MW_DXFR_r4_cascade              =       NOT trdy AND NOT devsel_toR and no_op_reg[1] AND lm_rdynR;
MW_DXFR_r4_d                    =       (       MW_DXFR  AND NOT last_xfr AND NOT stop) 
                                                        AND MW_DXFR_r4_cascade;
        
IF(PCI_32 == "NO") GENERATE
  MW_DXFR                         =  LCELL        (       MW_DXFR_r1 OR MW_DXFR_r2 OR MW_DXFR_r3 OR MW_DXFR_r4 );
  MW_DXFR_d                       =  MW_DXFR_r1_d OR MW_DXFR_r2_d OR MW_DXFR_r3_d OR MW_DXFR_r4_d;
ELSE GENERATE
  MW_DXFR                         =  LCELL        (       MW_DXFR_r1 OR MW_DXFR_r2 OR MW_DXFR_r4 );
  MW_DXFR_d                       =  MW_DXFR_r1_d OR MW_DXFR_r2_d  OR MW_DXFR_r4_d;
END GENERATE;


------------------------------------------------------------------------        
                                                
--      MW_WAIT_d       =       MW_DXFR AND NOT stop AND NOT trdy AND direct_xfr AND last_xfr AND NOT devsel_toR 
--                              OR      MW_DXFR AND NOT stop AND NOT trdy AND NOT lm_rdynR AND direct_xfr AND NOT devsel_toR 
--                              OR      MW_DXFR_32 AND NOT stop AND NOT trdy AND NOT lm_rdynR 
--                              OR      MW_WAIT AND NOT stop AND NOT trdy AND NOT devsel_toR ;

MW_WAIT_lc1_cascade             =       MW_DXFR AND NOT devsel_toR;
MW_WAIT_lc1     =       LCELL   (       (       direct_xfr AND last_xfr
                                                                        OR      NOT lm_rdynR AND direct_xfr
                                                                        ) and MW_WAIT_lc1_cascade
                                                                );
        
MW_WAIT_lc2     =       LCELL   (       MW_DXFR_32 AND NOT lm_dxfrn 
                                                OR      MW_WAIT AND NOT devsel_toR 
                                                );
                                                
MW_WAIT.clk             = clk;
MW_WAIT.clrn    = rstn;
MW_WAIT                 = MW_WAIT_d;


MW_WAIT_cascade         =               NOT trdy and no_op_reg[1];                              
MW_WAIT_d               =       ((MW_WAIT_lc1 OR MW_WAIT_lc2 )AND NOT stop) AND MW_WAIT_cascade;

------------------------------------------------------------------------

-- The term for MW_LXFR was dropped becuase: devsel_toR and stop are mutually execlusive.
--	 If retry_det is on, stop will also be ON.  stop will not be asserted without devsel being asserted first. 
--      MW_LAST_d               =           MW_DXFR_32      AND NOT stop AND trdy AND last_xfr_lc1 
--										OR	MW_LXFR 		AND NOT lm_rdynR AND stop AND not devsel_toR  -- See Note Before
--                                      OR  MW_DXFR         AND NOT stop AND trdy AND NOT lm_rdynR AND direct_xfr AND last_xfr 
--                                      OR  MW_WAIT         AND NOT stop AND trdy AND direct_xfr AND last_xfr AND NOT devsel_toR -- devsel_toR not needed 
--                                      OR  MW_WAIT_32      AND NOT stop AND trdy and latcntr_toR
--                                      OR  MW_LXFR         AND NOT lm_rdynR AND direct_xfr AND last_xfr AND NOT devsel_toR 
--                                      OR  MW_LXFR         AND ack64 AND NOT direct_xfr AND NOT lm_rdynR AND last_xfr AND NOT devsel_toR
--                                      OR  MW_LAST         AND NOT stop AND NOT trdy and NOT devsel_toR;

        
MW_LAST_r1.clk  = clk;
MW_LAST_r1.clrn = rstn;
MW_LAST_r1.d    = MW_LAST_r1_d;

MW_LAST_lc1     =       LCELL   (       MW_DXFR_32 AND last_xfr_lc1
                                     OR MW_WAIT_32 AND latcntr_toR 
                                 );
MW_LAST_lc2     =       LCELL   (       MW_DXFR AND NOT lm_rdynR AND direct_xfr 
                                     OR MW_WAIT AND direct_xfr
                                 );

IF(PCI_FAMILY_STRATIXII() OR PCI_FAMILY_CYCLONE()) GENERATE
  IF(PCI_FAMILY_STRATIXII()) GENERATE
    MW_LAST_r1_trdy         = LCELL(trdy);
    MW_LAST_r1_cascade      = (MW_LAST_r1_trdy AND NOT stop);
  ELSE GENERATE
    MW_LAST_r1_trdy         = LCELL(trdy);
    MW_LAST_r1_cascade      = LCELL(MW_LAST_r1_trdy and no_op_reg[2] AND NOT stop);
  END GENERATE;
ELSE GENERATE
  MW_LAST_r1_cascade      = LCELL(trdy and no_op_reg[2] AND NOT stop);
END GENERATE;


MW_LAST_r1_d            =       (       MW_LAST_lc1  
                                OR      MW_LAST_lc2 AND last_xfr
                                 ) AND MW_LAST_r1_cascade; 
                                        
--- Harry                                       
MW_LAST_r2.clk  = clk;
MW_LAST_r2.clrn = rstn;
MW_LAST_r2.d    = MW_LAST_r2_d;

MW_LAST_lc3     = LCELL (MW_LXFR AND NOT lm_rdynR AND NOT devsel_toR AND last_xfr);

MW_LAST_r2_d    =       MW_LAST_lc3 AND direct_xfr  and not dac_cyc_strobe
                     OR MW_LAST_lc3 AND NOT direct_xfr AND ack64;
                                        
MW_LAST_r3.clk  = clk;
MW_LAST_r3.clrn = rstn;
MW_LAST_r3.d    = MW_LAST_r3_d;

MW_LAST_r3_cascade = NOT trdy and no_op_reg[2];
MW_LAST_r3_d       = MW_LAST AND NOT stop AND NOT devsel_toR AND MW_LAST_r3_cascade;

MW_LAST_r4.clk		= clk;
MW_LAST_r4.clrn		= rstn;
MW_LAST_r4.d		= MW_LXFR AND NOT lm_rdynR AND stop;

MW_LAST_d = MW_LAST_r1_d  OR MW_LAST_r2_d OR MW_LAST_r3_d;
MW_LAST   = LCELL( MW_LAST_r1 OR  MW_LAST_r2 OR   MW_LAST_r3 OR	MW_LAST_r4);
  
  ------------------------------------------------------------------------        
                                                        
MW_HOLD_reg1.clk  = clk;
MW_HOLD_reg1.clrn = rstn;
MW_HOLD_reg1.d    = MW_HOLD_d1;

MW_HOLD_reg2.clk  = clk;
MW_HOLD_reg2.clrn = rstn;
MW_HOLD_reg2.d    = MW_HOLD_d2;

MW_HOLD_lc1 = LCELL(MW_LXFR and  not devsel_tor and  !lm_rdynR  and !direct_xfr);
MW_HOLD_lc2 = LCELL(MW_LXFR and  not devsel_tor and retry_det);
MW_HOLD_d1 = (MW_HOLD_lc1 and not devsel) or MW_HOLD_lc2;


MW_HOLD_lc3     = LCELL (MW_HOLD AND NOT devsel_toR);

MW_HOLD_d2 = MW_HOLD_lc3 and not devsel and not stop;

MW_HOLD =   MW_HOLD_reg1 or MW_HOLD_reg2;                                                      
                                                                    
-------------------------------------------------------------------------
                                
--      MW_DXFR_32_d    =       MW_WAIT_32      AND NOT stop AND trdy AND NOT latcntr_toR 
--                                      OR      MW_DXFR         AND NOT stop AND trdy AND NOT lm_rdynR AND NOT direct_xfr 
--                                      
--                                      OR      MW_LXFR         AND devsel AND NOT ack64 AND NOT lm_rdynR AND NOT direct_xfr AND (NOT devsel_toR %-Note1-%) AND not Stop
--                                      OR      MW_HOLD         AND devsel AND NOT ack64 AND NOT stop AND NOT devsel_toR 
--                                      
--                                      OR      MW_DXFR_32      AND NOT stop AND NOT trdy AND lm_rdynR ;
--                              
        
-- Note1 : Removed devsel_toR because it is mutually execlusive with devsel.
        
MW_DXFR_32_r1.clk       = clk;
MW_DXFR_32_r1.clrn      = rstn;
MW_DXFR_32_r1.d         = MW_DXFR_32_r1_d;


MW_DXFR_32_lc1          =       LCELL   (       MW_DXFR AND NOT lm_rdynR AND NOT direct_xfr);

IF (PCI_FAMILY_STRATIXII() OR PCI_FAMILY_CYCLONE()) GENERATE	
  IF(PCI_FAMILY_STRATIXII()) GENERATE
    MW_DXFR_32_r1_trdy      =       LCELL(trdy);
    MW_DXFR_32_r1_cascade   =       (MW_DXFR_32_r1_trdy AND NOT stop);
  ELSE GENERATE
    MW_DXFR_32_r1_trdy      =       LCELL(trdy);
    MW_DXFR_32_r1_cascade   =       LCELL(MW_DXFR_32_r1_trdy and no_op_reg[2] and no_op_reg[1] AND NOT stop);
  END GENERATE;
ELSE GENERATE
  MW_DXFR_32_r1_cascade   =       LCELL(trdy and no_op_reg[2] and no_op_reg[1] AND NOT stop);
END GENERATE;




MW_DXFR_32_r1_d         =       (       MW_WAIT_32 AND NOT latcntr_toR
                                                        OR      MW_DXFR_32_lc1
                                                        ) AND MW_DXFR_32_r1_cascade;
MW_DXFR_32_r2.clk       = clk;
MW_DXFR_32_r2.clrn      = rstn;
MW_DXFR_32_r2.d         = MW_DXFR_32_r2_d;


MW_DXFR_32_lc2          =       LCELL( MW_LXFR AND NOT lm_rdynR AND NOT direct_xfr);
MW_DXFR_32_lc3      =  LCELL(MW_HOLD     AND NOT devsel_toR);

IF (PCI_FAMILY_STRATIXII()) GENERATE	  
  mw_dxfr_32_r2_lc1     = ( (MW_DXFR_32_lc2 OR MW_DXFR_32_lc3) AND  NOT stop);
ELSE GENERATE
  mw_dxfr_32_r2_lc1     = LCELL(  (MW_DXFR_32_lc2  OR MW_DXFR_32_lc3) AND  NOT stop);
END GENERATE;


MW_DXFR_32_r2_d               =       mw_dxfr_32_r2_lc1 AND  (devsel AND NOT ack64);

MW_DXFR_32_r3.clk       = clk;
MW_DXFR_32_r3.clrn      = rstn;
MW_DXFR_32_r3.d         = MW_DXFR_32_r3_d;


MW_DXFR_32_r3_cascade   =       NOT trdy and no_op_reg[3] and no_op_reg[1];
MW_DXFR_32_r3_d         = MW_DXFR_32    AND NOT stop  AND lm_dxfrn AND MW_DXFR_32_r3_cascade;


MW_DXFR_32_d            = MW_DXFR_32_r1_d OR MW_DXFR_32_r2_d OR MW_DXFR_32_r3_d;
MW_DXFR_32                      = LCELL (       MW_DXFR_32_r1 OR MW_DXFR_32_r2 OR MW_DXFR_32_r3);
---------------------------------------------------------------------------
                                                
--      MW_WAIT_32_d    =       MW_DXFR_32      AND NOT stop AND trdy AND NOT lm_rdynR AND NOT last_xfr_lc1 
--                                      OR      MW_WAIT         AND NOT stop AND trdy AND NOT direct_xfr AND NOT devsel_toR -- devsel_toR not needed 
--                                      OR      MW_DXFR         AND NOT stop AND NOT trdy AND NOT direct_xfr AND last_xfr AND NOT devsel_toR 
--                                      OR      MW_DXFR         AND NOT stop AND NOT trdy AND NOT lm_rdynR AND NOT direct_xfr AND devsel_toR
--                                      OR      MW_WAIT_32      AND NOT stop AND NOT trdy ;

MW_WAIT_32_r1.clk       = clk;
MW_WAIT_32_r1.clrn      = rstn;
MW_WAIT_32_r1.d         = MW_WAIT_32_r1_d;

MW_WAIT_32_lc1          =       LCELL(MW_DXFR_32 AND NOT lm_dxfrn AND NOT last_xfr_lc1);

IF(PCI_FAMILY_STRATIXII() OR PCI_FAMILY_CYCLONE()) GENERATE
  MW_WAIT_32_r1_trdy      =       LCELL(trdy);
  MW_WAIT_32_r2_trdy      =       LCELL(trdy);
  IF(PCI_FAMILY_STRATIXII()) GENERATE
    MW_WAIT_32_r1_cascade   =       (MW_WAIT_32_r1_trdy AND NOT stop);
    MW_WAIT_32_r2_cascade   =       ( NOT MW_WAIT_32_r2_trdy AND NOT devsel_toR AND NOT stop);
  ELSE GENERATE
    MW_WAIT_32_r1_cascade   =       LCELL(MW_WAIT_32_r1_trdy and no_op_reg[1] AND NOT stop);
    MW_WAIT_32_r2_cascade   =       LCELL( NOT MW_WAIT_32_r2_trdy AND NOT devsel_toR AND NOT stop);
  END GENERATE;
ELSE GENERATE
  MW_WAIT_32_r1_cascade   =       LCELL(trdy and no_op_reg[1] AND NOT stop);
  MW_WAIT_32_r2_cascade   =      LCELL( NOT trdy AND NOT devsel_toR AND NOT stop);
END GENERATE;



MW_WAIT_32_r1_d         =       (       MW_WAIT_32_lc1 
                                                OR      MW_WAIT AND NOT direct_xfr
                                                )       AND MW_WAIT_32_r1_cascade;
MW_WAIT_32_r2.clk       = clk;
MW_WAIT_32_r2.clrn      = rstn;
MW_WAIT_32_r2.d         = MW_WAIT_32_r2_d;

MW_WAIT_32_lc2          =       LCELL   (       MW_DXFR  AND NOT lm_rdynR AND NOT direct_xfr 
                                                                OR      MW_WAIT_32 
                                                                );

MW_WAIT_32_lc3          =       LCELL   (       MW_DXFR AND NOT direct_xfr );

                                                                
MW_WAIT_32_r2_d         =       (       MW_WAIT_32_lc3  AND last_xfr 
                                                        OR      MW_WAIT_32_lc2  
                                                ) AND MW_WAIT_32_r2_cascade;

MW_WAIT_32_d            = MW_WAIT_32_r1_d OR MW_WAIT_32_r2_d;

MW_WAIT_32                      = MW_WAIT_32_r1 OR MW_WAIT_32_r2;
                                             
                                
--------------------------------------------------                              

--      MW_END_d        =       MW_HOLD AND devsel_toR 
--                              OR      MW_LXFR AND devsel_toR 
--                              OR      MW_LAST AND trdy 
--                              OR      MW_LAST AND stop 
--                              OR      MW_HOLD AND stop 
--                              OR      MW_WAIT_32 AND stop 
--                              OR      MW_DXFR_32 AND stop 
--                              OR      MW_WAIT AND stop 
--                              OR      MW_DXFR AND stop 
----                            OR      MW_LXFR AND stop ;
--
--      MW_END_d        =       MW_HOLD AND devsel_toR 
--                              OR      MW_LXFR AND devsel_toR
--                              OR      MW_LAST AND devsel_toR
--                              OR      MW_DXFR AND devsel_toR
--                              OR      MW_WAIT AND devsel_toR 
--                              
--                              OR      MW_LAST AND trdy 
--                              OR      NOT (MW_IDLE OR MW_LXFR) AND stop;
                                
                                
MW_END_r1.clk   = clk;
MW_END_r1.clrn  = rstn;
MW_END_r1.d             = MW_END_r1_d;

MW_END_lc1              =       LCELL   (       MW_LAST 
                                                        OR      MW_DXFR
                                                        OR      MW_WAIT 
                                                        );
MW_END_r1_cascade       = LCELL(MW_HOLD AND devsel_toR
                                OR      MW_END_lc1      AND devsel_toR );


IF(PCI_FAMILY_STRATIXII() or PCI_FAMILY_CYCLONE()) GENERATE
  MW_END_r1_trdy          = LCELL(trdy);
  MW_END_r1_d             =       MW_END_r1_cascade
                                OR      (MW_LAST AND MW_END_r1_trdy);
ELSE GENERATE
  MW_END_r1_d             =       MW_END_r1_cascade
                                OR      (MW_LAST AND trdy);
END GENERATE;


                                
MW_END_r2.clk   = clk;
MW_END_r2.clrn  = rstn;
MW_END_r2.d             = MW_END_r2_d;

MW_END_r2_d             =       MW_LXFR AND devsel_toR 
                                OR      NOT (MW_IDLE OR MW_LXFR) AND stop;


MW_END_d = MW_END_r1_d or MW_END_r2_d;

MW_END = LCELL(MW_END_r1 or MW_END_r2);                                                                         
                                                                                


----------- Master Read State Machine -----------------------------------------


MR_IDLE_not.clk         = clk;
MR_DXFR.clk             = clk;
MR_LWAIT.clk            = clk;
MR_END.clk              = clk;


MR_IDLE_not.clrn        = rstn;
MR_DXFR.clrn            = rstn;
MR_LWAIT.clrn           = rstn;
MR_END.clrn             = rstn;

MR_IDLE_not.d                   = not   MR_IDLE_d;
MR_DXFR.d                       = MR_DXFR_d;
MR_LWAIT.d                      = MR_LWAIT_d;
MR_END.d                        = MR_END_d;
                                                        

        MR_IDLE = not MR_IDLE_not;

--      MR_IDLE_d = (MR_IDLE and  ((not MS_ADR or wr_rdn or last_xfr or dac_cyc) and (not MS_ADR2 or wr_rdn or last_xfr or not dac_cyc)) 
--                                               and ((not MS_ADR or wr_rdn or not last_xfr) and (not MS_ADR2 or wr_rdn or not last_xfr or not dac_cyc)))
--      
--      MR_IDLE_d = (MR_IDLE and not ((MS_ADR and NOT wr_rdn and not last_xfr and not dac_cyc) or (MS_ADR2 and NOT wr_rdn and not last_xfr and dac_cyc) ) 
--                                               and not ((MS_ADR and not wr_rdn and last_xfr) or (MS_ADR2 and not wr_rdn and last_xfr and dac_cyc)))
--                              OR (MR_END);

        
MR_IDLE_lc1     =       (MS_ADR and NOT wr_rdn and not dac_cyc)
                        OR      (MS_ADR2 and NOT wr_rdn and dac_cyc);

MR_IDLE_d       =       (MR_IDLE and NOT MR_IDLE_lc1)
                                OR      (MR_END);
--------------------------------------------------------------------------------------
                                                                
--      MR_PXFR_d =     (MR_IDLE and (MS_ADR and NOT wr_rdn and not last_xfr and not dac_cyc))
--                              OR      (MR_IDLE AND (MS_ADR2 AND NOT wr_rdn AND NOT last_xfr AND dac_cyc))
--                              OR      (MR_PXFR and (not (devsel_toR) or (trdy or not stop)) and (not trdy and not stop))
--                              OR      (MR_DXFR and (trdy or not stop) and (not trdy and not stop) )
--                              OR      (MR_LWAIT and not (lm_rdyn) and  (not last_xfr and not stop));
                                
--      MR_PXFR_d =     (       NOT last_xfr AND        (       (MR_IDLE and MS_ADR and NOT wr_rdn and not dac_cyc)
--                                                                                      OR      (MR_IDLE AND MS_ADR2 AND NOT wr_rdn AND dac_cyc)
--                                                                                      )
--                                      ) 
--                              OR      (       MR_PXFR AND not devsel_toR AND not trdy and not stop)
--                              OR      (       MR_DXFR and not trdy and not stop) 
--                              OR      (       MR_LWAIT and not lm_rdyn and not last_xfr and not stop));
                                
                                
MR_PXFR_r1.clk = clk;
MR_PXFR_r1.clrn = rstn;
MR_PXFR_lc1             = LCELL (       (MR_IDLE and MS_ADR  and NOT wr_rdn  and not dac_cyc)
                                                OR      (MR_IDLE AND MS_ADR2 AND NOT wr_rdn  AND dac_cyc)
                                                );      
MR_PXFR_lc2     = LCELL((MR_LWAIT and not lm_rdyn and not last_xfr));

MR_PXFR_r1_d    = not last_xfr and MR_PXFR_lc1
                                        OR (MR_PXFR_lc2 and not stop);


MR_PXFR_r1.d = MR_PXFR_r1_d;                    
                        
MR_PXFR_r2.clk = clk;
MR_PXFR_r2.clrn = rstn; 

MR_PXFR_r2_cascade      = LCELL(not stop and not trdy);

MR_PXFR_r2_d = (
                                         ((MR_PXFR and not devsel_toR) or MR_DXFR)
                                    )  and MR_PXFR_r2_cascade;

MR_PXFR_r2.d = MR_PXFR_r2_d;

MR_PXFR = LCELL(MR_PXFR_r1 or MR_PXFR_r2);

MR_PXFR_d = MR_PXFR_r1_d or MR_PXFR_r2_d;
                                
                                
---------------------------------------------------------------------------------------                         
                                                                
--      MR_DXFR_d       = ( MR_PXFR and not devsel_toR
--                                                      and not (not trdy and stop) 
--                                                      and not (not trdy and not stop)
--                                                      and not (stop and lm_rdyn and trdy) 
--                                                      and not (not stop and lm_rdyn and trdy) 
--                                                      and (not last_xfr and not stop and not lm_rdyn and trdy)
--                                      )                                               
--                              OR ( MR_DXFR    and not ( not trdy and stop) 
--                                                              and not ( not trdy and not stop) 
--                                                              and not ( lm_rdyn and trdy and stop) 
--                                                              and not ( lm_rdyn and trdy and not stop) 
--                                                              and not ( not last_xfr and not lm_rdyn and trdy and not stop)
--                                      ) ;


MR_DXFR_d_lc1   = LCELL (       MR_PXFR AND not devsel_toR
                                                OR      MR_DXFR
                                                )       ;                                 


IF(PCI_FAMILY_STRATIXII() or PCI_FAMILY_CYCLONE()) GENERATE
  MR_DXFR_trdy = LCELL(trdy);     
  MR_DXFR_d =   (not stop and  MR_DXFR_trdy and  not lm_rdyn and MR_DXFR_cascade);
ELSE GENERATE
  MR_DXFR_d =   not stop and  trdy and  not lm_rdyn and MR_DXFR_cascade;
END GENERATE; 

  
MR_DXFR_cascade = LCELL(not last_xfr and MR_DXFR_d_lc1);
                                          
                                
---------------------------------------------------------------------------------------
                                
--      MR_LPXFR_d      =       (MR_IDLE and (MS_ADR and NOT wr_rdn and last_xfr and not dac_cyc)
--                              OR      (MR_IDLE and (MS_ADR2 and not wr_rdn and last_xfr and dac_cyc)
--                              OR      (MR_PXFR and (last_xfr and not stop and not lm_rdyn and trdy)
--                                                and not devsel_toR
--                                      )
--                              OR (MR_DXFR and (last_xfr and not lm_rdyn and trdy and not stop)
--                                 ) 
--                              OR (MR_LPXFR and not devsel_toR and not trdy and not stop)
--                              OR (MR_LWAIT and not lm_rdyn and not (not last_xfr and not stop)
--                                      );
        
        
--      MR_LPXFR_d =    last_xfr and    (       MR_IDLE and MS_ADR and NOT wr_rdn and not dac_cyc)
--                                                                      OR      MR_IDLE and MS_ADR2 and not wr_rdn and dac_cyc)
--                                                                      )
--                              OR (MR_PXFR and not devsel_toR and last_xfr  and not lm_rdyn and trdy and not stop)
--                              OR (MR_DXFR and last_xfr and not lm_rdyn and trdy and not stop)
--                              OR (MR_LPXFR and not devsel_toR and not trdy and not stop) 
--                              OR (MR_LWAIT and not lm_rdyn and not ( not last_xfr and not stop));


MR_LPXFR_r1.clk = clk;
MR_LPXFR_r1.clrn = rstn;
MR_LPXFR_lc1_cascade    =       MS_ADR  and not         dac_cyc
                                                OR      MS_ADR2 and             dac_cyc;
MR_LPXFR_lc1            = last_xfr and MR_IDLE and NOT  wr_rdn and MR_LPXFR_lc1_cascade;


MR_LPXFR_lc2            = (MR_LPXFR  and not devsel_toR);

IF(PCI_FAMILY_STRATIXII() or PCI_FAMILY_CYCLONE()) GENERATE
  MR_LPXFR_r1_trdy = LCELL(trdy);
  MR_LPXFR_r1_d = (MR_LPXFR_lc1) OR (MR_LPXFR_lc2 and not MR_LPXFR_r1_trdy and not stop);
ELSE GENERATE
  MR_LPXFR_r1_d = (MR_LPXFR_lc1) OR (MR_LPXFR_lc2 and not trdy and not stop);
END GENERATE;
                                     
MR_LPXFR_r1.d           =       MR_LPXFR_r1_d;


MR_LPXFR_r2_d_lc1       = LCELL (  (MR_PXFR and not devsel_toR)
                                                        OR (MR_DXFR )
                                                        );

IF (PCI_FAMILY_STRATIXII()) GENERATE	  
  MR_LPXFR_r2_lc1 = (not stop and not lm_rdyn);
ELSE GENERATE
  MR_LPXFR_r2_lc1 = LCELL(not stop and not lm_rdyn);
END GENERATE;

IF(PCI_FAMILY_STRATIXII() or PCI_FAMILY_CYCLONE()) GENERATE
  MR_LPXFR_r2_trdy = LCELL(trdy);
  MR_LPXFR_r2_d   =  MR_LPXFR_r2_d_lc1 and last_xfr and MR_LPXFR_r2_trdy and MR_LPXFR_r2_lc1 ;
ELSE GENERATE
  MR_LPXFR_r2_d   =  MR_LPXFR_r2_d_lc1 and last_xfr and trdy and MR_LPXFR_r2_lc1 ;
END GENERATE;



MR_LPXFR_r2.clk         = clk;
MR_LPXFR_r2.clrn        = rstn;
MR_LPXFR_r2.d           = MR_LPXFR_r2_d;


MR_LPXFR_r3.clk = clk;
MR_LPXFR_r3.clrn = rstn;


MR_LPXFR_r3_d = ( (MR_LWAIT and not lm_rdyn) and not  (not last_xfr and not stop));
        

MR_LPXFR_r3.d = MR_LPXFR_r3_d;

MR_LPXFR_d = MR_LPXFR_r1_d or MR_LPXFR_r2_d or MR_LPXFR_r3_d;

MR_LPXFR = LCELL(MR_LPXFR_r1 or MR_LPXFR_r2 or MR_LPXFR_r3);



                
                
---------------------------------------------------------------------------------------         

                
MR_LWAIT_lc1 = LCELL(   (MR_PXFR and lm_rdyn and not devsel_toR) 
                                                        OR (MR_DXFR and lm_rdyn));
MR_LWAIT_lc2 = (LCELL(
                                                (MR_LWAIT and lm_rdyn)
                                        ));

IF(PCI_FAMILY_STRATIXII() or PCI_FAMILY_CYCLONE()) GENERATE
  MR_LWAIT_trdy   = LCELL(trdy);
  MR_LWAIT_d      =        MR_LWAIT_lc2 OR ( MR_LWAIT_lc1 and not stop and MR_LWAIT_trdy) ;
ELSE GENERATE
  MR_LWAIT_d      =        MR_LWAIT_lc2 OR ( MR_LWAIT_lc1 and not stop and trdy) ;
END GENERATE;
 -------------------------------------------------------------------------------------                          
        
 
                
MR_LLWAIT_r1.clk        = clk;
MR_LLWAIT_r1.clrn       = rstn;
MR_LLWAIT_r1_lc1        = LCELL(        (MR_PXFR and lm_rdyn and not devsel_toR)
                                                                        OR (MR_DXFR and lm_rdyn));
MR_LLWAIT_r1_lc2        = LCELL((MR_LLWAIT and lm_rdyn));

IF(PCI_FAMILY_STRATIXII() or PCI_FAMILY_CYCLONE()) GENERATE
  MR_LLWAIT_r1_trdy      = LCELL(trdy);
  MR_LLWAIT_r1_d          = MR_LLWAIT_r1_lc2 OR (MR_LLWAIT_r1_lc1  and stop and MR_LLWAIT_r1_trdy);
ELSE GENERATE
  MR_LLWAIT_r1_d          = MR_LLWAIT_r1_lc2 OR (MR_LLWAIT_r1_lc1  and stop and trdy);
END GENERATE;
  
MR_LLWAIT_r1.d          = MR_LLWAIT_r1_d;
                                
MR_LLWAIT_r2.clk = clk;
MR_LLWAIT_r2.clrn = rstn;
                MR_LLWAIT_r2_cascade    =       not devsel_toR and trdy;
                MR_LLWAIT_r2_d = (MR_LPXFR and lm_rdyn and MR_LLWAIT_r2_cascade);
        

MR_LLWAIT_r2.d = MR_LLWAIT_r2_d;

MR_LLWAIT_d = MR_LLWAIT_r1_d or MR_LLWAIT_r2_d;

MR_LLWAIT = MR_LLWAIT_r1 or MR_LLWAIT_r2;
                
--------------------------------------------------------------------------------------
        
MR_LLXFR_r1.clk         = clk;
MR_LLXFR_r1.clrn        = rstn;
MR_LLXFR_r1_d_lc1       = LCELL((MR_PXFR and not lm_rdyn and not devsel_toR) 
                                                                OR (MR_DXFR and not lm_rdyn));
IF(PCI_FAMILY_STRATIXII() or PCI_FAMILY_CYCLONE()) GENERATE
  MR_LLXFR_r1_trdy = LCELL(trdy);
  MR_LLXFR_r1_d           = MR_LLXFR_r1_d_lc1 and stop and MR_LLXFR_r1_trdy;
ELSE GENERATE
  MR_LLXFR_r1_d           = MR_LLXFR_r1_d_lc1 and stop and trdy;
END GENERATE;

MR_LLXFR_r1.d           = MR_LLXFR_r1_d;

MR_LLXFR_r2.clk         = clk;
MR_LLXFR_r2.clrn        = rstn;
MR_LLXFR_r2_d_lc1       = LCELL(MR_LPXFR and not lm_rdyn and not devsel_toR);

IF(PCI_FAMILY_STRATIXII() or PCI_FAMILY_CYCLONE()) GENERATE
  MR_LLXFR_r2_trdy        = LCELL(trdy);
  MR_LLXFR_r2_d           = (MR_LLXFR_r2_d_lc1 and MR_LLXFR_r2_trdy)
                       OR (MR_LLWAIT and not lm_rdyn );
ELSE GENERATE
  MR_LLXFR_r2_d           = (MR_LLXFR_r2_d_lc1 and trdy)
                       OR (MR_LLWAIT and not lm_rdyn );
END GENERATE;

                       
MR_LLXFR_r2.d = MR_LLXFR_r2_d;

MR_LLXFR_d = MR_LLXFR_r1_d or MR_LLXFR_r2_d;

MR_LLXFR = MR_LLXFR_r1 or MR_LLXFR_r2;


--      MR_LLXFR_d = (MR_PXFR and (not (devsel_toR) or not (not trdy and stop)) and not (not trdy and not stop) and not (stop and lm_rdyn and trdy) and not (not stop and lm_rdyn and trdy)
--                                              and not (not last_xfr and not stop and not lm_rdyn and trdy) and not (last_xfr and not stop and not lm_rdyn and trdy))
--                              OR (MR_DXFR and not (not trdy and stop) and not (not trdy and not stop) and not (lm_rdyn and trdy and stop) and not ( lm_rdyn and trdy and not stop) 
--                                              and not ( not last_xfr and not lm_rdyn and trdy and not stop) and not ( last_xfr and not lm_rdyn and trdy and not stop) ) 
--                              OR (MR_LPXFR and (not (devsel_toR) or not (not trdy and stop)) and (not lm_rdyn and trdy))
--                              OR (MR_LLWAIT and not lm_rdyn);

                                
--------------------------------------------------------------------------------------
                                
MR_END_d_lc1    = LCELL((MR_PXFR and devsel_toR)
                                                        OR (MR_LPXFR and devsel_toR)
                                                        OR (MR_LLXFR));                 
MR_END_d_lc2    = LCELL(MR_PXFR OR MR_DXFR OR MR_LPXFR);
        
IF(PCI_FAMILY_STRATIXII() or PCI_FAMILY_CYCLONE()) GENERATE
  MR_END_trdy = LCELL(trdy);
  MR_END_d = MR_END_d_lc1 OR (MR_END_d_lc2 and  stop AND not MR_END_trdy);
ELSE GENERATE
  MR_END_d = MR_END_d_lc1 OR (MR_END_d_lc2 and  stop AND not trdy);
END GENERATE;
     

                                
%-      
        MR_END_d = (MR_PXFR and (devsel_toR or (not trdy and stop)))
                                OR (MR_DXFR and (not trdy and stop))                                    
                                OR (MR_LPXFR and (devsel_toR or (not trdy and stop)))
                                OR (MR_LLXFR);                          
-%
        
        
        
END GENERATE;


END;

