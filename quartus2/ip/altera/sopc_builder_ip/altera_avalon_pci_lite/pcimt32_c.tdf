-- File Name: config.tdf
-- Function :   This control the Configuration Access of the PCI/B MegaCore
-- Author : Ziad M. Abu-Lebdeh
-- Rev History
--  5/97  Initial Entry
--

-- ***********************************************************************************************
-- Function of the BAR values
--
-- The 32-Bit Hex number in the BAR sets options within the BAR.  Bits 31 downto 4 set the 
-- number of read/write bits instantiated.  It is illegal to have one or more 0's between
-- the 1's in these bits.  If a 0 is present the parameter will behave as if the 0 is a 1.
-- As per the PCI Specification, the number of read/write bits control the amount of address
-- space reserved by the BAR. The amount of space reserved by the BAR is 2^(Bar_read_only bits)
-- Bits 3 downto 0 control special options of the BAR. If bit 0 is a 0 then the Bar is memory
-- space and bits 1,2,3 have special meaning.  If bit 0 is a 1 the BAR is I/O Space.
-- For Memory Bar:  Bit 0 must be 0
--          Bit 1, 2 Define Memory Type
--            - 00 Bar is 32-Bit
--            - 10 Bar is 64-Bit
--            - 01, 11 are reserved and are illegal in this file
--
-- For I/O BAR:   Bit 0 must be a 1
--          Bit 1 is reserved and must be set to 0
--          Bits 2,3 are also reserved and must be set to 0 in this design.  Note
--            that this is in conflict with the PCI Bus which allows the user to reserve
--            a minimum of 4 bytes.  This design allows a minimum of 16 Bytes.
--
-- For 64-Bit Memory BAR:  Bits 2,1,0 = 100
--          Bar0 is the only BAR that can be set to 64-Bit BAR
--          When set to 64-Bit BAR, BAR0 and BAR1 are actually used
--          BAR1 will have Bits 31 downto 8 set to GND.  Bits 7 downto 0 can be configured
--          as read/write or read only similar to the method described above.  The maximum 
--          memory space that a 64-Bit Bar can reserve is 512 Gig Bytes
--
-- MicroMemory Modifications:  Allows 64-Bit BAR to use BAR1, and BAR2
--
-- Delphi Requested Modification:   Maximum Amount of memory reserved by 64-Bit BAR is 8 GigaGig Bytes
--                  (Tera Bytes); only one bit is decoded for 64-Bit BAR
--
-- Expansion ROM BAR Settings:
--    For Exp ROM Bar the same equations are used as Normal BAR.  However the settings and function
--    of the EXP ROM BAR are different.  
--    Bit 0 : Expansion ROM Enable.  This bit controls whether the device accepts accesses to
--          its expansion ROM space or not.  This bit is read/write.
--    Bit 10-1: Read Only bits and must return 0 when read
--    Bit 31-11 : Expansion ROM BAR area.  The maximum space an expansion ROM BAR can reserve is
--          16 Mbytes. 
--    Known Issue: If you set EXP_ROM_BAR to H"80000000" MP2 generates an error.  This was not
--          investigated further due to the fact that this value is illegal for EPX_ROM_BAR
--
--
--  Host Bridge Functionality:
--
--    The host bridge enable bit in the enable bits parameter is bit # 11.  When this bit is 
--    set the following settings take place:
--      - All bits in the command register are hardwired to 1.
--      - The local status register reset bus is activated.  Status register bits are reset by
--        asserting the appropriate bits on the lacal bus.
--      - Latency Timer is hardwired to the HARDWIRE_LAT_TMR parameter value.  the defalut for
--        this parameter is 20 Hex.
--            
-- ************************************************************************************************

-- Function Prototype of configuration space Decode
FUNCTION pcimt32_cd   ( clk, rstn, ena, adr[7..0])
    RETURNS     ( 
              selr[15..0]);

-- Function prototype for pcimt32_sr: pci_b set/reset flip flop with set dominant
FUNCTION pcimt32_sr ( s, r, clk, clrn, prn)
    RETURNS     ( q);
DEFINE PCI_FAMILY_STRATIXII()		= (((DEVICE_FAMILY == "STRATIX II" ) OR (DEVICE_FAMILY == "HardCopy II" ) ) ? 1 : 0);     
DEFINE PCI_FAMILY_CYCLONE()		= ((DEVICE_FAMILY == "CYCLONE")  ? 1 : 0);  
INCLUDE "maxplus2.inc";
--INCLUDE "pcimt32.inc";

PARAMETERS
(
  -- P2P bridge Parameters
  VERBOSE         = "NO",
  INTERNAL_ARBITER    = "NO",     -- Determines if REQ signal should have a tristate buffer or not.
  VERSION_1_0_COMPATIBLE  = "NO",
  MAX_64_BAR_RW_BITS  = 8,      -- Maximum Number of R/W Bits in BAR1 for 64-Bit BAR  
  DISCARD_TIMER   = "NO",   -- Instantiates Discard Timer Register
  SUBORDINATE_BUS   = "NO",   -- Instantiates Subordinate Bus Register
  PREFETCHABLE_MEMORY = "NO",   -- Instantiates Prefetchable Memory Base and Limit Registers
                    -- Also appropriately changes address decode logic
  IO_ADDR_32BIT   = "NO",     -- Instantiates Upper 16 bit Registers of the I/O base and Limit
  PRIMARY_INTERFACE = "YES",    -- P2P Bridge Primary Interface
  P2P_BRIDGE      = "NO",     -- P2P Bridge Interfaced Enabled
  P2P_ENABLE_BITS     = H"00000000",  -- These are Enable bits especially for the P2P Bridge
                      -- Functionality
  -- System Parameters
  PCI_32        = "YES",     -- 32-Bit PCI Support Only
  TARGET_ONLY     = "NO",     -- Target Only Function
  LOCAL_CONFIG_ENA  = "NO",     -- Local Configuration Enable
                    -- Enables Local side interface to write Configuration Space
  ENABLE_BITS     = H"00000000",  -- To enable features of the core.

  -- Configuration Space Paremeters
  PCI_66MHZ_CAPABLE = "YES",    -- Sets 66 MHz Capable bit in Status Register
  CAP_PTR       = H"40",
  CIS_PTR       = H"00000000",  -- CIS POINTER REGISTER VALUE
  EXP_ROM_BAR     = H"FFF00000",  -- EXpansion ROM Base Address Register
  INTERRUPT_PIN_REG = H"01",    -- To enable the interrupt pin register in the configuration space
  VENDOR_ID     = H"1172",    -- Vendor ID Register
  DEVICE_ID     = H"0002",    -- Device ID Register
  REVISION_ID     = H"01",    -- Revision ID Register
  CLASS_CODE      = H"FF0000",  -- Class Code Register
  SUBSYSTEM_ID    = H"FF00",    -- Subsystem ID Register
  SUBSYSTEM_VENDOR_ID = H"FF00",    -- Subsystem Vendor ID Register
  MIN_GRANT     = H"00",    -- Minimum Grant Register
  MAX_LATENCY     = H"00",    -- Maximum Latency Register
  
       -- Values in BAR0                            
       --      Bit(0) = 0-Memory, 1-I/O Space           
       --      Bit(1) = Reserve for I/O Space           
       --      Bit(2,1) = Memory Type                   
       --      Bit(3)  = Prefetchable Memory Address    
       --      Bits(31..n) = 1 for number of decode bits

  BAR0          = H"FFF00000" ,
  BAR1          = H"FFF00000" ,
  BAR2          = H"FFF00000" ,
  BAR3          = H"FFF00000" ,
  BAR4          = H"FFF00000" ,
  BAR5          = H"FFF00000" ,
  
  HARDWIRE_BAR0     = H"F0000000",
  HARDWIRE_BAR1     = H"FF000000",
  HARDWIRE_BAR2     = H"FFF00000",
  HARDWIRE_BAR3     = H"FFFF0000",
  HARDWIRE_BAR4     = H"FFFFF000",
  HARDWIRE_BAR5     = H"FFFFFF00",
  HARDWIRE_EXP_ROM  = H"FFF00000",  -- Expansion ROM Power Up Value
  
  HARDWIRE_LAT_TMR  = H"20",
  HARDWIRE_CACHE_LINE = H"00",

  

  NUMBER_OF_BARS    = 1     , -- Number of Base Address Regisers to be used
  DATA_TIMEOUT      = 16      -- Load value for time counter on target
);

---- Define Statements for Read_only bits ---------------------------------------------------------
  
--  ***********************************************************************************************
--  rob : read Only bits.  calculates the number of readonly bits in a BAR.  Since MSB (bit 31 is
--    the sign bit in MP2 and Quartus pre 2000.09, We are using that bit to indicate overflow.
--    When only bit 31 is set to 1, there is a special calculation for the number of rob.
--  bar_rob: Uses rob if more than 1 bit is a read/write.  Else sets number of read only bits to 31
  define rob(bar)         = CEIL(LOG2(0-((bar & H"7FFFFFFC")-(2^31))));
  define bar_rob(bar_ovfl_n, bar) = bar_ovfl_n > 0 ? rob(bar): 31;

--  bar_rob_64 : Read Only Bits for 64-Bit BAR.
  define rob_64(bar) = CEIL(LOG2(0-((bar & H"7FFFFFFF")-(2^31)))) ;
  define bar_rob_64(bar_ovfl_n, BAR_MSB_IS_ZERO , bar) = (bar_ovfl_n > 0) ? rob_64(bar) : ((BAR_MSB_IS_ZERO == 1 ) ? 32 : 31) ;
  
  define bar_rw_64(bar_mem_loc, bar_read_only) = (bar_mem_loc == 2) ? (MAX_64_BAR_RW_BITS - bar_read_only) : 0;


---------------------------------------------------------------------------------------------------
  
---- calculate the number of Bits in BAR to be read only. -----------------------------------------
  
  
--  constant MAX_64_BAR_RW_BITS   = 8;                  -- Maximum Number of R/W Bits for 64-Bit BAR
  constant EXP_ROM_OVFL_N     = (EXP_ROM_BAR & H"7FFFF800");      -- Only Upper 21 bits are used
  constant EXP_ROM_READ_ONLY_BITS = bar_rob(EXP_ROM_OVFL_N,EXP_ROM_BAR);
  
  constant BAR0_TYPE        = (BAR0 & H"00000001");
  constant BAR0_OVFL_N      = (BAR0 & H"7FFFFFFc") ;        -- Checkes if BAR0 is H"800000x"
  constant BAR0_MEM_LOC     = (BAR0_TYPE == H"00000001")? (H"00000000"): (BAR0 & H"00000006") DIV 2;
  constant BAR0_READ_ONLY_BITS  = bar_rob(BAR0_OVFL_N, BAR0);
  constant BAR0_MSB_IS_ZERO   = ((BAR0 & H"FFFFFFF0") == 0) ? 1 : 0  ; -- Checkes if MSB of BAR0 is 0 or 1.  This is used for 64-Bit BAR only.
  constant BAR0_READ_ONLY_BITS_64 = bar_rob_64(BAR0_OVFL_N, BAR0_MSB_IS_ZERO, BAR0);
  constant BAR0_LS_NIBBLE     = (BAR0 & H"0000000F");
  constant BAR0_PREFETCH      = (BAR0 & H"00000008") DIV 8;

  
  constant BAR1_TYPE        = (BAR1 & H"00000001");
  constant BAR1_OVFL_N      = (BAR1 &  H"7FFFFFFC");        -- Checkes if BAR1 is H"800000x"  
  constant BAR1_MEM_LOC     = (BAR1_TYPE == H"00000001")? (H"00000000"): (BAR1 & H"00000006") DIV 2;
  constant BAR1_READ_ONLY_BITS  = bar_rob(BAR1_OVFL_N, BAR1);
  constant BAR1_MSB_IS_ZERO   = ((BAR1 & H"FFFFFFF0") == 0) ? 1 : 0  ; -- Checkes if MSB of BAR1 is 0 or 1.  This is used for 64-Bit BAR only.
  constant BAR1_READ_ONLY_BITS_64 = bar_rob_64(BAR1_OVFL_N, BAR1_MSB_IS_ZERO, BAR1);
  constant BAR1_READ_WRITE_BITS   = bar_rw_64(BAR0_MEM_LOC, BAR1_READ_ONLY_BITS_64);
  constant BAR1_LS_NIBBLE     = (BAR1 & H"0000000F");
  constant BAR1_PREFETCH      = (BAR1 & H"00000008") DIV 8;
  
  constant BAR2_TYPE        = (BAR2 & H"00000001");
  constant BAR2_OVFL_N      =  (BAR2 &  H"7FFFFFFC");       -- 1: Not over flow, 0: over flow
  constant BAR2_MEM_LOC     = (BAR2_TYPE == H"00000001")? (H"00000000"): (BAR2 & H"00000006") DIV 2;
  constant BAR2_READ_ONLY_BITS  = bar_rob(BAR2_OVFL_N, BAR2);
  constant BAR2_MSB_IS_ZERO   = ((BAR2 & H"FFFFFFF0") == 0) ? 1 : 0  ; -- Checkes if MSB of BAR2 is 0 or 1.  This is used for 64-Bit BAR only.
  constant BAR2_READ_ONLY_BITS_64 = bar_rob_64(BAR2_OVFL_N, BAR2_MSB_IS_ZERO, BAR2);
  constant BAR2_READ_WRITE_BITS   = bar_rw_64(BAR1_MEM_LOC, BAR2_READ_ONLY_BITS_64);
  constant BAR2_LS_NIBBLE     = (BAR2 & H"0000000F");
  constant BAR2_PREFETCH      = (BAR2 & H"00000008") DIV 8;

  constant BAR3_TYPE        = (BAR3 & H"00000001");
  constant BAR3_OVFL_N      =  (BAR3 &  H"7FFFFFFC");       -- 1: Not over flow, 0: over flow
  constant BAR3_READ_ONLY_BITS  = bar_rob(BAR3_OVFL_N, BAR3);
  constant BAR3_LS_NIBBLE     = (BAR3 & H"0000000F");
  constant BAR3_MEM_LOC     = (BAR3_TYPE == H"00000001")? (H"00000000"): (BAR3 & H"00000006") DIV 2;
  constant BAR3_PREFETCH      = (BAR3 & H"00000008") DIV 8;

  constant BAR4_TYPE        = (BAR4 & H"00000001");
  constant BAR4_OVFL_N      =  (BAR4 &  H"7FFFFFFC");       -- 1: Not over flow, 0: over flow
  constant BAR4_READ_ONLY_BITS  = bar_rob(BAR4_OVFL_N, BAR4);
  constant BAR4_LS_NIBBLE     = (BAR4 & H"0000000F");
  constant BAR4_MEM_LOC     = (BAR4_TYPE == H"00000001")? (H"00000000"): (BAR4 & H"00000006") DIV 2;
  constant BAR4_PREFETCH      = (BAR4 & H"00000008") DIV 8;

  constant BAR5_TYPE        = (BAR5 & H"00000001");
  constant BAR5_OVFL_N      =  (BAR5 &  H"7FFFFFFC");       -- 1: Not over flow, 0: over flow
  constant BAR5_READ_ONLY_BITS  = bar_rob(BAR5_OVFL_N, BAR5);
  constant BAR5_LS_NIBBLE     = (BAR5 & H"0000000F");
  constant BAR5_MEM_LOC     = (BAR5_TYPE == H"00000001")? (H"00000000"): (BAR5 & H"00000006") DIV 2;
  constant BAR5_PREFETCH      = (BAR5 & H"00000008") DIV 8;

  constant BAR_64BIT_ROB_BAR0   = BAR0_READ_ONLY_BITS + BAR1_READ_ONLY_BITS_64;  -- IF BAR1=H"FFFFFFFF" and BAR0=H"XXXXXXX4(C)"
  constant BAR_64BIT_ROB_BAR01  = BAR0_READ_ONLY_BITS_64 + BAR1_READ_ONLY_BITS;  -- IF BAR1=H"XXXXXXXX" and BAR0=H"00000004(C)"
  constant BAR0_READ_WRITE_BITS_64 = (BAR0_MEM_LOC < 2) ? 8 :(32 + MAX_64_BAR_RW_BITS) - (BAR0_READ_ONLY_BITS_64 + BAR1_READ_ONLY_BITS_64) ;
  constant BAR1_READ_WRITE_BITS_64 = (BAR1_MEM_LOC < 2) ? 8 :(32 + MAX_64_BAR_RW_BITS) - (BAR1_READ_ONLY_BITS_64 + BAR2_READ_ONLY_BITS_64) ;

--------------------------------------------------------------------------------------------------- 
  
---- Defining constant for the enable -------------------------------------------------------------


  CONSTANT HARDWIRE_BAR0_ENA    = (ENABLE_BITS & H"00000001");        -- 0
  CONSTANT HARDWIRE_BAR1_ENA    = (ENABLE_BITS & H"00000002") DIV 2;    -- 1
  CONSTANT HARDWIRE_BAR2_ENA    = (ENABLE_BITS & H"00000004") DIV 4;    -- 2
  CONSTANT HARDWIRE_BAR3_ENA    = (ENABLE_BITS & H"00000008") DIV 8;    -- 3
  CONSTANT HARDWIRE_BAR4_ENA    = (ENABLE_BITS & H"00000010") DIV 16;   -- 4
  CONSTANT HARDWIRE_BAR5_ENA    = (ENABLE_BITS & H"00000020") DIV 32;   -- 5
  CONSTANT HARDWIRE_EXP_ROM_ENA   = (ENABLE_BITS & H"00000040") DIV 64;   -- 6
  CONSTANT EXP_ROM_ENA      = (ENABLE_BITS & H"00000080") DIV 128;    -- 7
  CONSTANT CAP_LIST_ENA       = (ENABLE_BITS & H"00000100") DIV 256;    -- 8
  CONSTANT CIS_PTR_ENA      = (ENABLE_BITS & H"00000200") DIV 512;    -- 9
  CONSTANT INTERRUPT_ACK_ENA    = (ENABLE_BITS & H"00000400") DIV 1024;   -- 10 
  CONSTANT HARDWIRE_HB_ENA    = (ENABLE_BITS & H"00000800") DIV 2048;   -- 11 Hardwire Host Bridge Enable
  CONSTANT INTERNAL_ARBITER_ENA   = (ENABLE_BITS & H"00001000") DIV 4096;   -- 12 Determines if REQ signal should have a tristate buffer or not.
  Constant SCFG_HB_ENA      = (ENABLE_BITS & H"00002000") DIV 8192;   -- 13 Enable Host Bridge Capability and Self Configuration    
  CONSTANT LOC_HDAT_MUX_ENA   = (ENABLE_BITS & H"00004000") DIV 16384;  -- 14 Insert Local Muxes on High Data and Byte enable outputs for 32 Xfers  
  CONSTANT DISABLE_LAT_TMR    = (ENABLE_BITS & H"00008000") DIV 32768;  -- 15 Disable Latency Timer
  CONSTANT PCI_64BIT_SYSTEM     = (ENABLE_BITS & H"00010000") DIV 65536;  -- 16 Indicates whether this is a pure 64bit system or not


  -- ********************************************************************************************
  -- P2P Enable Bits
  --
  -- 0 Enable driving CBEN from local side during Master Burst write after 1st data phase 
  -- 1 Enable driving Par Par64 from local side for mstr writ and trgt read                 
  -- 2 Disable I/O accesses for P2P Bridge                                                
  -- 3 Enable Mem Base1, Mem Limit 1, Pref Mem Base 1, Pref Mem Limit 1                   
  -- 4 Enable Mem Base1, Mem Limit 2, Pref Mem Base 1, Pref Mem Limit 2                   
  -- 5 Enable Mem Base1, Mem Limit 3, Pref Mem Base 1, Pref Mem Limit 3                   
  -- ********************************************************************************************
  CONSTANT P2P_MW_CBEN_ENA    = (P2P_ENABLE_BITS & H"00000001") DIV H"00000001";  
  CONSTANT P2P_LPARI_ENA      = (P2P_ENABLE_BITS & H"00000002") DIV H"00000002";  
  CONSTANT P2P_IOACC_DIS      = (P2P_ENABLE_BITS & H"00000004") DIV H"00000004";  
  CONSTANT P2P_MBS_MLMT_1_ENA   = (P2P_ENABLE_BITS & H"00000008") DIV H"00000008";  
  CONSTANT P2P_MBS_MLMT_2_ENA   = (P2P_ENABLE_BITS & H"00000010") DIV H"00000010";  
  CONSTANT P2P_MBS_MLMT_3_ENA   = (P2P_ENABLE_BITS & H"00000020") DIV H"00000020";  
  
  
  
  
  CONSTANT BAR1_COMP_WIDTH = BAR0_MEM_LOC < 2 ? 32-BAR1_READ_ONLY_BITS : BAR1_READ_WRITE_BITS;
  CONSTANT BAR2_COMP_WIDTH = (BAR0_MEM_LOC < 2 AND BAR1_MEM_LOC ==2) ? BAR2_READ_WRITE_BITS : 32-BAR2_READ_ONLY_BITS;
  
  constant BAR0_RO_BITS_MAX = BAR0_READ_ONLY_BITS_64 < 32 ? BAR0_READ_ONLY_BITS-1 : BAR0_READ_ONLY_BITS_64-1;
  constant BAR1_REG_MAX = BAR0_MEM_LOC < 2 ? 31 : MAX_64_BAR_RW_BITS-1;
        constant BAR1_REG_MIN = BAR0_MEM_LOC < 2 ? BAR1_READ_ONLY_BITS : BAR1_READ_ONLY_BITS_64;
        constant BAR2_REG_MAX = (BAR0_MEM_LOC < 2 AND BAR1_MEM_LOC ==2) ?  MAX_64_BAR_RW_BITS-1 : 31;
        constant BAR2_REG_MIN = (BAR0_MEM_LOC < 2 AND BAR1_MEM_LOC ==2) ? BAR2_READ_ONLY_BITS_64 : BAR2_READ_ONLY_BITS;
        

---------------------------------------------------------------------------------------------------
SUBDESIGN 'pcimt32_c'
(

---- PCI Input Signals ----------------------------------------------------------------------------
  clk           : INPUT = GND;  -- PCI Clock
  rstn          : INPUT = VCC;  -- PCI Reset
  cben_IR[3..0]       : INPUT = GND;  -- Registered cben signals
  ad_IR[31..0]      : INPUT = GND;  -- Registered PCI Address/Data Bus
  ad_ir_addr[31..0]   : INPUT = GND;
  cben_ir_addr[3..0]    : INPUT = GND;  

  adr_phase       : INPUT = GND;  -- High One Clock after Address Phase
  dac_adr_phase_r     : INPUT = GND;  -- High 2 Clocks after Address Phase and DAC Command
  cfg_dat_vld       : INPUT = GND;  -- Write Data from ad_IR into corresponding register
  serr_det        : INPUT = GND;  -- Signaled SERR
  adr_dec_ena       : INPUT = GND;  -- Enable Address Decode valid During Address Phase

  discard_set       : INPUT = GND;

  tabrt_set       : INPUT;    -- Signaled Target Abort
  tabrt_rcvd_set      : INPUT;    -- Recieved Target Abort
  mabrt_set       : INPUT;    -- Recieved Master Abort
  bar_hit_rst       : INPUT;    -- Reset the bar Hit bit at end of PCI access
  perr_det_set      : INPUT;    -- Detected Parity Error
  perr_rep_set      : INPUT;    -- Data Parity Error Signaled
  lirqn             : INPUT = VCC;    -- setting the interrupt status

  l_stat_reg_rst[5..0]  : INPUT = GND;  -- Local Status Register Reset bits
                      -- 0 : reset bit 8 (Master Data Parity Error)
                      -- 1 : reset bit 11 (Signaled Target Abort)
                      -- 2 : reset bit 12 (Received Target Abort)
                      -- 3 : reset bit 13 (Received Master Abort)
                      -- 4 : reset bit 14 (Signaled System Error)
                      -- 5 : reset bit 15 ( Detected Parity Error)
  dac_cfg         : INPUT;    -- Current Xaction is DAC
--------------------------------------------------------------------------------------------------- 

---- Configuration Outputs ------------------------------------------------------------------------
  mem_bar_hit       : OUTPUT;   -- One Of Memory BAR has HIT
  -- Command Register Local Side Outputs
  io_ena          : OUTPUT;   -- I/O Space Enable
  mem_ena         : OUTPUT;   -- Memory Space Enable
  mstr_ena        : OUTPUT;   -- Bus Master Enable
  mwi_ena         : OUTPUT;   -- Memory Write and Invalidate Enable
  perr_ena        : OUTPUT;   -- Pariy Error Response Enable 
  serr_ena        : OUTPUT;   -- SERR Enable
  intr_disable     : OUTPUT;
  -- Status Register Local Side Outputs
  perr_rep        : OUTPUT;   -- Data Parity Error Signaled
  tabrt_sig       : OUTPUT;   -- Signaled Target Abort
  tabrt_rcvd      : OUTPUT;   -- Recieved Target Abort
  mabrt_rcvd      : OUTPUT;   -- Recieved Master Abort
  serr_sig        : OUTPUT;   -- Signaled SERR
  perr_det        : OUTPUT;   -- Detected Parity Error
  intr_stat       : OUTPUT;

  lat_dat[7..0]     : OUTPUT;   -- Latency Timer Register Data
  cache_dat[7..0]     : OUTPUT;   -- Cache Line Register Data
  base_hit[5..0]      : OUTPUT;   -- Base Address Register Comparison Outputs
  exp_rom_bar_hit     : OUTPUT;   -- Expansion ROM BAR hit

--------------------------------------------------------------------------------------------------- 

---- Local Side Configuration Space Support ------------------------------------------------------- 
  lcfg_adr[7..0]      : INPUT = GND;  -- Local Configuration Address
  lcfg_ben[3..0]      : INPUT = GND;  -- Local Configuration Byte enables
  lcfg_dat_in[31..0]    : INPUT = GND;  -- Local Configuration Data Input Bus
  lcfg_adr_vld      : INPUT = GND;  -- Local Configuration Address Valid
  lcfg_dat_vld      : INPUT = GND;  -- Local Configuration data Valid
  lcfg_dat_out[31..0]   : OUTPUT;   -- Local Configuration Data Output
---------------------------------------------------------------------------------------------------
  
---- P2P_BRIDGE -----------------------------------------------------------------------------------   
  Stat_set[15..0]     : INPUT = GND;  -- Status Register Set Bits
  sec_stat_set_in[15..0]  : INPUT = GND;  -- Secondary status Register Set Bits

  cfg_dat_in_a[207..0]  : INPUT = GND;  -- Configuration File Data Input
  cfg_dat_in_b[183..0]  : INPUT = GND;  -- Configuration File Data Input
  cfg_dat_in_c[191..0]  : INPUT = GND;    -- Configuration Data input for addresses 40h-  54h
  
  mem_adr_vld       : OUTPUT;   -- Xaction is in Memory Range
  prfch_mem_adr_vld   : OUTPUT;   -- Xaction is in Prefetchable Memory Range
  io_adr_vld        : OUTPUT;   -- Xaction is in I/O address range
  ad_dat_out[31..0]   : OUTPUT;   -- Read Configuration Data Output

  cfg_dat_out_a[207..0] : OUTPUT;   -- Configuration File Data Output used from Prim to Sec
  cfg_dat_out_b[183..0] : OUTPUT;   -- Configuration File Data Output used from Prim to Sec
  
  cfg_dat_out_c[191..0] : OUTPUT;   -- Configuration Data output for addresses 40h- 54h
---------------------------------------------------------------------------------------------------
  
)

VARIABLE

--===== TYPE 0 CONFIGURATION SPACE: P2P_BRIDGE == "NO" ============================================
  IF (P2P_BRIDGE == "NO") GENERATE
  -- Select Configuration register  --
    cfg_adr_selR[15..0]       : NODE;   -- Select Signals for the configuration space
    dev_vend_selR         : NODE; -- Device/Vendor ID Register Select       
    stat_cmd_selR         : NODE; -- Status/Command Register Select
    class_rev_selR          : NODE; -- Class Code/Revision ID Register Select
    bist_hdr_lat_cach_selR      : NODE; -- BIST/Header Type/Latency Timer/Cache Line Reg Sel
    subs_subsvend_selR        : NODE; -- Susystem ID/Subsystem Vendor ID Regsiter Select
    cap_ptr_selR          : NODE; -- Capabilities Pointer Register Select
    cis_ptr_selR          : NODE; -- Cis Pointer Register Select 
    exp_rom_selR          : NODE; -- expansion ROM BAR Select
  -- Configuration Register Clock Enable active during Config Write Cycle
    stat_cmd_ena[3..0]        : NODE; -- Status/Command Register Write Enable
    latency_cache_ena[1..0]     : NODE; -- BIST/Header Type/Latency Timer/Chache Line Register Write Enable
    int_ln_ena0           : NODE; -- Max Latency/Min Grant/Interrupt Pin/Interrupt Line  Write Enable
  -- Configuration Data REgister  
    cmd_reg[15..0]          : NODE; -- Command Register Data
    stat_reg[15..0]         : NODE; -- Status Register Data
  -- Configuration DATa
    dev_vend_dat[31..0]       : NODE; -- Device/Vendor ID Register Data
    stat_cmd_dat[31..0]       : NODE; -- Status/Command Register Data
    class_revision_dat[31..0]   : NODE; -- Class Code/Revision ID Register Data
    bist_hdr_ltncy_cach_dat[31..0]  : NODE; -- BIST/Header Type/Latency Timer/Chache Line Register Data
    subs_subsvend_dat[31..0]    : NODE; -- Susystem ID/Subsystem Vendor ID Regsiter Data
    cap_reg_dat[31..0]        : NODE; -- Capabilities List pointer
    exp_rom_dat[31..0]        : NODE; -- Expansion ROM BAR data
    cap_ptr_dat[7..0]         : NODE;
    cis_ptr_reg_dat[31..0]      : NODE;
    device_id_dat[15..0]      : NODE; -- Device ID Register Data
    device_vend_id_dat[15..0]   : NODE; -- Device Vendor ID Register Data
    class_dat[23..0]        : NODE; -- Class Code Register Data
    rev_id_dat[7..0]        : NODE; -- Revision ID Register Data
    subs_id_dat[15..0]      : NODE; -- Subsystem ID Register Data
    subs_vend_id_dat[15..0]: NODE; -- Subsystem Vendor ID Register Data
    max_lat_dat[7..0]      : NODE; -- Maximum Latency Register Data
    min_gnt_dat[7..0]      : NODE; -- Minimum Grant Register Data
  -- Reset signals for SRFF
    par_rep_rst            : NODE; -- Reset Signaled Parity Error (Bit 24 Status/Command Register)
    targ_abrt_rst          : NODE; -- Reset Signaled Target Abort (Bit 27 Status/Command Register)
    targ_abrt_rcvd_rst     : NODE; -- Reset Received Target Abort (Bit 28 Status/Command Register)
    mstr_abrt_rst          : NODE; -- Reset Recieved Master Abort (Bit 29 Status/Command Register)
    serr_rst               : NODE; -- Reset Signaled SERR (Bit 30 Status/Command Register)
    perr_det_rst           : NODE; -- Reset Detected Parity Error (Bit 31 Status/Command Register)
    lirq                   : NODE;
    lirq_reg               : NODE;
    lirq_fall              : NODE;
    lirq_rise              : NODE;
    intr_stat_set          : NODE;
    intr_stat_rst          : NODE;
      int_ack_hit_cc                  : LCELL;
          bar3_cc                         : LCELL;
          bar34_cc                        : LCELL;
          bar4_cc                         : LCELL;
          bar345_cc                       : LCELL;
          bar45_cc                        : LCELL;
    
     
    
    IF (TARGET_ONLY == "NO") GENERATE
      -- Latency Timer
      IF( HARDWIRE_HB_ENA == H"0") GENERATE       
        lat_tmr_reg[4..0]     : DFFE; -- Latency Timer Register Read/Write Bits
        lat_tmr[7..0]       : NODE; -- Latency Timer Regsiter Read Only Bits
        -- Cache Data
        cache_line[7..0]      : DFFE; -- Cache Line Register
      ELSE GENERATE
        lat_tmr[7..0]       : NODE; -- Latency Timer Regsiter Read Only Bits
        -- Cache Data
        cache_line[7..0]      : NODE; -- Cache Line Register
      END GENERATE;
      
    ELSE GENERATE
      -- Latency Timer
      --lat_tmr_reg[4..0]     : NODE; -- Latency Timer Register Read/Write Bits
      lat_tmr[7..0]       : NODE; -- Latency Timer Regsiter Read Only Bits
      -- Cache Data
      cache_line[7..0]      : NODE; -- Cache Line Register
    END GENERATE;
  
    -- Interrupt REgister
    
    lat_gnt_intpin_intln_dat[31..0] : NODE; -- Max Latency/Min Grant/Interrupt Pin/Interrupt Line Regsiter Data
    lat_gnt_intpin_intln_selR : NODE; -- Max Latency/Min Grant/Interrupt Pin/Interrupt Line Regsiter Select
    INTERRUPT_PIN_REG_node[7..0]: Node; 
    
    IF ( INTERRUPT_PIN_REG == H"01") GENERATE
      int_ln_reg[7..0]      : DFFE; -- Interrrupt Line Register
        
    ELSE GENERATE
      int_ln_reg[7..0]      : NODE; -- Interrrupt Line Register
        
    END GENERATE;   
  -- Interrupt Acknowledge Support
    int_ack_hit           : NODE; -- Indicates that there is a valid interrupt Acknowledge Cycle

  -- BAR SELECT/HIT
    bar_selR[5..0]    : NODE; -- Bar0 Register Select
    cyc_vld[5..0]     : LCELL;
  --  bar[5..0][31..0]  : NODE;   -- Data for all Base Address Registers
          bar_0[31..0]  : NODE;
          bar_1[31..0]  : NODE;
          bar_2[31..0]  : NODE;
          bar_3[31..0]  : NODE;
          bar_4[31..0]  : NODE;
          bar_5[31..0]  : NODE;
  
    bar_hit[5..0]   : NODE; -- Address = BAR Address
    bar_hitR[5..0]    : SRFF; -- Registered bar_hit
  --  bar_nibble[5..0][3..0]      : NODE; -- Bar Lease Significant Nibble
          bar_nibble0[3..0]     : NODE; -- Bar Lease Significant Nibble
          bar_nibble1[3..0]     : NODE; -- Bar Lease Significant Nibble
          bar_nibble2[3..0]     : NODE; -- Bar Lease Significant Nibble
          bar_nibble3[3..0]     : NODE; -- Bar Lease Significant Nibble
          bar_nibble4[3..0]     : NODE; -- Bar Lease Significant Nibble
          bar_nibble5[3..0]     : NODE; -- Bar Lease Significant Nibble
            
  -- MEMORY/IO ENABLE 
    mem_access_enable       : NODE;
    io_access_enable        : NODE;
    dac_cmd             : LCELL;
    mem_cyc             : LCELL;  -- Memory Cycle Indicator
    io_cyc              : LCELL;  -- I/O Cycle Indicator

    IF(P2P_BRIDGE == "NO") GENERATE
      mbar_hit          : NODE;
    END GENERATE;   -- end bridge
  -- Instantiate Configuration Address Decoder
    cfg_adr_dec           : pcimt32_cd ;    -- Config Address Space decoder
    cfg_adr_dec_tmp_node[5..0]    : NODE;  -- temporary holding nodes so the repeat clause below will work
  -- cONFIGURATION DATA OUTPUT
    config_data[31..0]        : NODE; -- Configuration Data Mux Output
    ad_dat_out[31..0]       : DFFE; -- AD Data Output Registers
  -- DAC
  -- NO OPERATION
    no_op[207..0]   : NODE; --
  END GENERATE; 
--==== END OF TYPE 0 CONFIGURATION SPACE: P2P_BRIDGE == "NO" ====================================== 

--==== BEGINNING OF TYPE 1 CONFIGURATION SPACE: P2P_BRIDGE == "YES" ===============================   
  IF (P2P_BRIDGE == "YES") GENERATE
  -- Internal Signals for cfg_dat_in --
    cfg_adr_selR[15..0]   : NODE;   -- Select Signals for the configuration space
    cmd_in[15..0]         : NODE; -- Command Register Input
    stat_in[15..0]          : NODE; -- Status Register Input
    cache_dat_in[7..0]        : NODE; -- Cache Line Size Input
    prim_lat_in[7..0]       : NODE; -- Primary Latency Timer Register
    bar0_dat_in[31..0]        : NODE; -- BAR0
    bar1_dat_in[31..0]        : NODE; -- BAR1
    prim_bus_num_in[7..0]     : NODE; -- Primary Bus Number Input
    sec_bus_num_in[7..0]      : NODE; -- Secondary Bus Number Input
    sub_bus_num_in[7..0]      : NODE; -- Subordinate Bus Number Input
    sec_lat_in[7..0]        : NODE; -- Secondary Bus Number Input
    io_base_in[7..0]        : NODE; -- I/O Base
    io_limit_in[7..0]       : NODE; -- I/O Limit
    sec_stat_in[15..0]        : NODE; -- Secondary Status Register Input
    mem_base_in[15..0]        : NODE; -- Memory Base Register Input
    mem_limit_in[15..0]       : NODE; -- Memory Limit Register Input
    prfch_mem_base_in[15..0]    : NODE; -- Memory Base Register Input
    prfch_mem_limit_in[15..0]   : NODE; -- Memory Limit Register Input
    prfch_mem_base_up_in[31..0]   : NODE; -- Memory Base Register Input
    prfch_mem_limit_up_in[31..0]  : NODE; -- Memory Limit Register Input  
    io_base_up_in[15..0]      : NODE; -- I/O Base Upper 16 Bits
    io_limit_up_in[15..0]     : NODE; -- I/O Limit Upper 16 Bits 
    exp_rom_in[31..0]       : NODE;
    brdg_ctrl_in[15..0]       : NODE; -- Bridge Control Register Input
    cap_ptr_in[7..0]        : NODE;
    mem_base_1_in[15..0]      : NODE;   
    mem_limit_1_in[15..0]           : NODE;    
    prfch_mem_base_1_in[15..0]     : NODE;    
    prfch_mem_limit_1_in[15..0]    : NODE;    
    mem_base_2_in[15..0]            : NODE;   
    mem_limit_2_in[15..0]           : NODE;   
    prfch_mem_base_2_in[15..0]     : NODE;  
    prfch_mem_limit_2_in[15..0]    : NODE;      
    mem_base_3_in[15..0]            : NODE;     
    mem_limit_3_in[15..0]     : NODE;
    prfch_mem_base_3_in[15..0]    : NODE;
    prfch_mem_limit_3_in[15..0] : NODE;
  -- Configuration Space Output
    cmd_out[15..0]          : NODE; -- Command Register Data
    stat_out[15..0]         : NODE; -- Status Register Data
    cache_dat_out[7..0]       : NODE;
    prim_lat_out[7..0]        : NODE; -- Latency Timer Register Data
    prim_bus_num_out[7..0]      : NODE; -- Primary Bus Number Register Output
    sec_bus_num_out[7..0]     : NODE; -- Secondary Bus Number Register Output
    sub_bus_num_out[7..0]     : NODE; -- Subordiante Bus Number Register Output
    sec_lat_out[7..0]       : NODE; -- Secondary Latency Timer Register Output
    sec_stat_out[15..0]       : NODE; -- Secondary Status Register Data 
    io_base_out[7..0]       : NODE;
    io_limit_out[7..0]        : NODE;
    mem_base_out[15..0]       : NODE; -- Memory Base Register Output
    mem_limit_out[15..0]      : NODE; -- Memory Limit Register Output
    prfch_mem_base_out[15..0]   : NODE; -- Memory Base Register Input
    prfch_mem_limit_out[15..0]    : NODE; -- Memory Limit Register Input
    prfch_mem_base_up_out[31..0]  : NODE; -- Memory Base Register Input
    prfch_mem_limit_up_out[31..0] : NODE; -- Memory Limit Register Input    
    io_base_up_out[15..0]     : NODE; -- I/O Base Upper 16 Bits
    io_limit_up_out[15..0]      : NODE; -- I/O Limit Upper 16 Bits  
    exp_rom_out[31..0]        : NODE; 
    brdg_ctrl_out[15..0]      : NODE; -- Bridge Control Register Data
    cap_ptr_out[7..0]       : NODE;
  -- cONFIGURATION DATA
    dev_id_dat[15..0]       : NODE;   -- Device ID Register Data
    vend_id_dat[15..0]        : NODE;   -- Vendor ID Register Data
    cmd_dat[15..0]          : NODE;   -- Command Register Data
    stat_dat[15..0]         : NODE;   -- Status Register Data
    rev_id_dat[7..0]        : NODE;   -- Revision ID Register Data
    class_dat[23..0]        : NODE;   -- Class Code Register Data
    prim_lat_dat[7..0]        : NODE;   -- Primary Latency Timer Data
    cache_dat[7..0]         : NODE;
    sec_lat_dat[7..0]       : NODE;
    sub_bus_num_dat[7..0]     : NODE;
    sec_bus_num_dat[7..0]     : NODE;
    prim_bus_num_dat[7..0]      : NODE;
    sec_stat_dat[15..0]       : NODE;
    io_limit_dat[7..0]        : NODE;
    io_base_dat[7..0]       : NODE;
    mem_limit_dat[15..0]      : NODE;
    mem_base_dat[15..0]       : NODE;
    prfch_mem_limit_dat[15..0]    : NODE;
    prfch_mem_base_dat[15..0]   : NODE;
    prfch_base_up_dat[31..0]    : NODE;
    prfch_limit_up_dat[31..0]   : NODE;
    io_limit_up_dat[15..0]      : NODE;
    io_base_up_dat[15..0]     : NODE;
    cap_ptr_dat[7..0]       : NODE;
    exp_rom_dat[31..0]        : NODE;
    brdg_ctrl_dat[15..0]      : NODE;
    exp_rom_selR          : NODE; -- expansion ROM BAR Select
  -- CONFIGURATION ADDRESS ENABLE
    cfg_04_adr_ena[3..0]      : NODE; -- status/Command Reg clock enables
    cfg_0C_adr_ena[3..0]      : NODE; -- Primary Latency Timer Reg Clock enable
    cfg_18_adr_ena[3..0]      : NODE; -- Prim Bus Num, Sec Bus Num, Subordinate Bus Num, Sec Lat Tmr 
    cfg_1C_adr_ena[3..0]      : NODE; -- Sec Status
    cfg_20_adr_ena[3..0]      : NODE; -- Mem Lim, Mem Base    

    IF (PREFETCHABLE_MEMORY == "YES") GENERATE
      cfg_24_adr_ena[3..0]    : NODE;
    END GENERATE;

    cfg_30_adr_ena[3..0]      : NODE; -- Mem Lim, Mem Base  
    cfg_3C_adr_ena[3..0]      : NODE; -- Brdg Ctrl
  -- CONFIGURATION REGISTER
    cmd_reg[15..0]          : NODE;
    stat_reg[15..0]         : NODE;
    cache_dat_reg[7..0]       : NODE;
    prim_lat_reg[7..0]        : NODE;
    prim_bus_num_reg[7..0]      : NODE;
    sec_bus_num_reg[7..0]     : NODE;
    lirq                      : NODE;
    lirq_reg                  : NODE;
    lirq_rise                 : NODE;
    lirq_fall                 : NODE;
    intr_stat_set             : NODE;
    intr_stat_rst             : NODE;
    
    IF (SUBORDINATE_BUS == "YES") GENERATE
      sub_bus_num_reg[7..0]     : NODE;
    END GENERATE;

    sec_lat_reg[7..0]       : NODE;
    sec_stat_reg[15..0]       : NODE;
    mem_base_reg[15..4]       : DFFE;
    mem_limit_reg[15..4]      : DFFE;
    
    IF (PREFETCHABLE_MEMORY == "YES") GENERATE
      prfch_mem_base_reg[15..4] : DFFE;
      prfch_mem_limit_reg[15..4]  : DFFE;
    END GENERATE;
      
    io_base_reg[7..4]       : DFFE;
    io_limit_reg[7..4]        : DFFE; 
    
    IF (IO_ADDR_32BIT == "YES") GENERATE
      io_base_up_reg[15..0]   : DFFE;
      io_limit_up_reg[15..0]    : DFFE;

      io_base_comp      : lpm_compare WITH (
                LPM_WIDTH = 20, 
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE = 16);
      io_limit_comp     : lpm_compare WITH (
                LPM_WIDTH = 20, 
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE = 16);
      
      io_space_disabled_comp  : lpm_compare WITH (
                LPM_WIDTH = 20, 
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE = 16);

    ELSE GENERATE
    
      io_addr_16bit       : NODE;
    
      io_base_comp      : lpm_compare WITH (
                LPM_WIDTH = 4, 
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE = 16);
                
      io_limit_comp     : lpm_compare WITH (
                LPM_WIDTH = 4, 
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE = 16);

      io_space_disabled_comp  : lpm_compare WITH (
                LPM_WIDTH = 4, 
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE = 16);
    END GENERATE;
    brdg_ctrl_reg[15..0]      : NODE; 
  -- Memory/IO DISABLED BASE/LIMIT

    mem_space_disabled        : DFFE;
    

    mem_base_comp       : lpm_compare WITH (              
                LPM_WIDTH = 12, 
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE = 16);
    mem_limit_comp        : lpm_compare WITH (        
                LPM_WIDTH = 12, 
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE = 16);



    mem_space_disabled_comp   : lpm_compare WITH (              
                LPM_WIDTH = 12, 
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE = 16);

    IF (PREFETCHABLE_MEMORY == "YES") GENERATE
      prfch_mem_space_disabled  : DFFE; 
    END GENERATE;
    io_space_disabled       : DFFE; 
    IF (DISCARD_TIMER == "YES") GENERATE
      discard_rst         : NODE; 
    END GENERATE;

  IF (PRIMARY_INTERFACE == "YES") GENERATE
      mem_adr_vld_cascade : LCELL;
    IF (PREFETCHABLE_MEMORY == "YES") GENERATE
        prfch_mem_adr_vld_cascade : LCELL;
    END GENERATE;
  END GENERATE;
  IF (PRIMARY_INTERFACE == "NO") GENERATE   
    IF (PREFETCHABLE_MEMORY == "YES") GENERATE
      mem_adr_disabled_lc[1..0] : NODE;
      mem_adr_vld_lc[3..0]    : NODE;
        mem_adr_vld_cascade : LCELL;
    END GENERATE;
  END GENERATE;
    
----------------------    
  IF (P2P_MBS_MLMT_1_ENA == 1 ) GENERATE

    cfg_dec_adr_up4         : NODE;
    cfg_adr40_selR          : DFFE;
    cfg_adr44_selR          : DFFE;
    
    cfg_40_adr_ena[3..0]      : NODE;
    cfg_44_adr_ena[3..0]      : NODE;

    mem_base_1_reg[15..4]     : DFFE;
    
    
    mem_base_1_dat[15..0]     : NODE;
    mem_base_1_out[15..0]     : NODE;
    
    mem_limit_1_reg[15..4]      : DFFE;
    
    mem_limit_1_dat[15..0]      : NODE;
    mem_limit_1_out[15..0]      : NODE;
    
    mem_base_limit_1_dat[31..0]   : NODE;
    
    
    prfch_mem_base_1_reg[15..4]   : DFFE;
    prfch_mem_base_1_dat[15..0]   : NODE;
    prfch_mem_base_1_out[15..0]   : NODE;
    
    prfch_mem_limit_1_reg[15..4]  : DFFE;
    prfch_mem_limit_1_dat[15..0]  : NODE;
    prfch_mem_limit_1_out[15..0]  : NODE;
    
    prfch_mbase_lim_1_dat[31..0]  : NODE;
    
    cfg_adr_40_54_dat[31..0]    : NODE;   
    cfg_adr_48_54_dat[31..0]    : NODE;
    cfg_adr_50_54_dat[31..0]    : NODE;
                          
    mem_spc_1_dis_comp    : lpm_compare WITH (              
                LPM_WIDTH = 12, 
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE = 16);

    mem_base_1_comp     : lpm_compare WITH (              
                LPM_WIDTH = 12, 
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE = 16);

    mem_limit_1_comp    : lpm_compare WITH (              
                LPM_WIDTH = 12, 
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE = 16);
                
    prfch_mem_spc_1_dis_comp    : lpm_compare WITH (              
                LPM_WIDTH = 12, 
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE = 16);
                
    prfch_mem_base_1_comp   : lpm_compare WITH (              
                LPM_WIDTH = 12, 
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE = 16);
                
    prfch_mem_limit_1_comp    : lpm_compare WITH (              
                LPM_WIDTH = 12, 
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE = 16);
    mem_spc_1_dis         : DFFE;
    

    adr_ge_mem_base1        : LCELL;
    adr_le_mem_limit1       : LCELL;
    
    prfch_mem_spc_1_dis     : DFFE;
    
    prfch_adr_ge_mem_base1      : LCELL;
    prfch_adr_le_mem_limit1   : LCELL;
                      
  ELSE GENERATE
    mem_base_1_out[15..0]     : NODE;
    mem_limit_1_out[15..0]      : NODE;
    prfch_mem_base_1_out[15..0]   : NODE;
    prfch_mem_limit_1_out[15..0]  : NODE;
    cfg_adr_40_54_dat[31..0]      : NODE;
    cfg_adr_48_54_dat[31..0]      : NODE;
    cfg_adr_50_54_dat[31..0]      : NODE;
    mem_spc_1_dis           : NODE;
    adr_le_mem_limit1         : NODE;
    adr_ge_mem_base1          : NODE;
    prfch_mem_spc_1_dis       : NODE;
    prfch_adr_le_mem_limit1     : NODE;
    prfch_adr_ge_mem_base1        : NODE;
      
  END GENERATE;   
    
  IF (P2P_MBS_MLMT_2_ENA == 1 ) GENERATE

    cfg_adr48_selR          : DFFE;
    cfg_adr4C_selR          : DFFE;
    
    cfg_48_adr_ena[3..0]      : NODE;
    cfg_4C_adr_ena[3..0]      : NODE;

    mem_base_2_reg[15..4]     : DFFE;
    
    
    mem_base_2_dat[15..0]     : NODE;
    mem_base_2_out[15..0]     : NODE;
    
    mem_limit_2_reg[15..4]      : DFFE;
    
    mem_limit_2_dat[15..0]      : NODE;
    mem_limit_2_out[15..0]      : NODE;
    
    mem_base_limit_2_dat[31..0]   : NODE;
    
    
    prfch_mem_base_2_reg[15..4]   : DFFE;
    prfch_mem_base_2_dat[15..0]   : NODE;
    prfch_mem_base_2_out[15..0]   : NODE;
    
    prfch_mem_limit_2_reg[15..4]  : DFFE;
    prfch_mem_limit_2_dat[15..0]  : NODE;
    prfch_mem_limit_2_out[15..0]  : NODE;
    
    prfch_mbase_lim_2_dat[31..0]  : NODE;
    
                    
    mem_spc_2_dis_comp    : lpm_compare WITH (              
                LPM_WIDTH = 12, 
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE = 16);

    mem_base_2_comp     : lpm_compare WITH (              
                LPM_WIDTH = 12, 
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE = 16);

    mem_limit_2_comp    : lpm_compare WITH (              
                LPM_WIDTH = 12, 
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE = 16);
                
    prfch_mem_spc_2_dis_comp    : lpm_compare WITH (              
                LPM_WIDTH = 12, 
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE = 16);
                
    prfch_mem_base_2_comp   : lpm_compare WITH (              
                LPM_WIDTH = 12, 
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE = 16);
                
    prfch_mem_limit_2_comp    : lpm_compare WITH (              
                LPM_WIDTH = 12, 
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE = 16);
    mem_spc_2_dis         : DFFE;
    

    adr_ge_mem_base2        : LCELL;
    adr_le_mem_limit2       : LCELL;
    
    prfch_mem_spc_2_dis     : DFFE;
    
    prfch_adr_ge_mem_base2      : LCELL;
    prfch_adr_le_mem_limit2   : LCELL;
                      
  ELSE GENERATE
    mem_base_2_out[15..0]     : NODE;
    mem_limit_2_out[15..0]      : NODE;
    prfch_mem_base_2_out[15..0]   : NODE;
    prfch_mem_limit_2_out[15..0]  : NODE;
    mem_spc_2_dis           : NODE;
    adr_le_mem_limit2         : NODE;
    adr_ge_mem_base2          : NODE;
    prfch_mem_spc_2_dis       : NODE;
    prfch_adr_le_mem_limit2     : NODE;
    prfch_adr_ge_mem_base2        : NODE;
      
  END GENERATE; 
  
  IF (P2P_MBS_MLMT_3_ENA == 1 ) GENERATE

    cfg_dec_adr_up5         : NODE;
    cfg_adr50_selR          : DFFE;
    cfg_adr54_selR          : DFFE;
    
    cfg_50_adr_ena[3..0]      : NODE;
    cfg_54_adr_ena[3..0]      : NODE;

    mem_base_3_reg[15..4]     : DFFE;
    
    
    mem_base_3_dat[15..0]     : NODE;
    mem_base_3_out[15..0]     : NODE;
    
    mem_limit_3_reg[15..4]      : DFFE;
    
    mem_limit_3_dat[15..0]      : NODE;
    mem_limit_3_out[15..0]      : NODE;
    
    mem_base_limit_3_dat[31..0]   : NODE;
    
    
    prfch_mem_base_3_reg[15..4]   : DFFE;
    prfch_mem_base_3_dat[15..0]   : NODE;
    prfch_mem_base_3_out[15..0]   : NODE;
    
    prfch_mem_limit_3_reg[15..4]  : DFFE;
    prfch_mem_limit_3_dat[15..0]  : NODE;
    prfch_mem_limit_3_out[15..0]  : NODE;
    
    prfch_mbase_lim_3_dat[31..0]  : NODE;
    
        
    mem_spc_3_dis_comp    : lpm_compare WITH (              
                LPM_WIDTH = 12, 
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE = 16);

    mem_base_3_comp     : lpm_compare WITH (              
                LPM_WIDTH = 12, 
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE = 16);

    mem_limit_3_comp    : lpm_compare WITH (              
                LPM_WIDTH = 12, 
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE = 16);
                
    prfch_mem_spc_3_dis_comp    : lpm_compare WITH (              
                LPM_WIDTH = 12, 
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE = 16);
                
    prfch_mem_base_3_comp   : lpm_compare WITH (              
                LPM_WIDTH = 12, 
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE = 16);
                
    prfch_mem_limit_3_comp    : lpm_compare WITH (              
                LPM_WIDTH = 12, 
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE = 16);
    mem_spc_3_dis         : DFFE;
    

    adr_ge_mem_base3        : LCELL;
    adr_le_mem_limit3       : LCELL;
    
    prfch_mem_spc_3_dis     : DFFE;
    
    prfch_adr_ge_mem_base3      : LCELL;
    prfch_adr_le_mem_limit3   : LCELL;
                      
  ELSE GENERATE
    mem_base_3_out[15..0]     : NODE;
    mem_limit_3_out[15..0]      : NODE;
    prfch_mem_base_3_out[15..0]   : NODE;
    prfch_mem_limit_3_out[15..0]  : NODE;
    mem_spc_3_dis           : NODE;
    adr_le_mem_limit3         : NODE;
    adr_ge_mem_base3          : NODE;
    prfch_mem_spc_3_dis       : NODE;
    prfch_adr_le_mem_limit3     : NODE;
    prfch_adr_ge_mem_base3        : NODE;
      
  END GENERATE;   
    
----------------------
----------------------    
    
    
  -- RESET Signals for SRFF
    sec_stat_rst[15..0]       : NODE; -- Secondary Status Register Reset Bits
    mstr_perr_rst         : NODE; -- Reset Signaled Parity Error Bit
    tabrt_sig_rst         : NODE; -- Reset Signaled Target Abort Bit
    tabrt_rcvd_rst          : NODE; -- Reset Received Target Abort Bit
    mabrt_rcvd_rst          : NODE; -- Reset Recieved Master Abort Bit
    serr_sig_rst          : NODE; -- Reset Signaled SERR Bit
    perr_det_rst          : NODE; -- Reset Detected Parity Error Bit
  -- BAR SELECT/HIT   
    bar_selR[1..0]          : NODE; -- Bar0 Register Select
    cyc_vld[1..0]         : LCELL;
  --  bar[1..0][31..0]        : NODE;   -- Data for all Base Address Registers
          bar_0[31..0]        : NODE;
          bar_1[31..0]        : NODE;
  
    bar_hit[1..0]         : NODE; -- Address = BAR Address
    bar_hitR[1..0]          : SRFF; -- Registered bar_hit
  --  bar_nibble[1..0][3..0]      : NODE; -- Bar Lease Significant Nibble
          bar_nibble0[3..0]     : NODE;
          bar_nibble1[3..0]     : NODE;
  -- MEMORY/IO ENABLE     
    mem_access_enable       : NODE;
    io_access_enable        : NODE;
    dac_cmd             : LCELL;  -- Daul Address Command
    mem_cyc             : LCELL;  -- Memory Cycle Indicator
    io_cyc              : LCELL;  -- I/O Cycle Indicator

    
  -- Instantiate Configuration Address Decoder
    cfg_adr_dec           : pcimt32_cd ;    -- Config Address Space decoder
    cfg_adr_dec_tmp_node[5..0]    : NODE;  -- temporary holding nodes so the repeat clause below will work
  -- CONFIGURATION DATA OUTPUT
    config_data[31..0]        : NODE; -- Configuration Data Mux Output
    ad_dat_out[31..0]       : DFFE; -- AD Data Output Registers
  -- MEMORY/IO BASE/LIMIT
    IF (PRIMARY_INTERFACE == "YES") GENERATE    
      adr_ge_mem_base       : NODE; -- Address Greater Than or Equal to Memory Base Register
      adr_le_mem_limit      : NODE; -- Address Less Than or Equal to Memory Limit Register
            
      IF (PREFETCHABLE_MEMORY == "YES") GENERATE
        adr_ge_prfch_mem_base : NODE; -- Address Greater Than or Equal to Memory Base Register
        adr_le_prfch_mem_limit  : NODE; -- Address Less Than or Equal to Memory Limit Register

      prfch_base_comp       :lpm_compare WITH (             -- BAR0 Address Comparator
                LPM_WIDTH = 12, 
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE = 16);
        
      prfch_limit_comp      :lpm_compare WITH (             -- BAR0 Address Comparator
                LPM_WIDTH = 12, 
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE = 16);
      prfch_mem_space_disabled_comp       :lpm_compare WITH (             -- BAR0 Address Comparator
                LPM_WIDTH = 12, 
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE = 16);

      END GENERATE;

      adr_ge_io_base        : NODE; -- Address Greater Than or Equal to I/O Base Register
      adr_le_io_limit       : NODE; -- Address Less Than or Equal to I/O Limit Register

    ELSE GENERATE
      IF (PREFETCHABLE_MEMORY == "YES") GENERATE
        adr_ge_mem_base     : NODE; -- Address Greater Than or Equal to Memory Base Register
        adr_le_mem_limit    : NODE; -- Address Less Than or Equal to Memory Limit Register
        
        adr_ge_prfch_mem_base : NODE; -- Address Greater Than or Equal to Memory Base Register
        adr_le_prfch_mem_limit  : NODE; -- Address Less Than or Equal to Memory Limit Register
        
        prfch_base_comp       :lpm_compare WITH (           
                LPM_WIDTH = 12, 
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE = 16);
        
        prfch_limit_comp      :lpm_compare WITH (           
                LPM_WIDTH = 12, 
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE = 16);
        prfch_mem_space_disabled_comp       :lpm_compare WITH (     
                LPM_WIDTH = 12, 
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE = 16);
  
    
      END GENERATE;
    
    

      adr_l_io_base       : NODE; -- Address less than Base
      adr_g_io_limit        : NODE; -- Address Greater Than Limit
    END GENERATE;
    
     io_adr_vld_cascade : LCELL;
  
  -- NO OPERATION
    no_op[31..0]          : NODE;
  END GENERATE;
--==== END OF TYPE 1 CONFIGURATION SPACE: P2P_BRIDGE == "YES" =====================================
  
--==== Instantiate BAR R/W Registes and Address Comparators =======================================
  -- Repeat this section for each of the BARs
  
---- BAR0: 32-BIT OR 64-BIT BAR --------------------------------------------------------------------
  IF (NUMBER_OF_BARS >= 1+0) GENERATE
    -- P2P_BRIDGE == "YES"  
    IF (P2P_BRIDGE == "YES") GENERATE
      IF (PRIMARY_INTERFACE == "YES") GENERATE
        bar0_reg[31 .. BAR0_READ_ONLY_BITS]   : DFFE;     -- BAR0 R/W Registers 
      ELSE GENERATE -- SECONDARY INTERFACE
        bar0_reg[31 .. BAR0_READ_ONLY_BITS]   : NODE;     -- BAR0 R/W Registers 
      END GENERATE;
      bar0_ena[3..0]                : NODE;     -- Bar0 Register Write Enable
      bar0_comp : lpm_compare WITH (              -- BAR0 Address Comparator
              LPM_WIDTH = (32-BAR0_READ_ONLY_BITS), 
              LPM_REPRESENTATION = "UNSIGNED",
              CHAIN_SIZE = 4);
      IF (BAR0_READ_ONLY_BITS > 4) GENERATE   
        bar0_ro_bits[BAR0_RO_BITS_MAX..4]   : NODE;     -- BAR0 Read Only Bits      
      END GENERATE;
    -- P2P_BRIDGE == "NO"
    ELSE GENERATE
    -- HARDWIRE_BAR
      IF (HARDWIRE_BAR0_ENA == 1) GENERATE
      -- 32-BIT BAR
        IF (BAR0_MEM_LOC < 2) GENERATE      
                bar0_comp : lpm_compare WITH (          -- BAR0 Address Comparator
                LPM_WIDTH = (32-BAR0_READ_ONLY_BITS), 
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE = 4);  
          
        ELSE GENERATE
      -- 64-BIT BAR
          IF (BAR0_READ_ONLY_BITS_64 < 32) GENERATE
              bar0_comp : lpm_compare WITH (            -- BAR0 Address Comparator
                    LPM_WIDTH = (32-BAR0_READ_ONLY_BITS), 
                    LPM_REPRESENTATION = "UNSIGNED",
                    CHAIN_SIZE = 4);
            IF (BAR0_READ_ONLY_BITS > 4) GENERATE   
              bar0_ro_bits[BAR0_RO_BITS_MAX..4]   : NODE;     -- BAR0 Read Only Bits      
            END GENERATE;
          ELSE GENERATE
            bar0_ro_bits[BAR0_READ_ONLY_BITS_64-1..4]   : NODE;     -- BAR0 Read Only Bits
          END GENERATE;           
        END GENERATE;
    -- NO HARDWIRE_BAR    
      ELSE GENERATE 
      -- 32-BIT BAR 
        IF (BAR0_MEM_LOC < 2) GENERATE    
          bar0_ena[3..0]              : NODE;     -- Bar0 Register Write Enable
          bar0_reg[31 .. BAR0_READ_ONLY_BITS]   : DFFE;     -- BAR0 R/W Registers 
          bar0_comp : lpm_compare WITH (              -- BAR0 Address Comparator
                LPM_WIDTH = (32-BAR0_READ_ONLY_BITS), 
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE = 4);
          IF (BAR0_READ_ONLY_BITS > 4) GENERATE   
            bar0_ro_bits[BAR0_RO_BITS_MAX..4]   : NODE;     -- BAR0 Read Only Bits      
          END GENERATE;
        ELSE GENERATE
      -- 64-BIT BAR 
          IF (BAR0_READ_ONLY_BITS_64 < 32) GENERATE
            bar0_ena[3..0]              : NODE;     -- Bar0 Register Write Enable
            bar0_reg[31 .. BAR0_READ_ONLY_BITS]   : DFFE;     -- BAR0 R/W Registers 
            bar0_comp : lpm_compare WITH (            -- BAR0 Address Comparator
                    LPM_WIDTH = (32-BAR0_READ_ONLY_BITS), 
                    LPM_REPRESENTATION = "UNSIGNED",
                    CHAIN_SIZE = 4);
            IF (BAR0_READ_ONLY_BITS > 4) GENERATE -- Ziad Check why we are using 32-Bit instead of 64 bit 
              bar0_ro_bits[BAR0_RO_BITS_MAX..4]   : NODE;     -- BAR0 Read Only Bits      
            END GENERATE;
          ELSE GENERATE       
            bar0_ro_bits[BAR0_READ_ONLY_BITS_64-1..4]   : NODE;     -- BAR0 Read Only Bits
          END GENERATE;   
        END GENERATE; -- END OF 64-BIT BAR    
      END GENERATE; -- END OF NO HARDWIRE BAR
    END GENERATE; -- END OF P2P_BRIDGE == "NO"
  END GENERATE; -- END OF BAR0
---------------------------------------------------------------------------------------------------

---- BAR1: 32-BIT BAR OR 64-BIT BAR ---------------------------------------------------------------
  IF (NUMBER_OF_BARS >= 1+1) GENERATE
  -- P2P_BRIDGE == "YES"
    IF (P2P_BRIDGE == "YES") GENERATE
      IF (PRIMARY_INTERFACE == "YES") GENERATE
        bar1_reg[BAR1_REG_MAX..BAR1_REG_MIN]    : DFFE;     -- BAR1 R/W Registers instantiated in Primary Interface Only 
      ELSE GENERATE
        bar1_reg[BAR1_REG_MAX.. BAR1_REG_MIN]   : NODE;     -- BAR1 R/W Bits are driven from Primary Interface if Sec 
      END GENERATE;
      bar1_ena[3..0]              : NODE;         -- Bar1 Register Write Enable
      bar1_comp : lpm_compare WITH (              -- BAR1 Address Comparator
                  LPM_WIDTH = (BAR1_COMP_WIDTH), 
                  LPM_REPRESENTATION = "UNSIGNED",
                  CHAIN_SIZE = 4);
      IF (BAR1_READ_ONLY_BITS > 4) GENERATE   
        bar1_ro_bits[BAR1_READ_ONLY_BITS-1..4]  : NODE;     -- BAR1 Read Only Bits
      END GENERATE;
  -- P2P_BRIDGE == "NO" 
    ELSE GENERATE 
    -- HARDWIRE_BAR 
      IF (HARDWIRE_BAR1_ENA == 1) GENERATE
      -- 32-BIT BAR
        IF (BAR0_MEM_LOC < 2) GENERATE    -- 32-Bit BAR0
          IF (BAR1_MEM_LOC < 2) GENERATE  -- 32-Bit BAR1  
            bar1_comp : lpm_compare WITH (          -- BAR1 Address Comparator
                      LPM_WIDTH = (BAR1_COMP_WIDTH), 
                      LPM_REPRESENTATION = "UNSIGNED",
                      CHAIN_SIZE = 4);
          ELSE GENERATE   -- 64-Bit BAR1 Hardwired, BAR0 is 32-Bit
            IF (BAR1_READ_ONLY_BITS_64 < 32) GENERATE
                bar1_comp : lpm_compare WITH (            -- BAR1 Address Comparator
                      LPM_WIDTH = (BAR1_COMP_WIDTH), 
                      LPM_REPRESENTATION = "UNSIGNED",
                      CHAIN_SIZE = 4);
              IF (BAR1_READ_ONLY_BITS > 4) GENERATE   
                bar1_ro_bits[BAR1_READ_ONLY_BITS-1..4]  : NODE;     -- BAR1 Read Only Bits      
              END GENERATE;
            ELSE GENERATE
              bar1_ro_bits[BAR1_READ_ONLY_BITS_64-1..4]   : NODE;     -- BAR1 Read Only Bits
            END GENERATE;           
          END GENERATE;
                        
      -- 64-BIT BAR0
        ELSE GENERATE -- 64-Bit BAR0    
          alz_BAR1_64         : DFFE; -- All Zero Bar1 of 64-Bit BAR
          bar1_comp : lpm_compare WITH (              -- BAR1 Address Comparator
                          LPM_WIDTH = (BAR1_READ_WRITE_BITS), 
                          LPM_REPRESENTATION = "UNSIGNED",
                          CHAIN_SIZE = 4);
          IF (MAX_64_BAR_RW_BITS < 32 ) Generate  -- Less than Max Size for BAR1
            IF (BAR1_READ_ONLY_BITS_64 > 0) GENERATE
              bar1_ro_bits_upper[31..MAX_64_BAR_RW_BITS] : NODE;
              bar1_ro_bits_lower[BAR1_READ_ONLY_BITS_64-1..0] : NODE;
            ELSE GENERATE
              bar1_ro_bits_upper[31..MAX_64_BAR_RW_BITS] : NODE;
            END GENERATE;
          ELSE GENERATE -- MAX Size for BAR No Upper RO Bits are needed
            IF (BAR1_READ_ONLY_BITS_64 > 0) GENERATE
              bar1_ro_bits_lower[BAR1_READ_ONLY_BITS_64-1 .. 0 ] : NODE;
            END GENERATE;
          END GENERATE;
        END GENERATE; -- END OF Hardwire 64-BIT BAR
      -- NO HARDWIRE BAR
      ELSE GENERATE
      -- 32-BIT Non-Hardwired BAR
        IF (BAR0_MEM_LOC < 2 ) GENERATE
          IF (BAR1_MEM_LOC < 2) GENERATE -- 32-Bit BAR1
            bar1_ena[3..0]                  : NODE;     -- Bar1 Register Write Enable
            bar1_reg[BAR1_REG_MAX .. BAR1_REG_MIN]        : DFFE;     -- BAR1 R/W Registers 
            bar1_comp : lpm_compare WITH (                -- BAR1 Address Comparator
                        LPM_WIDTH = (BAR1_COMP_WIDTH), 
                        LPM_REPRESENTATION = "UNSIGNED",
                        CHAIN_SIZE = 4);
            IF (BAR1_READ_ONLY_BITS > 4) GENERATE   
              bar1_ro_bits[BAR1_READ_ONLY_BITS-1..4]    : NODE;     -- BAR1 Read Only Bits
            END GENERATE;
          ELSE GENERATE -- 64-Bit BAR1
            IF (BAR1_READ_ONLY_BITS_64 < 32) GENERATE
              bar1_ena[3..0]                : NODE;     -- Bar1 Register Write Enable
              bar1_reg[BAR1_REG_MAX .. BAR1_REG_MIN]      : DFFE;     -- BAR1 R/W Registers 
              bar1_comp : lpm_compare WITH (              -- BAR1 Address Comparator
                      LPM_WIDTH = (BAR1_COMP_WIDTH), 
                      LPM_REPRESENTATION = "UNSIGNED",
                      CHAIN_SIZE = 4);
              IF (BAR1_READ_ONLY_BITS > 4) GENERATE 
                bar1_ro_bits[BAR1_READ_ONLY_BITS-1..4]  : NODE;     -- BAR1 Read Only Bits      
              END GENERATE;
            ELSE GENERATE       
              bar1_ena[3..0]                : NODE;     -- Bar1 Register Write Enable
              bar1_ro_bits[BAR1_READ_ONLY_BITS_64-1..4]   : NODE;     -- BAR1 Read Only Bits
            END GENERATE;   
          END GENERATE;
  
      -- 64-BIT BAR0
        ELSE GENERATE 
          alz_BAR1_64                           : DFFE; -- All Zero Bar1 of 64-Bit BAR
          bar1_ena[3..0]                          : NODE;     -- Bar1 Register Write Enable
          bar1_reg[MAX_64_BAR_RW_BITS-1 .. BAR1_READ_ONLY_BITS_64]    : DFFE;     -- BAR1 R/W Registers 
          bar1_comp : lpm_compare WITH (              -- BAR1 Address Comparator
                      LPM_WIDTH = (BAR1_READ_WRITE_BITS), 
                      LPM_REPRESENTATION = "UNSIGNED",
                      CHAIN_SIZE = 4);  
          IF (MAX_64_BAR_RW_BITS < 32 ) GENERATE  -- Less than Max Size for BAR1
            IF (BAR1_READ_ONLY_BITS_64 > 0) GENERATE
              bar1_ro_bits_upper[31..MAX_64_BAR_RW_BITS]        : NODE;
              bar1_ro_bits_lower[BAR1_READ_ONLY_BITS_64-1..0]     : NODE;
            ELSE GENERATE
              bar1_ro_bits_upper[31..MAX_64_BAR_RW_BITS]        : NODE;
            END GENERATE;
          ELSE GENERATE
            IF (BAR1_READ_ONLY_BITS_64 > 0) GENERATE
              bar1_ro_bits_lower[BAR1_READ_ONLY_BITS_64-1..0]     : NODE;
            END GENERATE;
          END GENERATE;
        END GENERATE; -- END OF 64-BIT BAR
      END GENERATE; -- END OF NO HARDWIRE_BAR     
    END GENERATE; -- END OF P2P_BRIDGE == "NO"
  END GENERATE; -- END OF BAR 1
  
  
  
  
---- Expansion ROM Nodes --------------------------------------------------------------------------
IF(P2P_BRIDGE == "YES") GENERATE
    IF (EXP_ROM_ENA == 1) GENERATE
      exp_rom_comp  : lpm_compare With (
                LPM_WIDTH = (32 - EXP_ROM_READ_ONLY_BITS),
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE  = 4);   
      exp_rom_hit   : NODE;
      exp_rom_cyc_vld : LCELL;
      exp_rom_hitR  : SRFF; 
      exp_rom_ro_bits[EXP_ROM_READ_ONLY_BITS-1 .. 1] : NODE;  
      IF (HARDWIRE_EXP_ROM_ENA == H"0") GENERATE
          IF(PRIMARY_INTERFACE == "YES") GENERATE
        exp_rom_reg[31.. EXP_ROM_READ_ONLY_BITS]  : DFFE;
        exp_rom_dec_ena               : DFFE;
        ELSE GENERATE
        exp_rom_reg[31.. EXP_ROM_READ_ONLY_BITS]  : NODE;
        exp_rom_dec_ena               : NODE;
        END GENERATE;
        exp_rom_en[3..0]              : NODE;
        
      ELSE GENERATE
        exp_rom_temp_dat[31..0]           : NODE;
        exp_rom_reg[31.. EXP_ROM_READ_ONLY_BITS]  : NODE;
        exp_rom_en[3..0]              : NODE;
        exp_rom_dec_ena_not             : DFFE;
        exp_rom_dec_ena               : NODE;
      END GENERATE;
    END GENERATE; 
ELSE GENERATE    -- P2P_BRIDGE = "YES"
  IF (EXP_ROM_ENA == 1) GENERATE
      exp_rom_comp  : lpm_compare With (
                LPM_WIDTH = (32 - EXP_ROM_READ_ONLY_BITS),
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE  = 4);   
      exp_rom_hit   : NODE;
      exp_rom_cyc_vld : LCELL;
      exp_rom_hitR  : SRFF; 
      exp_rom_ro_bits[EXP_ROM_READ_ONLY_BITS-1 .. 1] : NODE;  
      IF (HARDWIRE_EXP_ROM_ENA == H"0") GENERATE
          
        exp_rom_reg[31.. EXP_ROM_READ_ONLY_BITS]  : DFFE;
        exp_rom_en[3..0]              : NODE;
        exp_rom_dec_ena               : DFFE;
      ELSE GENERATE
        exp_rom_temp_dat[31..0]           : NODE;
        exp_rom_reg[31.. EXP_ROM_READ_ONLY_BITS]  : NODE;
        exp_rom_en[3..0]              : NODE;
        exp_rom_dec_ena_not             : DFFE;
        exp_rom_dec_ena               : NODE;
      END GENERATE;
    END GENERATE; 
  
  
  
  
END GENERATE;
    
            
    exp_rom_access    : NODE;
---------------------------------------------------------------------------------------------------
-- Old
---------------------------------------------------------------------------------------------------

--==== BAR 5-2 ARE NOT USED FOR P2P_BRIDGE: P2P_BRIDGE == "NO" ====================================
---- BAR2: NOT USED FOR P2P_BRIDGE == "YES" ------------------------------------------------------- 
---- BAR2: 32-BIT BAR OR 64-BIT BAR ---------------------------------------------------------------
  IF (P2P_BRIDGE == "NO") GENERATE  
    IF (NUMBER_OF_BARS >= 1+2) GENERATE
      -- HARDWIRE_BAR 
      IF (HARDWIRE_BAR2_ENA == 1) GENERATE
        IF(BAR1_MEM_LOC == 2 AND BAR0_MEM_LOC < 2) GENERATE -- 32_bit BAR0 and 64-Bit BAR1
          alz_BAR2_64                         : DFFE;   -- All Zero Bar2 of 64-Bit BAR
          bar2_comp : lpm_compare WITH (                    -- BAR2 Address Comparator
                          LPM_WIDTH = (BAR2_READ_WRITE_BITS), 
                          LPM_REPRESENTATION = "UNSIGNED",
                          CHAIN_SIZE = 4);
          IF (MAX_64_BAR_RW_BITS < 32 ) Generate                  -- Less than Max Size for BAR2
            IF (BAR2_READ_ONLY_BITS_64 > 0) GENERATE
              bar2_ro_bits_upper[31..MAX_64_BAR_RW_BITS]      : NODE;
              bar2_ro_bits_lower[BAR2_READ_ONLY_BITS_64-1..0]   : NODE;
            ELSE GENERATE
              bar2_ro_bits_upper[31..MAX_64_BAR_RW_BITS]      : NODE;
            END GENERATE;
          ELSE GENERATE -- MAX Size for BAR No Upper RO Bits are needed
            IF (BAR2_READ_ONLY_BITS_64 > 0) GENERATE
              bar2_ro_bits_lower[BAR2_READ_ONLY_BITS_64-1 .. 0 ]  : NODE;
            END GENERATE;
          END GENERATE;
        ELSE GENERATE -- 32-Bit BAR2
          bar2_comp : lpm_compare WITH (                    -- BAR2 Address Comparator
                        LPM_WIDTH = (BAR2_COMP_WIDTH), 
                        LPM_REPRESENTATION = "UNSIGNED",
                        CHAIN_SIZE = 4);            
        END GENERATE; -- END OF Hardwire BAR
      -- NO HARDWIRE BAR
      ELSE GENERATE
        IF(BAR1_MEM_LOC == 2 AND BAR0_MEM_LOC < 2) GENERATE -- 32_bit BAR0 and 64-Bit BAR1
          alz_BAR2_64                         : DFFE;   -- All Zero Bar1 of 64-Bit BAR
          bar2_ena[3..0]                        : NODE;   -- Bar1 Register Write Enable
          bar2_reg[MAX_64_BAR_RW_BITS-1 .. BAR2_READ_ONLY_BITS_64]  : DFFE;   -- BAR1 R/W Registers 
          bar2_comp : lpm_compare WITH (                    -- BAR1 Address Comparator
                      LPM_WIDTH = (BAR2_READ_WRITE_BITS), 
                      LPM_REPRESENTATION = "UNSIGNED",
                      CHAIN_SIZE = 4);  
          IF (MAX_64_BAR_RW_BITS < 32 ) GENERATE  -- Less than Max Size for BAR1
            IF (BAR2_READ_ONLY_BITS_64 > 0) GENERATE
              bar2_ro_bits_upper[31..MAX_64_BAR_RW_BITS]      : NODE;
              bar2_ro_bits_lower[BAR2_READ_ONLY_BITS_64-1..0]   : NODE;
            ELSE GENERATE
              bar2_ro_bits_upper[31..MAX_64_BAR_RW_BITS]      : NODE;
            END GENERATE;
          ELSE GENERATE
            IF (BAR2_READ_ONLY_BITS_64 > 0) GENERATE
              bar2_ro_bits_lower[BAR2_READ_ONLY_BITS_64-1..0]   : NODE;
            END GENERATE;
          END GENERATE;
        
        ELSE GENERATE -- 32-Bit BAR2
      
          bar2_ena[3..0]                        : NODE;   -- Bar1 Register Write Enable
          bar2_reg[BAR2_REG_MAX .. BAR2_REG_MIN]              : DFFE;   -- BAR1 R/W Registers 
          bar2_comp : lpm_compare WITH (                    -- BAR1 Address Comparator
                      LPM_WIDTH = (BAR2_COMP_WIDTH), 
                      LPM_REPRESENTATION = "UNSIGNED",
                      CHAIN_SIZE = 4);
          IF (BAR2_READ_ONLY_BITS > 4) GENERATE   
            bar2_ro_bits[BAR2_READ_ONLY_BITS-1..4]          : NODE;   -- BAR1 Read Only Bits
          END GENERATE;
      
        END GENERATE; -- END OF 64-BIT BAR
      END GENERATE; -- END OF NO HARDWIRE_BAR     
    END GENERATE; -- END OF P2P_BRIDGE == "NO"

---- BAR3: NOT USED FOR P2P_BRIDGE == "YES" -------------------------------------------------------
    IF (NUMBER_OF_BARS >= 1+3) GENERATE
      IF (HARDWIRE_BAR3_ENA == 1) GENERATE
        bar3_comp : lpm_compare WITH (              -- BAR3 Address Comparator
                LPM_WIDTH = (32-BAR3_READ_ONLY_BITS), 
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE = 4);
      ELSE GENERATE
        bar3_ena[3..0]                : NODE;     -- Bar3 Register Write Enable
        bar3_reg[31 .. BAR3_READ_ONLY_BITS]   : DFFE;     -- BAR3 R/W Registers 
        bar3_comp : lpm_compare WITH (              -- BAR3 Address Comparator
                LPM_WIDTH = (32-BAR3_READ_ONLY_BITS), 
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE = 4);
        IF (BAR3_READ_ONLY_BITS > 4) GENERATE 
          bar3_ro_bits[BAR3_READ_ONLY_BITS-1..4]  : NODE;     -- BAR3 Read Only Bits    
        END GENERATE;
      END GENERATE;     
    END GENERATE;

---- BAR4 -----------------------------------------------------------------------------------------
    IF (NUMBER_OF_BARS >= 1+4) GENERATE
      IF (HARDWIRE_BAR4_ENA == 1) GENERATE
        bar4_comp : lpm_compare WITH (              -- BAR4 Address Comparator
                LPM_WIDTH = (32-BAR4_READ_ONLY_BITS), 
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE = 4);
        ELSE GENERATE
          bar4_ena[3..0]                : NODE;     -- Bar4 Register Write Enable
        bar4_reg[31 .. BAR4_READ_ONLY_BITS]   : DFFE;     -- BAR4 R/W Registers 
        bar4_comp : lpm_compare WITH (              -- BAR4 Address Comparator
                LPM_WIDTH = (32-BAR4_READ_ONLY_BITS), 
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE = 4);
        IF (BAR4_READ_ONLY_BITS > 4) GENERATE
          bar4_ro_bits[BAR4_READ_ONLY_BITS-1..4]  : NODE;     -- BAR4 Read Only Bits    
        END GENERATE;
      END GENERATE;
    END GENERATE;
    
---- BAR5 -----------------------------------------------------------------------------------------
    IF (NUMBER_OF_BARS >= 1+5) GENERATE
      IF (HARDWIRE_BAR5_ENA == 1) GENERATE
          bar5_comp : lpm_compare WITH (              -- BAR5 Address Comparator
                LPM_WIDTH = (32-BAR5_READ_ONLY_BITS), 
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE = 4);
      ELSE GENERATE
        bar5_ena[3..0]                : NODE;     -- Bar5 Register Write Enable
        bar5_reg[31 .. BAR5_READ_ONLY_BITS]   : DFFE;     -- BAR5 R/W Registers 
        bar5_comp : lpm_compare WITH (              -- BAR5 Address Comparator
                LPM_WIDTH = (32-BAR5_READ_ONLY_BITS), 
                LPM_REPRESENTATION = "UNSIGNED",
                CHAIN_SIZE = 4);
        IF (BAR5_READ_ONLY_BITS > 4) GENERATE
          bar5_ro_bits[BAR5_READ_ONLY_BITS-1..4]  : NODE;     -- BAR5 Read Only Bits  
        END GENERATE;
      END GENERATE;
    END GENERATE;
    
    --
END GENERATE; -- END OF P2P_BRIDGE == "NO"




  
--==== END OF BAR 5-2 NODES FOR P2P_BRIDGE == "NO" ================================================

  
BEGIN
DEFAULTS
        cfg_dat_out_a[207..0] = GND;
        cfg_dat_out_b[183..0] = GND;
        cfg_dat_out_c[191..0] = GND;
        mem_adr_vld           = GND;
        prfch_mem_adr_vld     = GND;
        io_adr_vld            = GND;
END DEFAULTS;
--==== BEGINNING OF LOGIC SECTION =================================================================
Assert (VERBOSE == "NO") Report " PCI Configuration Module $Revision: 1.9 $, $JustDate:  1/09/03 $"
severity INFO;
--==== P2P_BRIDGE == "NO" =========================================================================
  IF (P2P_BRIDGE == "NO") GENERATE
    IF( HARDWIRE_HB_ENA == 1) GENERATE
      Assert report " Host bridge functionality is enabled.  This hardwires command, latency timer and cacheline registers and enables l_stat_reg_rst[5..0] bus"
      severity info;
    END GENERATE;     
  dev_vend_selR       = cfg_adr_dec.selR0;    -- Data = B"000000"
  stat_cmd_selR       = cfg_adr_dec.selR1;    -- Data = B"000001"
  cis_ptr_selR        = cfg_adr_dec.selR10;   -- Data = B"001010"
  class_rev_selR        = cfg_adr_dec.selR2;    -- Data = B"000010"
  bist_hdr_lat_cach_selR    = cfg_adr_dec.selR3;    -- Data = B"000011"
  subs_subsvend_selR      = cfg_adr_dec.selR11;   -- Data = B"001011"
  exp_rom_selR        = cfg_adr_dec.selR12;   -- Data = B"001100"
  cap_ptr_selR        = cfg_adr_dec.selR13;   -- Data = B"001101"
  lat_gnt_intpin_intln_selR = cfg_adr_dec.selR15;   -- Data = B"001111"


  -- Configuarion Registers Clock Enables
  IF (LOCAL_CONFIG_ENA == "NO") GENERATE  
    stat_cmd_ena[3..0]      = stat_cmd_selR and cfg_dat_vld and not (cben_IR[3..0]);
    latency_cache_ena[1..0]   = bist_hdr_lat_cach_selR and cfg_dat_vld and not(cben_IR[1..0]);
    int_ln_ena0         = lat_gnt_intpin_intln_selR and cfg_dat_vld and not (cben_IR0);
  ELSE  GENERATE
    stat_cmd_ena[3..0]      = stat_cmd_selR and lcfg_dat_vld and not lcfg_ben[3..0];
    latency_cache_ena[1..0]   = bist_hdr_lat_cach_selR and lcfg_dat_vld and not lcfg_ben[1..0];
    int_ln_ena0         = lat_gnt_intpin_intln_selR and lcfg_dat_vld and not lcfg_ben0;
  END GENERATE;
  
  -- Read/Write Configuration Registers
  -- Command Register
  IF (TARGET_ONLY =="NO") GENERATE
    IF( LOCAL_CONFIG_ENA == "NO") GENERATE
      IF( HARDWIRE_HB_ENA == H"0") GENERATE       
        cmd_reg0  = DFFE(ad_IR0,clk,rstn,VCC,stat_cmd_ena0);        -- I/O Space Enable
        cmd_reg1  = DFFE(ad_IR1,clk,rstn,VCC,stat_cmd_ena0);        -- Memory Space Enable

        IF (SCFG_HB_ENA == 0) GENERATE  -- Self Configuration Host Bridge Enable
          cmd_reg2  = DFFE(ad_IR2,clk,rstn,VCC,stat_cmd_ena0);      -- Bus Master Enable        
        ELSE GENERATE
          cmd_reg2  = VCC;                          
        END GENERATE;   

        cmd_reg3  = GND;                          -- Read Only Special Cycle
        cmd_reg4  = DFFE(ad_IR4,clk,rstn,VCC,stat_cmd_ena0);        -- Memory Write and Invalidate Enable
        cmd_reg5  = GND;                          -- Read Only VGA Pallet Snoop
        cmd_reg6  = DFFE(ad_IR6,clk,rstn,VCC,stat_cmd_ena0);        -- Pariy Error Response Enable 
        cmd_reg7  = GND;                          -- Read Only Wait Cycle Control
        cmd_reg8  = DFFE(ad_IR8,clk,rstn,VCC,stat_cmd_ena1);        -- SERR Enable
        cmd_reg9  = GND;                          -- Read Only, Fast Back-to-Back Enable
        cmd_reg10 = DFFE(ad_IR10, clk, rstn, VCC, stat_cmd_ena1);  -- Interrupt Disable bit
        cmd_reg[15..11] = B"00000";                    -- Read Only, Reserve
      ELSE  GENERATE
        cmd_reg0  = VCC;                          -- I/O Space Enable
        cmd_reg1  = VCC;                          -- Memory Space Enable
        cmd_reg2  = VCC;                          -- Read Only Bus Master Enable
        cmd_reg3  = GND;                          -- Read Only Special Cycle
        cmd_reg4  = VCC;                          -- Memory Write and Invalidate Enable
        cmd_reg5  = GND;                          -- Read Only VGA Pallet Snoop
        cmd_reg6  = VCC;                          -- Pariy Error Response Enable 
        cmd_reg7  = GND;                          -- Read Only Wait Cycle Control
        cmd_reg8  = VCC;                          -- SERR Enable
        cmd_reg9  = GND;                          -- Read Only, Fast Back-to-Back Enable
        cmd_reg[15..10] = B"000000";                    -- Read Only, Reserve

        no_op0    = stat_cmd_ena0 or stat_cmd_ena1;
        
      END GENERATE;
    ELSE  GENERATE      
      IF( HARDWIRE_HB_ENA == H"0") GENERATE
        cmd_reg0  = DFFE(lcfg_dat_in0,clk,rstn,VCC,stat_cmd_ena0);    -- I/O Space Enable
        cmd_reg1  = DFFE(lcfg_dat_in1,clk,rstn,VCC,stat_cmd_ena0);    -- Memory Space Enable
        IF (SCFG_HB_ENA == 0) GENERATE  -- Self Configuration Host Bridge Enable  
        cmd_reg2  = DFFE(lcfg_dat_in2,clk,rstn,VCC,stat_cmd_ena0);    -- Bus Master Enable
        ELSE GENERATE
          cmd_reg2  = VCC;                          
        END GENERATE;   

        cmd_reg3  = GND;                          -- Read Only Special Cycle
        cmd_reg4  = DFFE(lcfg_dat_in4,clk,rstn,VCC,stat_cmd_ena0);    -- Memory Write and Invalidate Enable
        cmd_reg5  = GND;                          -- Read Only VGA Pallet Snoop
        cmd_reg6  = DFFE(lcfg_dat_in6,clk,rstn,VCC,stat_cmd_ena0);    -- Pariy Error Response Enable 
        cmd_reg7  = GND;                          -- Read Only Wait Cycle Control
        cmd_reg8  = DFFE(lcfg_dat_in8,clk,rstn,VCC,stat_cmd_ena1);    -- SERR Enable
        cmd_reg9  = GND;                          -- Read Only, Fast Back-to-Back Enable
        cmd_reg[15..10] = B"00000";                    -- Read Only, Reserved
      ELSE  GENERATE
        cmd_reg0  = VCC;                          -- I/O Space Enable
        cmd_reg1  = VCC;                          -- Memory Space Enable
        cmd_reg2  = VCC;                          -- Bus Master Enable
        cmd_reg3  = GND;                          -- Read Only Special Cycle
        cmd_reg4  = VCC;                          -- Memory Write and Invalidate Enable
        cmd_reg5  = GND;                          -- Read Only VGA Pallet Snoop
        cmd_reg6  = VCC;                          -- Pariy Error Response Enable 
        cmd_reg7  = GND;                          -- Read Only Wait Cycle Control
        cmd_reg8  = VCC;                          -- SERR Enable
        cmd_reg9  = GND;                          -- Read Only, Fast Back-to-Back Enable
        cmd_reg[15..10] = B"000000";                    -- Read Only, Reserved
        
        no_op0    = stat_cmd_ena0 or stat_cmd_ena1;
        
      END GENERATE;
    END GENERATE;
  ELSE GENERATE       
    IF( LOCAL_CONFIG_ENA == "NO") GENERATE      
      cmd_reg0  = DFFE(ad_IR0,clk,rstn,VCC,stat_cmd_ena0);        -- I/O Space Enable
      cmd_reg1  = DFFE(ad_IR1,clk,rstn,VCC,stat_cmd_ena0);        -- Memory Space Enable
      cmd_reg2  = GND;                          -- Read Only Bus Master Enable
      cmd_reg3  = GND;                          -- Read Only Special Cycle
      cmd_reg4  = GND;                          -- Memory Write and Invalidate Enable
      cmd_reg5  = GND;                          -- Read Only VGA Pallet Snoop
      cmd_reg6  = DFFE(ad_IR6,clk,rstn,VCC,stat_cmd_ena0);        -- Pariy Error Response Enable 
      cmd_reg7  = GND;                          -- Read Only Wait Cycle Control
      cmd_reg8  = DFFE(ad_IR8,clk,rstn,VCC,stat_cmd_ena1);        -- SERR Enable
      cmd_reg9  = GND;                          -- Read Only, Fast Back-to-Back Enable
      cmd_reg10  = DFFE(ad_IR10,clk,rstn,VCC,stat_cmd_ena1);
      cmd_reg[15..11] = B"00000";                    -- Read Only, Reserved      
    ELSE  GENERATE      
      cmd_reg0  = DFFE(lcfg_dat_in0,clk,rstn,VCC,stat_cmd_ena0);    -- I/O Space Enable
      cmd_reg1  = DFFE(lcfg_dat_in1,clk,rstn,VCC,stat_cmd_ena0);    -- Memory Space Enable
      cmd_reg2  = GND;                          -- Read Only Bus Master Enable
      cmd_reg3  = GND;                          -- Read Only Special Cycle
      cmd_reg4  = GND;                          -- Memory Write and Invalidate Enable
      cmd_reg5  = GND;                          -- Read Only VGA Pallet Snoop
      cmd_reg6  = DFFE(lcfg_dat_in6,clk,rstn,VCC,stat_cmd_ena0);    -- Pariy Error Response Enable 
      cmd_reg7  = GND;                          -- Read Only Wait Cycle Control
      cmd_reg8  = DFFE(lcfg_dat_in8,clk,rstn,VCC,stat_cmd_ena1);    -- SERR Enable
      cmd_reg9  = GND;                          -- Read Only, Fast Back-to-Back Enable
      cmd_reg[15..10] = B"000000";                    -- Read Only, Reserved
    END GENERATE;
  END GENERATE;
  
  -- interrupt status register supporting signals
  lirq = not lirqn;
  lirq_reg = DFFE(lirq,clk,rstn,VCC,VCC);
  lirq_rise = not lirq_reg and lirq;
  lirq_fall = lirq_reg and not lirq;
  intr_stat_set = not cmd_reg10 and lirq_rise;
  intr_stat_rst = lirq_fall;
  

  
  -- Status Register
  stat_reg[2..0]    = B"000";
  stat_reg3    = pcimt32_sr(intr_stat_set, intr_stat_rst, clk, rstn,VCC);      -- Interrupt status
  
  IF (CAP_LIST_ENA == 1) GENERATE
    stat_reg4     = VCC;                            -- Capability List Enable
  ELSE GENERATE
    stat_reg4   = GND;
  END GENERATE;
  
  IF (PCI_66MHZ_CAPABLE == "YES") GENERATE
    stat_reg5   = VCC;                            -- Read Only, 66 MHZ capable
  ELSE GENERATE
    stat_reg5   = GND;
  END GENERATE;
  
  stat_reg6   = GND;                            -- Read Only, UDF Supported
  stat_reg7   = GND;                            -- Read Only, Fast Back-To-Back Capable
  stat_reg8   = SRFF(perr_rep_set, par_rep_rst, clk, rstn, VCC);      -- Data Parity Error Signaled
  stat_reg[10..9] = B"10";                          -- Read Only, Devsel Timing, SLOW
  stat_reg11    = pcimt32_sr(tabrt_set, targ_abrt_rst, clk, rstn,VCC);      -- Signaled Target Abort
  stat_reg12    = pcimt32_sr(tabrt_rcvd_set, targ_abrt_rcvd_rst, clk, rstn, VCC); -- Recieved Target Abort
  stat_reg13    = pcimt32_sr(mabrt_set, mstr_abrt_rst, clk, rstn, VCC);     -- Recieved Master Abort
  stat_reg14    = pcimt32_sr(serr_det, serr_rst, clk, rstn, VCC);       -- Signaled SERR
  stat_reg15    = pcimt32_sr(perr_det_set, perr_det_rst, clk, rstn, VCC);   -- Detected Parity Error
--  stat_reg15    = pcimt32_sr(gnd, vcc, clk, rstn, VCC);   -- Detected Parity Error

  no_op[]     =     no_op[] 
            or  stat_cmd_ena2 -- or bar_hit_lc1 or bar_hit_lc2 or bar_hit_lc3 or exp_rom_hit_lc1 or exp_rom_hit_lc2  ;
            OR  dac_adr_phase_r 
            or  bar_hit[1]
            or bar_hit[2]
            or bar_hit[3]
            or bar_hit[4]
            or bar_hit[5]
            OR cyc_vld[0]
            OR cyc_vld[1]
            OR cyc_vld[2]
            OR cyc_vld[3]
            OR cyc_vld[4]
            OR cyc_vld[5]
                        OR l_stat_reg_rst[0]
                        OR l_stat_reg_rst[1]
                        OR l_stat_reg_rst[2]
                        OR l_stat_reg_rst[3]
                        OR l_stat_reg_rst[4]
                        OR l_stat_reg_rst[5]
                        OR int_ack_hit_cc            
                        OR bar3_cc                 
                        OR bar34_cc         
                        OR bar4_cc                         
                        OR bar345_cc                   
                        OR bar45_cc                       

                         ;
            
  IF( LOCAL_CONFIG_ENA == "NO") GENERATE
    IF( HARDWIRE_HB_ENA == H"0") GENERATE
      par_rep_rst     = LCELL(stat_cmd_selR and stat_cmd_ena3 and ad_IR24) ;      -- Reset Signaled Parity Error Bit
      targ_abrt_rst   = LCELL(stat_cmd_selR and stat_cmd_ena3 and ad_IR27);     -- Reset Signaled Target Abort Bit
      targ_abrt_rcvd_rst  = LCELL(stat_cmd_selR and stat_cmd_ena3 and ad_IR28);     -- Reset Received Target Abort Bit
      mstr_abrt_rst   = LCELL(stat_cmd_selR and stat_cmd_ena3 and ad_IR29);     -- Reset Recieved Master Abort Bit
      serr_rst      = LCELL(stat_cmd_selR and stat_cmd_ena3 and ad_IR30);     -- Reset Signaled SERR Bit
      perr_det_rst    = LCELL(stat_cmd_selR and stat_cmd_ena3 and ad_IR31);     -- Reset Detected Parity Error Bit
    ELSE GENERATE
      par_rep_rst     = l_stat_reg_rst0 ;                       -- Reset Signaled Parity Error Bit
      targ_abrt_rst   = l_stat_reg_rst1 ;                       -- Reset Signaled Target Abort Bit
      targ_abrt_rcvd_rst  = l_stat_reg_rst2 ;                       -- Reset Received Target Abort Bit
      mstr_abrt_rst   = l_stat_reg_rst3 ;                       -- Reset Recieved Master Abort Bit
      serr_rst      = l_stat_reg_rst4 ;                       -- Reset Signaled SERR Bit
      perr_det_rst    = l_stat_reg_rst5 ;                       -- Reset Detected Parity Error Bit
      
      no_op0        = stat_cmd_ena3;
    END GENERATE;
  ELSE  GENERATE
    par_rep_rst     = LCELL(stat_cmd_selR and stat_cmd_ena3 and lcfg_dat_in24) ;      -- Reset Signaled Parity Error Bit
    targ_abrt_rst   = LCELL(stat_cmd_selR and stat_cmd_ena3 and lcfg_dat_in27);     -- Reset Signaled Target Abort Bit
    targ_abrt_rcvd_rst  = LCELL(stat_cmd_selR and stat_cmd_ena3 and lcfg_dat_in28);     -- Reset Received Target Abort Bit
    mstr_abrt_rst   = LCELL(stat_cmd_selR and stat_cmd_ena3 and lcfg_dat_in29);     -- Reset Recieved Master Abort Bit
    serr_rst      = LCELL(stat_cmd_selR and stat_cmd_ena3 and lcfg_dat_in30);     -- Reset Signaled SERR Bit
    perr_det_rst    = LCELL(stat_cmd_selR and stat_cmd_ena3 and lcfg_dat_in31);     -- Reset Detected Parity Error Bit
  END GENERATE;

  -- Latency Timer Register
IF (TARGET_ONLY =="NO") GENERATE
  IF( HARDWIRE_HB_ENA == H"0") GENERATE
    lat_tmr_reg[4..0].clk = clk;
    lat_tmr_reg[4..0].clrn  = rstn;
    lat_tmr_reg[4..0].ena = latency_cache_ena1;
    lat_tmr[7..3]   = lat_tmr_reg[4..0];
    lat_tmr[2..0]   = B"000";

    IF( LOCAL_CONFIG_ENA == "NO") GENERATE    
      lat_tmr_reg[4..0]   = ad_IR[15..11];
    ELSE  GENERATE
      lat_tmr_reg[4..0]   = lcfg_dat_in[15..11];
    END GENERATE;
  ELSE GENERATE
    
    lat_tmr[7..0]   = HARDWIRE_LAT_TMR;
    no_op0        = latency_cache_ena1;
    
  END GENERATE;
  
ELSE GENERATE

  lat_tmr[7..3]   = GND;
  lat_tmr[2..0]   = GND;
  no_op[0] = latency_cache_ena1 OR dac_adr_phase_r ;
  
END GENERATE;
  

  -- Cache Line Register
  IF (TARGET_ONLY =="NO") GENERATE
    IF( HARDWIRE_HB_ENA == H"0") GENERATE

      cache_line[7..0].clk  = clk;
      cache_line[7..0].clrn = rstn;
      cache_line[7..0].ena  = latency_cache_ena0;
    
      IF( LOCAL_CONFIG_ENA == "NO") GENERATE
        cache_line[7..0]    = ad_IR[7..0];      
      ELSE  GENERATE
        cache_line[7..0]    = lcfg_dat_in[7..0];
      END GENERATE;
    ELSE GENERATE
    
      cache_line[7..0]    = HARDWIRE_CACHE_LINE;
      no_op0          = latency_cache_ena0;
      
    END GENERATE;
        
  ELSE GENERATE
    cache_line[7..0]    = GND;
    no_op[0] = latency_cache_ena0;
  END GENERATE;
    
  -- Interrupt Line Register
  IF ( INTERRUPT_PIN_REG == H"01") GENERATE
    -- Interrupt Line Register
    int_ln_reg[7..0].clk  = clk;
    int_ln_reg[7..0].clrn = rstn;
    int_ln_reg[7..0].ena  = int_ln_ena0;  
    IF( LOCAL_CONFIG_ENA == "NO") GENERATE    
      int_ln_reg[7..0]    = ad_IR[7..0];    
    ELSE  GENERATE    
      int_ln_reg[7..0]    = lcfg_dat_in[7..0];  
    END GENERATE;
  ELSE GENERATE
    int_ln_reg[7..0]= GND;
    no_op[0] = int_ln_ena0; 
  END GENERATE;


  -- Convert Parameters Into Data
  device_id_dat[15..0]    = DEVICE_ID;    -- Device ID Register Data
  device_vend_id_dat[15..0] = VENDOR_ID;    -- Device Vendor ID Register Data
  class_dat[23..0]      = CLASS_CODE;   -- Class Code Register Data
  rev_id_dat[7..0]      = REVISION_ID;    -- Revision ID Register Data
  subs_id_dat[15..0]      = SUBSYSTEM_ID;   -- Subsystem ID Register Data
  subs_vend_id_dat[15..0]   = SUBSYSTEM_VENDOR_ID;  -- Subsystem Vendor ID Register Data
  IF (CAP_LIST_ENA == 1) GENERATE
    cap_ptr_dat[7..0]     = CAP_PTR;    -- Capabilities Pointer
  ELSE GENERATE
    cap_ptr_dat[7..0]     = H"00";    -- Capabilities Pointer
  END GENERATE;
  IF ( CIS_PTR_ENA == 1) GENERATE 
        cis_ptr_reg_dat[31..0] = cis_ptr;  -- Cis pointer         
  ELSE GENERATE 
        cis_ptr_reg_dat[31..0] = H"00000000";           -- Cis pointer    
  END GENERATE;
  IF (TARGET_ONLY =="NO") GENERATE

  max_lat_dat[7..0]     = MAX_LATENCY;    -- Maximum Latency Register Data
  min_gnt_dat[7..0]     = MIN_GRANT;    -- Minimum Grant Register Data
  ELSE GENERATE
  
  max_lat_dat[7..0]     = GND;    -- Maximum Latency Register Data
  min_gnt_dat[7..0]     = GND;    -- Minimum Grant Register Data

  END GENERATE;
  -- Set Configuration Register Output Data
  cap_reg_dat[31..0]      = (H"000000",cap_ptr_dat[7..0]); 
  dev_vend_dat[31..0]     = (device_id_dat[15..0],device_vend_id_dat[15..0]);
  stat_cmd_dat[31..0]     = (stat_reg[15..0], cmd_reg[15..0]);
  class_revision_dat[31..0]   = (class_dat[23..0], rev_id_dat[7..0]);
  bist_hdr_ltncy_cach_dat[31..0]  = (H"00",H"00",lat_tmr[7..0],cache_line[7..0]);
  subs_subsvend_dat[31..0]    = (subs_id_dat[15..0],subs_vend_id_dat[15..0]);

  IF ((INTERRUPT_PIN_REG != H"01") and (INTERRUPT_PIN_REG != H"00")) GENERATE 
  ASSERT REPORT "ERROR: The INTERRUPT_PIN_REG parameter can only be set to H""01"" to implement INTAn, or to H""00"" for no interrupt pin implementation."
  SEVERITY ERROR;
  END GENERATE;
  INTERRUPT_PIN_REG_node[] = INTERRUPT_PIN_REG;   

  lat_gnt_intpin_intln_dat[31..0] = (max_lat_dat[7..0],min_gnt_dat[7..0],INTERRUPT_PIN_REG_node[],int_ln_reg[7..0]);

  --lat_gnt_intpin_intln_dat[31..0] = (max_lat_dat[7..0],min_gnt_dat[7..0],B"00000001",int_ln_reg[7..0]);

  
  config_data[] =   (dev_vend_dat[] and dev_vend_selR)
        OR  (stat_cmd_dat[] and stat_cmd_selR)
        OR  (class_revision_dat[] and class_rev_selR)
        OR  (bist_hdr_ltncy_cach_dat[] and bist_hdr_lat_cach_selR)
        OR  (bar_0[] and bar_selR[0])
        OR  (bar_1[] and bar_selR[1])
        OR  (bar_2[] and bar_selR[2])
        OR  (bar_3[] and bar_selR[3])
        OR  (bar_4[] and bar_selR[4])
        OR  (bar_5[] and bar_selR[5])
        OR  (subs_subsvend_dat[] and subs_subsvend_selR)
        OR  (cap_reg_dat[] and cap_ptr_selR)
        OR  (cis_ptr_reg_dat[] and cis_ptr_selR)
        OR  (exp_rom_dat[] and exp_rom_selR)
        OR  (lat_gnt_intpin_intln_dat[] and lat_gnt_intpin_intln_selR);

  ad_dat_out[].clk  = clk;
  ad_dat_out[].clrn = rstn;
  ad_dat_out[]    = config_data[];
--  cfg_dat_out[]   = ad_dat_out[];
  
  IF( LOCAL_CONFIG_ENA == "NO") GENERATE

    lcfg_dat_out[31..0]   = H"00000000";

  ELSE  GENERATE

    lcfg_dat_out[31..0]   = cfg_dat_out[];

  END GENERATE;

  -- Command Register Local Side Outputs

  io_ena        = cmd_reg0;   -- I/O Space Enable
  mem_ena       = cmd_reg1;   -- Memory Space Enable
  mstr_ena      = cmd_reg2;   -- Bus Master Enable
  mwi_ena       = cmd_reg4;   -- Memory Write and Invalidate Enable
  perr_ena      = cmd_reg6;   -- Pariy Error Response Enable 
  serr_ena      = cmd_reg8;   -- SERR Enable
  intr_disable  = cmd_reg10;   -- interrupt disable

  -- Status Register Local Side Outputs
  intr_stat     = stat_reg3;  -- Interrupt Status
  perr_rep      = stat_reg8;  -- Data Parity Error Signaled
  tabrt_sig     = stat_reg11; -- Signaled Target Abort
  tabrt_rcvd    = stat_reg12; -- Recieved Target Abort
  mabrt_rcvd    = stat_reg13; -- Recieved Master Abort
  serr_sig      = stat_reg14; -- Signaled SERR
  perr_det      = stat_reg15; -- Detected Parity Error

  lat_dat[7..0]   = lat_tmr[7..0];  -- Latency Timer Register Output Data
  cache_dat[7..0]   = cache_line[7..0];-- Cache Line Register Output Data

    
    ASSERT (NUMBER_OF_BARS >=1) 
    REPORT "NUMBER_OF_BARS = %, You must Instantiate at least one Base Address Register" NUMBER_OF_BARS
    SEVERITY ERROR;
          
    no_op[207..0] = no_op[] or cfg_dat_in_a[207..0];
    no_op[183..0]   = cfg_dat_in_b[183..0];
    no_op[191..0] = cfg_dat_in_c[191..0];
    no_op[31..0]= no_op[31..0] or ad_IR[] or adr_dec_ena OR lcfg_dat_in[] or ad_ir_addr[];
    no_op[15..0]  = stat_set[15..0] or sec_stat_set_in[15..0]or cfg_adr_selR[15..0];
    no_op[7..0] = lcfg_adr[7..0];
    no_op[5..0] = cfg_adr_dec_tmp_node[5..0];
    no_op[3..0] = lcfg_ben[3..0] OR cben_IR[3..0] or cben_ir_addr[3..0]
          or bar_nibble0[]
          or bar_nibble1[]
          or bar_nibble2[]
          or bar_nibble3[]
          or bar_nibble4[]
          or bar_nibble5[] ;
    no_op0    = no_op0 or lcfg_dat_vld or lcfg_adr_vld or cfg_dat_vld
          OR io_access_enable
          OR mem_access_enable
          or io_cyc
          or exp_rom_access 
          OR  dac_cfg
          OR  dac_cmd   ;
    IF (HARDWIRE_HB_ENA == H"0") GENERATE
        no_op[] = no_op[];
    ELSE GENERATE 
      Assert Report "Local Host Interface is Enabled"
      Severity INFO;
    END GENERATE;
    
    dac_cmd = (cben_IR_addr[3..0]==B"1101");
  ---  To support interrupt acknowledge command for the 32-bit.
    IF ( INTERRUPT_ACK_ENA == 0 ) GENERATE
      mem_cyc   =   ( cben_IR_addr[3..1] == B"011")
            or  ( cben_IR_addr[3..0] == B"1100")
            or  ( cben_IR_addr[3..1] == B"111");
    ELSE GENERATE
      mem_cyc   =   ( cben_IR_addr[3..1] == B"011"  )
            or  ( cben_IR_addr[3..0] == B"1100")
            or  ( cben_IR_addr[3..0] == B"0000")
            or  ( cben_IR_addr[3..1] == B"111");
    END GENERATE; 

    IF (INTERRUPT_ACK_ENA == 0 ) GENERATE
      int_ack_hit   = GND;
    ELSE GENERATE
      int_ack_hit   = LCELL ( adr_phase AND ( cben_IR_addr[3..0] == B"0000"));
    END GENERATE;

  -- IO CYCLE
    io_cyc  = (cben_IR_addr[3..1] == B"001");
  -- BAR NIBBLE 
    bar_nibble0[3..0] = BAR0_LS_NIBBLE;
    bar_nibble1[3..0] = BAR1_LS_NIBBLE;
    bar_nibble2[3..0] = BAR2_LS_NIBBLE;
    bar_nibble3[3..0] = BAR3_LS_NIBBLE;
    bar_nibble4[3..0] = BAR4_LS_NIBBLE;
    bar_nibble5[3..0] = BAR5_LS_NIBBLE;
    base_hit[5..0]    = bar_hitR[5..0]; -- Base Address Hit Signals
  -- MEMORY/IO ENABLE
    mem_access_enable   = cmd_reg1;
    io_access_enable    = cmd_reg0;
  -- mbar_hit
    % mbar_hit      =   ( bar_hit[0] )
                  or  ( bar_hit[1] )
                  or  ( bar_hit[2] )
                  or  ( bar_hit[3] )
                  or  ( bar_hit[4] )
                  or  ( bar_hit[5] )
                  or  exp_rom_access;
                  
    %


        int_ack_hit_cc = NOT int_ack_hit;
        bar3_cc        = NOT (bar_hit[3] OR int_ack_hit);
        bar34_cc       = NOT (bar_hit[3] or bar_hit[4] or int_ack_hit);
        bar4_cc        = NOT (bar_hit[4] OR int_ack_hit);
        bar345_cc      = NOT (bar_hit[3] OR bar_hit[4] OR bar_hit[5] OR int_ack_hit);
        bar45_cc       = NOT (bar_hit[4] OR bar_hit[5] OR int_ack_hit);
     

        
    IF (NUMBER_OF_BARS == 1) GENERATE
      IF(EXP_ROM_ENA == 1) GENERATE
        mbar_hit = LCELL(int_ack_hit OR exp_rom_access or bar_hit[0]);
      ELSE GENERATE
        mbar_hit =  LCELL(int_ack_hit OR bar_hit[0]);
      END GENERATE;
    END GENERATE;
    
    IF (NUMBER_OF_BARS == 2) GENERATE
      IF (BAR0_MEM_LOC != 2) GENERATE -- 32-Bit BAR0, BAR1
        IF(EXP_ROM_ENA == 1) GENERATE
          mbar_hit = LCELL(int_ack_hit OR exp_rom_access or bar_hit[0] or bar_hit[1]);
        ELSE GENERATE
          mbar_hit = LCELL(int_ack_hit OR bar_hit[0] or bar_hit[1]);
        END GENERATE;
      ELSE GENERATE -- 64-BIT BAR0
        IF(EXP_ROM_ENA == 1) GENERATE
          mbar_hit = LCELL(int_ack_hit OR exp_rom_access OR bar_hit[1]);
        ELSE GENERATE
          mbar_hit = LCELL(int_ack_hit OR bar_hit[1]);
        END GENERATE;
      END GENERATE;
    END GENERATE;
    
    IF (NUMBER_OF_BARS == 3) GENERATE
      IF (BAR0_MEM_LOC != 2)  GENERATE  -- 32-Bit BAR1
        IF (BAR1_MEM_LOC < 2) GENERATE -- 32-Bit BAR1
          IF(EXP_ROM_ENA == 1) GENERATE
            mbar_hit = NOT  ( ( NOT (exp_rom_access or bar_hit[0] or bar_hit[1] OR bar_hit[2])
                                AND int_ack_hit_cc
                        )
                    );
          ELSE GENERATE
            mbar_hit = LCELL(bar_hit[0] or bar_hit[1] OR bar_hit[2] OR int_ack_hit);
          END GENERATE;
        ELSE GENERATE -- 64-Bit BAR1
          IF(EXP_ROM_ENA == 1) GENERATE
            mbar_hit = NOT  ( ( NOT (exp_rom_access or bar_hit[0] or bar_hit[2])
                        AND int_ack_hit_cc
                        )
                    );
          ELSE GENERATE
            mbar_hit = LCELL(bar_hit[0] or bar_hit[2] OR int_ack_hit);
          END GENERATE;
        END GENERATE;
      ELSE GENERATE -- 64-Bit BAR0
        IF(EXP_ROM_ENA == 1) GENERATE
          mbar_hit =  NOT   ( ( NOT (exp_rom_access or bar_hit[1] OR bar_hit[2])
                        AND int_ack_hit_cc
                        )
                    );
        ELSE GENERATE
          mbar_hit = LCELL(bar_hit[1] OR bar_hit[2] OR int_ack_hit);
        END GENERATE;
      END GENERATE;
    END GENERATE;
    
    IF (NUMBER_OF_BARS == 4) GENERATE
      IF (BAR0_MEM_LOC < 2) GENERATE  -- 32-Bit BAR1
        IF (BAR1_MEM_LOC < 2) GENERATE -- 32-Bit BAR1
          IF(EXP_ROM_ENA == 1) GENERATE
            mbar_hit = NOT (    ( NOT (exp_rom_access or bar_hit[0] or bar_hit[1] OR bar_hit[2])
                          AND bar3_cc
                                )
                          
                    );
          ELSE GENERATE
            mbar_hit = NOT  (   ( NOT (bar_hit[0] or bar_hit[1] OR bar_hit[2] OR bar_hit[3])
                          AND int_ack_hit_cc
                          )
                    );
          END GENERATE;
        ELSE GENERATE -- 64-Bit BAR1
          IF(EXP_ROM_ENA == 1) GENERATE
            mbar_hit = NOT  (   ( NOT (exp_rom_access or bar_hit[0] or bar_hit[2])
                          AND bar3_cc
                                )
                          
                    );
          ELSE GENERATE
            mbar_hit = NOT  (   ( NOT (bar_hit[0] or bar_hit[2] OR bar_hit[3])
                          AND int_ack_hit_cc
                          )
                    );
          END GENERATE;
        END GENERATE;
      ELSE GENERATE -- 64-Bit BAR0
        IF(EXP_ROM_ENA == 1) GENERATE
          mbar_hit = NOT  (   ( NOT (exp_rom_access or bar_hit[1] OR bar_hit[2])
                        AND bar3_cc
                              )
                        
                  );
        ELSE GENERATE
          mbar_hit = NOT  (   ( NOT (bar_hit[1] OR bar_hit[2] OR bar_hit[3])
                        AND int_ack_hit_cc
                        )
                  );
        END GENERATE;
      END GENERATE;
    END GENERATE;
    
      
    IF (NUMBER_OF_BARS == 5) GENERATE
      IF (BAR0_MEM_LOC < 2) GENERATE  -- 32-Bit BAR1
        IF (BAR1_MEM_LOC < 2) GENERATE -- 32-Bit BAR1
          IF(EXP_ROM_ENA == 1) GENERATE
            mbar_hit = NOT (    ( NOT (exp_rom_access or bar_hit[0] or bar_hit[1] OR bar_hit[2])
                          AND bar34_cc                          )
                    );
          ELSE GENERATE
            mbar_hit = NOT  (   ( NOT (bar_hit[0] or bar_hit[1] OR bar_hit[2] OR bar_hit[3])
                          AND bar4_cc
                          )
                    );
          END GENERATE;
        ELSE GENERATE -- 64-Bit BAR1
          IF(EXP_ROM_ENA == 1) GENERATE
            mbar_hit = NOT  (   ( NOT (exp_rom_access or bar_hit[0] or bar_hit[2])
                          AND bar34_cc                          )
                    );
          ELSE GENERATE
            mbar_hit = NOT  (   ( NOT (bar_hit[0] or bar_hit[2] OR bar_hit[3])
                          AND bar4_cc                         )
                    );
          END GENERATE;
        END GENERATE;
      ELSE GENERATE -- 64-Bit BAR0
        IF(EXP_ROM_ENA == 1) GENERATE
          mbar_hit = NOT  (   ( NOT (exp_rom_access or bar_hit[1] OR bar_hit[2])
                        AND bar34_cc                        )
                  );
        ELSE GENERATE
          mbar_hit = NOT  (   ( NOT (bar_hit[1] OR bar_hit[2] OR bar_hit[3])
                        AND bar4_cc                       )
                  );
        END GENERATE;
      END GENERATE;
    END GENERATE;
          
        
    IF (NUMBER_OF_BARS == 6) GENERATE
      IF (BAR0_MEM_LOC < 2) GENERATE  -- 32-Bit BAR1
        IF (BAR1_MEM_LOC < 2) GENERATE -- 32-Bit BAR1
          IF(EXP_ROM_ENA == 1) GENERATE
            mbar_hit = NOT (    ( NOT (exp_rom_access or bar_hit[0] or bar_hit[1] OR bar_hit[2])
                          AND bar345_cc
                          )
                    );
          ELSE GENERATE
            mbar_hit = NOT  (   ( NOT (bar_hit[0] or bar_hit[1] OR bar_hit[2] OR bar_hit[3])
                          AND bar45_cc
                          )
                    );
          END GENERATE;
        ELSE GENERATE -- 64-Bit BAR1
          IF(EXP_ROM_ENA == 1) GENERATE
            mbar_hit = NOT  (   ( NOT (exp_rom_access or bar_hit[0] or bar_hit[2])
                          AND bar345_cc
                          )
                    );
          ELSE GENERATE
            mbar_hit = NOT  (   ( NOT (bar_hit[0] or bar_hit[2] OR bar_hit[3])
                          AND bar45_cc                          )
                    );
          END GENERATE;
        END GENERATE;
      ELSE GENERATE -- 64-Bit BAR0
        IF(EXP_ROM_ENA == 1) GENERATE
          mbar_hit = NOT  (   ( NOT (exp_rom_access or bar_hit[1] OR bar_hit[2])
                        AND bar345_cc                       )
                  );
        ELSE GENERATE
          mbar_hit = NOT  (   ( NOT (bar_hit[1] OR bar_hit[2] OR bar_hit[3])
                        AND bar45_cc
                        )
                  );
        END GENERATE;
      END GENERATE;
    END GENERATE;
                
        
    mem_bar_hit     = mbar_hit;

  -- Configuration Address Decoder
    cfg_adr_dec.clk     = clk;
    cfg_adr_dec.rstn    = rstn; 
    IF (LOCAL_CONFIG_ENA == "NO") GENERATE
      cfg_adr_dec.ena     = adr_dec_ena;
      cfg_adr_dec.adr[7..0] = ad_IR_addr[7..0];
    ELSE GENERATE
      cfg_adr_dec.ena     = lcfg_adr_vld;
      cfg_adr_dec.adr[7..0] = lcfg_adr[7..0]; 
    END GENERATE;
    cfg_adr_selR[15..0]   = cfg_adr_dec.selR[15..0];
    cfg_adr_dec_tmp_node[0] = cfg_adr_dec.selR4;
    cfg_adr_dec_tmp_node[1] = cfg_adr_dec.selR5;
    cfg_adr_dec_tmp_node[2] = cfg_adr_dec.selR6;
    cfg_adr_dec_tmp_node[3] = cfg_adr_dec.selR7;
    cfg_adr_dec_tmp_node[4] = cfg_adr_dec.selR8;
    cfg_adr_dec_tmp_node[5] = cfg_adr_dec.selR9;

---- BAR0: 32-BIT BAR and 64-BIT BAR --------------------------------------------------------------
    IF (NUMBER_OF_BARS >= 1+0) GENERATE
      -- Check and REPORT value supplied for BAR0 
      IF (BAR0_TYPE == 1) GENERATE    -- I/O BAR
        
        --IF (BAR0_MEM_LOC == 0 and BAR0_PREFETCH == 0 ) GENERATE 
          ASSERT REPORT "BAR0 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = I/O"
            32-BAR0_READ_ONLY_BITS, CEIL(2^BAR0_READ_ONLY_BITS)
          SEVERITY INFO;
        --ELSE GENERATE 
       --   ASSERT REPORT " Illegal Value [%] for BAR0 Parameter" BAR0
       --     SEVERITY ERROR;
        --END GENERATE;
      
      ELSE GENERATE -- MEMORY BAR
      -- 32-BIT BAR: NON-PREFETCHABLE 
        IF (BAR0_MEM_LOC == 0 and BAR0_PREFETCH == 0 ) GENERATE
          IF (BAR0_OVFL_N == 0) GENERATE -- size = 2 GBytes
            ASSERT REPORT "BAR0 Settings: Number of Address Bits Decoded = %, Size = 2 GBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Non-Prefetchable"
              32-BAR0_READ_ONLY_BITS 
            SEVERITY INFO;
          ELSE GENERATE         -- BAR0 is less than 2 GBytes   
            IF (CEIL(2^BAR0_READ_ONLY_BITS) >=   1073741824) GENERATE -- Size is 1 GBytes 
              ASSERT REPORT "BAR0 Settings: Number of Address Bits Decoded = %, Size = % GBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Non-Prefetchable"
                32-BAR0_READ_ONLY_BITS, (2^BAR0_READ_ONLY_BITS) DIV  1073741824
              SEVERITY INFO;
            END GENERATE;
            IF (CEIL(2^BAR0_READ_ONLY_BITS) >=  1048576 and (CEIL(2^BAR0_READ_ONLY_BITS) <   1073741824)) GENERATE -- Size >= 1 MBytes < 1 GBytes
              ASSERT REPORT "BAR0 Settings: Number of Address Bits Decoded = %, Size = % MBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Non-Prefetchable"
                32-BAR0_READ_ONLY_BITS, CEIL(2^BAR0_READ_ONLY_BITS) DIV 1048576 
              SEVERITY INFO;
            END GENERATE;
            IF((CEIL(2^BAR0_READ_ONLY_BITS) >= 1024)  and (CEIL(2^BAR0_READ_ONLY_BITS) < 1048576)) GENERATE -- Size >= 1 KBytes < 1 MBytes
              ASSERT REPORT "BAR0 Settings: Number of Address Bits Decoded = %, Size = % KBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Non-Prefetchable"
                32-BAR0_READ_ONLY_BITS, CEIL(2^BAR0_READ_ONLY_BITS) DIV 1024
              SEVERITY INFO;
            END GENERATE;
            IF (CEIL(2^BAR0_READ_ONLY_BITS) < 1024) GENERATE -- size < 1 KBytes
              ASSERT REPORT "BAR0 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Non-Prefetchable"
                32-BAR0_READ_ONLY_BITS, CEIL(2^BAR0_READ_ONLY_BITS)
              SEVERITY INFO;
            END GENERATE;
          END GENERATE; 
        END GENERATE;   
      -- 32-BIT BAR: PREFETCHABLE 
        IF (BAR0_MEM_LOC == 0 and BAR0_PREFETCH == 1 ) GENERATE
          IF (BAR0_OVFL_N == 0) GENERATE
            ASSERT REPORT "BAR0 Settings: Number of Address Bits Decoded = %, Size = 2 GBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Prefetchable"
              32-BAR0_READ_ONLY_BITS 
            SEVERITY INFO;
          ELSE GENERATE     
            IF (CEIL(2^BAR0_READ_ONLY_BITS) >=   1073741824) GENERATE
              ASSERT REPORT "BAR0 Settings: Number of Address Bits Decoded = %, Size = % GBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Prefetchable"
                32-BAR0_READ_ONLY_BITS, CEIL(2^BAR0_READ_ONLY_BITS) DIV  1073741824
              SEVERITY INFO;
            END GENERATE;
            IF (CEIL(2^BAR0_READ_ONLY_BITS) >=  1048576 and (CEIL(2^BAR0_READ_ONLY_BITS) <   1073741824)) GENERATE
              ASSERT REPORT "BAR0 Settings: Number of Address Bits Decoded = %, Size = % MBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Prefetchable"
                32-BAR0_READ_ONLY_BITS, CEIL(2^BAR0_READ_ONLY_BITS) DIV 1048576 
              SEVERITY INFO;
            END GENERATE;
            IF((CEIL(2^BAR0_READ_ONLY_BITS) >= 1024)  and (CEIL(2^BAR0_READ_ONLY_BITS) < 1048576)) GENERATE
              ASSERT REPORT "BAR0 Settings: Number of Address Bits Decoded = %, Size = % KBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Prefetchable"
                32-BAR0_READ_ONLY_BITS, CEIL(2^BAR0_READ_ONLY_BITS) DIV 1024
              SEVERITY INFO;
            END GENERATE;
            IF (CEIL(2^BAR0_READ_ONLY_BITS) < 1024) GENERATE
              ASSERT REPORT "BAR0 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Prefetchable"
                32-BAR0_READ_ONLY_BITS, CEIL(2^BAR0_READ_ONLY_BITS)
              SEVERITY INFO;
            END GENERATE;   
          END GENERATE;
        END GENERATE;
      -- 32-BIT BAR: 1 MEG SPACE NON-PREFETCHABLE *** Rev 2.2 Makes this illegal
        IF(BAR0_MEM_LOC == 1 and BAR0_PREFETCH == 0 ) GENERATE
          IF (BAR0_OVFL_N == 0) GENERATE
            ASSERT REPORT "Error:  The value for BAR0 parameter is incorrect; The allocated memory [2 GBytes] cannot be located below 1 Meg Space." 
            SEVERITY Error;
          ELSE GENERATE     
            IF (CEIL(2^BAR0_READ_ONLY_BITS) >=   1073741824) GENERATE
              ASSERT REPORT "Error:  The value for BAR0 parameter is incorrect; The allocated memory [% GBytes] cannot be located below 1 Meg Space."  CEIL(2^BAR0_READ_ONLY_BITS) DIV  1073741824
              SEVERITY Error;
            END GENERATE;
            IF (CEIL(2^BAR0_READ_ONLY_BITS) >=  1048576 and (CEIL(2^BAR0_READ_ONLY_BITS) <   1073741824)) GENERATE
              ASSERT REPORT "Error:  The value for BAR0 parameter is incorrect; The allocated memory [% MBytes] cannot be located below 1 Meg Space."  CEIL(2^BAR0_READ_ONLY_BITS) DIV 1048576 
              SEVERITY error;
            END GENERATE;
            IF((CEIL(2^BAR0_READ_ONLY_BITS) >= 1024)  and (CEIL(2^BAR0_READ_ONLY_BITS) < 1048576)) GENERATE
              ASSERT REPORT "BAR0 Settings: Number of Address Bits Decoded = %, Size = % KBytes, Type = Memory, Location = Below 1 Meg Space, Non-Prefetchable"
                32-BAR0_READ_ONLY_BITS, CEIL(2^BAR0_READ_ONLY_BITS) DIV 1024
              SEVERITY INFO;
            END GENERATE;
            IF (CEIL(2^BAR0_READ_ONLY_BITS) < 1024) GENERATE
              ASSERT REPORT "BAR0 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = Memory, Location = Below 1 Meg Space, Non-Prefetchable"
                32-BAR0_READ_ONLY_BITS, CEIL(2^BAR0_READ_ONLY_BITS)
              SEVERITY INFO;
            END GENERATE;
          END GENERATE;
        END GENERATE;
      -- 32-BIT BAR: 1 MEG SPACE PREFETCHABLE
        IF (BAR0_MEM_LOC == 1 and BAR0_PREFETCH == 1 ) GENERATE
          IF (BAR0_OVFL_N == 0) GENERATE
            ASSERT REPORT "Error:  The value for BAR0 parameter is incorrect; The allocated memory [2 GBytes] cannot be located below 1 Meg Space." 
            SEVERITY Error;
          ELSE GENERATE   
            IF (CEIL(2^BAR0_READ_ONLY_BITS) >=   1073741824) GENERATE
              ASSERT REPORT "Error:  The value for BAR0 parameter is incorrect; The allocated memory [% GBytes] cannot be located below 1 Meg Space."  CEIL(2^BAR0_READ_ONLY_BITS) DIV  1073741824
              SEVERITY Error;
            END GENERATE;
            IF (CEIL(2^BAR0_READ_ONLY_BITS) >=  1048576 and (CEIL(2^BAR0_READ_ONLY_BITS) <   1073741824)) GENERATE
              ASSERT REPORT "Error:  The value for BAR0 parameter is incorrect; The allocated memory [% MBytes] cannot be located below 1 Meg Space."  CEIL(2^BAR0_READ_ONLY_BITS) DIV 1048576 
              SEVERITY error;
            END GENERATE;
            IF((CEIL(2^BAR0_READ_ONLY_BITS) >= 1024)  and (CEIL(2^BAR0_READ_ONLY_BITS) < 1048576)) GENERATE
              ASSERT REPORT "BAR0 Settings: Number of Address Bits Decoded = %, Size = % KBytes, Type = Memory, Location = Below 1 Meg Space, Prefetchable"
                32-BAR0_READ_ONLY_BITS, CEIL(2^BAR0_READ_ONLY_BITS) DIV 1024
              SEVERITY INFO;
            END GENERATE;
            IF (CEIL(2^BAR0_READ_ONLY_BITS) < 1024) GENERATE
              ASSERT REPORT "BAR0 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = Memory, Location = Below 1 Meg Space, Prefetchable"
                32-BAR0_READ_ONLY_BITS, CEIL(2^BAR0_READ_ONLY_BITS)
              SEVERITY INFO;
            END GENERATE;   
          END GENERATE;
        END GENERATE;
      -- 64-BIT BAR: NON-PREFETCHABLE
        IF (BAR0_MEM_LOC == 2 and BAR0_PREFETCH == 0 ) GENERATE
          IF (BAR0_READ_ONLY_BITS_64 < 32) GENERATE -- 64-Bit BAR size <= 2 GBytes
            IF (BAR0_OVFL_N == 0) GENERATE
              ASSERT REPORT "64-Bit BAR Using BAR1,0 Settings: Number of Address Bits Decoded = %, Size = 2 GBytes, Type = Memory, Location = Anywhere in the 64 Bit address Space, Non-Prefetchable"
              BAR0_READ_WRITE_BITS_64 
              SEVERITY INFO;
            ELSE GENERATE       
              IF (CEIL(2^BAR0_READ_ONLY_BITS) >=   1073741824) GENERATE
                ASSERT REPORT "64-Bit BAR Using BAR1,0 Settings: Number of Address Bits Decoded = %, Size = % GBytes, Type = Memory, Location = Anywhere in the 64 Bit address Space, Non-Prefetchable"
                  BAR0_READ_WRITE_BITS_64 , (2^BAR0_READ_ONLY_BITS) DIV  1073741824
                SEVERITY INFO;
              END GENERATE;
              IF (CEIL(2^BAR0_READ_ONLY_BITS) >=  1048576 and (CEIL(2^BAR0_READ_ONLY_BITS) <   1073741824)) GENERATE
                ASSERT REPORT "64-Bit BAR Using BAR1,0 Settings: Number of Address Bits Decoded = %, Size = % MBytes, Type = Memory, Location = Anywhere in the 64 Bit address Space, Non-Prefetchable"
                  BAR0_READ_WRITE_BITS_64 , CEIL(2^BAR0_READ_ONLY_BITS) DIV 1048576 
                SEVERITY INFO;
              END GENERATE;
              IF((CEIL(2^BAR0_READ_ONLY_BITS) >= 1024)  and (CEIL(2^BAR0_READ_ONLY_BITS) < 1048576)) GENERATE
                ASSERT REPORT "64-Bit BAR Using BAR1,0 Settings: Number of Address Bits Decoded = %, Size = % KBytes, Type = Memory, Location = Anywhere in the 64 Bit address Space, Non-Prefetchable"
                  BAR0_READ_WRITE_BITS_64 , CEIL(2^BAR0_READ_ONLY_BITS) DIV 1024
                SEVERITY INFO;
              END GENERATE;
              IF (CEIL(2^BAR0_READ_ONLY_BITS) < 1024) GENERATE
                ASSERT REPORT "64-Bit BAR Using BAR1,0 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = Memory, Location = Anywhere in the 64 Bit address Space, Non-Prefetchable"
                  BAR0_READ_WRITE_BITS_64 , CEIL(2^BAR0_READ_ONLY_BITS)
                SEVERITY INFO;
              END GENERATE;
            END GENERATE;     
          ELSE GENERATE     -- 64-Bit BAR Size > 2 GBytes
            
          -- BAR0 READ_ONLY_BITS == 32: BAR0==H"00000004(C)"

            IF (BAR1_OVFL_N == 0) GENERATE
              ASSERT REPORT "64-Bit BAR Using BAR1,0 Settings: Number of Address Bits Decoded = %, Size = 8589934592 GBytes, Type = Memory, Location = Anywhere in the 64 Bit address Space, Non-Prefetchable"
                BAR0_READ_WRITE_BITS_64 
              SEVERITY INFO;
            ELSE GENERATE
              IF (BAR1_READ_ONLY_BITS_64 == 30) GENERATE
                ASSERT REPORT "64-Bit BAR Using BAR1,0 Settings: Number of Address Bits Decoded = %, Size = 4294967296  GBytes, Type = Memory, Location = Anywhere in the 64 Bit address Space, Non-Prefetchable"
                  BAR0_READ_WRITE_BITS_64 -- 2^62
                SEVERITY INFO;
              END GENERATE;   
              IF (BAR1_READ_ONLY_BITS_64 == 29) GENERATE
                ASSERT REPORT "64-Bit BAR Using BAR1,0 Settings: Number of Address Bits Decoded = %, Size = 2147483648 GBytes, Type = Memory, Location = Anywhere in the 64 Bit address Space, Non-Prefetchable"
                  BAR0_READ_WRITE_BITS_64 -- 2^61
                SEVERITY INFO;
              END GENERATE;     
              IF (BAR1_READ_ONLY_BITS_64 <= 28) GENERATE
                ASSERT REPORT "64-Bit BAR Using BAR1,0 Settings: Number of Address Bits Decoded = %, Size =  % GBytes, Type = Memory, Location = Anywhere in the 64 Bit address Space, Non-Prefetchable"
                  BAR0_READ_WRITE_BITS_64, (2^(MAX_64_BAR_RW_BITS-BAR1_READ_WRITE_BITS) * 4)  -- 2^60
                SEVERITY INFO;
              END GENERATE;   
            END GENERATE;

            
          END GENERATE; -- END OF BAR0==H"00000004(C)"    
        END GENERATE;
      -- 64-BIT BAR: PREFETCHABLE
        IF (BAR0_MEM_LOC == 2 and BAR0_PREFETCH == 1 ) GENERATE
          IF (BAR0_READ_ONLY_BITS_64 < 32) GENERATE
            IF (BAR0_OVFL_N == 0) GENERATE
              ASSERT REPORT "64-Bit BAR Using BAR1,0 Settings: Number of Address Bits Decoded = %, Size = 2 GBytes, Type = Memory, Location = Anywhere in the 64 Bit address Space, Prefetchable"
                BAR0_READ_WRITE_BITS_64 
              SEVERITY INFO;
            ELSE GENERATE       
              IF (CEIL(2^BAR0_READ_ONLY_BITS) >=   1073741824) GENERATE
                ASSERT REPORT "64-Bit BAR Using BAR1,0 Settings: Number of Address Bits Decoded = %, Size = % GBytes, Type = Memory, Location = Anywhere in the 64 Bit address Space, Prefetchable"
                  BAR0_READ_WRITE_BITS_64 , (2^BAR0_READ_ONLY_BITS) DIV  1073741824
                SEVERITY INFO;
              END GENERATE;
              IF (CEIL(2^BAR0_READ_ONLY_BITS) >=  1048576 and (CEIL(2^BAR0_READ_ONLY_BITS) <   1073741824)) GENERATE
                ASSERT REPORT "64-Bit BAR Using BAR1,0 Settings: Number of Address Bits Decoded = %, Size = % MBytes, Type = Memory, Location = Anywhere in the 64 Bit address Space, Prefetchable"
                  BAR0_READ_WRITE_BITS_64 , CEIL(2^BAR0_READ_ONLY_BITS) DIV 1048576 
                SEVERITY INFO;
              END GENERATE;
              IF((CEIL(2^BAR0_READ_ONLY_BITS) >= 1024)  and (CEIL(2^BAR0_READ_ONLY_BITS) < 1048576)) GENERATE
                ASSERT REPORT "64-Bit BAR Using BAR1,0 Settings: Number of Address Bits Decoded = %, Size = % KBytes, Type = Memory, Location = Anywhere in the 64 Bit address Space, Prefetchable"
                  BAR0_READ_WRITE_BITS_64 , CEIL(2^BAR0_READ_ONLY_BITS) DIV 1024
                SEVERITY INFO;
              END GENERATE;
              IF (CEIL(2^BAR0_READ_ONLY_BITS) < 1024) GENERATE
                ASSERT REPORT "64-Bit BAR Using BAR1,0 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = Memory, Location = Anywhere in the 64 Bit address Space, Prefetchable"
                  BAR0_READ_WRITE_BITS_64 , CEIL(2^BAR0_READ_ONLY_BITS)
                SEVERITY INFO;
              END GENERATE;
            END GENERATE;
          ELSE GENERATE
          -- BAR0_READ_ONLY_BITS==32: BAR0=H"00000004(C)"

            IF (BAR1_OVFL_N == 0) GENERATE
              ASSERT REPORT "64-Bit BAR Using BAR1,0 Settings: Number of Address Bits Decoded = %, Size = 8589934592 GBytes, Type = Memory, Location = Anywhere in the 64 Bit address Space, Prefetchable"
                BAR0_READ_WRITE_BITS_64 
              SEVERITY INFO;
            ELSE GENERATE
              IF (BAR1_READ_ONLY_BITS_64 == 30) GENERATE
                ASSERT REPORT "64-Bit BAR Using BAR1,0 Settings: Number of Address Bits Decoded = %, Size = 4294967296  GBytes, Type = Memory, Location = Anywhere in the 64 Bit address Space, Prefetchable"
                  BAR0_READ_WRITE_BITS_64 -- 2^62
                SEVERITY INFO;
              END GENERATE;   
              IF (BAR1_READ_ONLY_BITS_64 == 29) GENERATE
                ASSERT REPORT "64-Bit BAR Using BAR1,0 Settings: Number of Address Bits Decoded = %, Size = 2147483648 GBytes, Type = Memory, Location = Anywhere in the 64 Bit address Space, Prefetchable"
                  BAR0_READ_WRITE_BITS_64 -- 2^61
                SEVERITY INFO;
              END GENERATE;     
              IF (BAR1_READ_ONLY_BITS_64 <= 28) GENERATE
                ASSERT REPORT "64-Bit BAR Using BAR1,0 Settings: Number of Address Bits Decoded = %, Size =  % GBytes, Type = Memory, Location = Anywhere in the 64 Bit address Space, Prefetchable"
                  BAR0_READ_WRITE_BITS_64, (2^(MAX_64_BAR_RW_BITS-BAR1_READ_WRITE_BITS) * 4)  -- 2^60
                SEVERITY INFO;
              END GENERATE;   
            END GENERATE;

          END GENERATE; -- END OF BAR0==H"00000004(C)"    
        END GENERATE; -- END OF 64-BAR: PREFETCHABLE
      -- BAR0_MEM_LOC > 2
        IF (BAR0_MEM_LOC > 2) GENERATE
          ASSERT REPORT " Illegal Memory Type Value for BAR0 "
          SEVERITY ERROR;
        END GENERATE;     
      END GENERATE; -- END OF BAR0_TYPE==0: MEMORY 
---------------------------------------------------------------------------------------------------
      -- NO HARDWIRE BAR
      -- Write Enable Logic for BAR0 
      IF ( HARDWIRE_BAR0_ENA != 1 ) GENERATE  
        IF (BAR0_MEM_LOC < 2) GENERATE
          no_op[]       = no_op[] or bar0_ena3 or bar0_ena2 or bar0_ena1 or bar0_ena0;  
          IF (LOCAL_CONFIG_ENA == "NO") GENERATE
            bar0_ena[3..0]    = bar_selR[0] and cfg_dat_vld and not(cben_IR[3..0]); 
          ELSE  GENERATE
            bar0_ena[3..0]    = bar_selR[0] and lcfg_dat_vld and not lcfg_ben[3..0];
          END GENERATE;
            IF (BAR0_READ_ONLY_BITS > 4) GENERATE
            bar0_ro_bits[BAR0_RO_BITS_MAX..4]   = GND;      -- BAR0 Read Only Bits < 32
          END GENERATE;
        ELSE GENERATE -- 64-Bit BAR
          IF (BAR0_READ_ONLY_BITS_64 < 32) GENERATE -- if BAR0 Read Only Bits != 32 
            no_op[]       = no_op[] or bar0_ena3 or bar0_ena2 or bar0_ena1 or bar0_ena0;  
            IF (LOCAL_CONFIG_ENA == "NO") GENERATE
              bar0_ena[3..0]    = bar_selR[0] and cfg_dat_vld and not(cben_IR[3..0]); 
            ELSE  GENERATE
              bar0_ena[3..0]    = bar_selR[0] and lcfg_dat_vld and not lcfg_ben[3..0];
            END GENERATE;
            IF (BAR0_READ_ONLY_BITS > 4) GENERATE
              bar0_ro_bits[BAR0_RO_BITS_MAX..4]   = GND;      -- BAR0 Read Only Bits < 32
            END GENERATE;
          ELSE GENERATE
            bar0_ro_bits[BAR0_READ_ONLY_BITS_64-1..4]   = GND;      -- BAR0 Read Only Bits = 32
          END GENERATE;
        END GENERATE;
  
        bar_selR[0]     = cfg_adr_dec_tmp_node[0];  -- address decode 10h

    -- Set BAR0 R/W Registers Controls
      --32-BIT BAR: BAR0_REG ENABLE
    -- Read/Write Register for BAR0  
        IF (BAR0_MEM_LOC < 2) GENERATE
          bar0_reg[].clk  = clk ;
          bar0_reg[].clrn = rstN;
          IF (LOCAL_CONFIG_ENA == "NO") GENERATE
            bar0_reg[].d  = ad_IR[31..BAR0_READ_ONLY_BITS];
          ELSE  GENERATE
            bar0_reg[].d  = lcfg_dat_in[31..Bar0_Read_ONLY_BITS];
          END GENERATE;
          IF (BAR0_READ_ONLY_BITS < 8) GENERATE
            bar0_reg[31..24].ena            = bar0_ena[3];
            bar0_reg[23..16].ena            = bar0_ena[2];
            bar0_reg[15..8].ena             = bar0_ena[1];
            bar0_reg[7..BAR0_READ_ONLY_BITS].ena  = bar0_ena[0];
          ELSE GENERATE   
            IF (BAR0_READ_ONLY_BITS < 16) GENERATE    
              bar0_reg[31..24].ena            = bar0_ena[3];
              bar0_reg[23..16].ena            = bar0_ena[2];
              bar0_reg[15..BAR0_READ_ONLY_BITS].ena = bar0_ena[1];
            ELSE GENERATE       
              IF (BAR0_READ_ONLY_BITS < 24) GENERATE      
                bar0_reg[31..24].ena            = bar0_ena[3];
                bar0_reg[23..BAR0_READ_ONLY_BITS].ena = bar0_ena[2];      
              ELSE GENERATE     
                bar0_reg[31..BAR0_READ_ONLY_BITS].ena = bar0_ena[3];
              END GENERATE;
            END GENERATE;
          END GENERATE;
        ELSE GENERATE
      -- 64-BIT BAR
          IF (BAR0_READ_ONLY_BITS_64 < 32) GENERATE -- BAR0 Read Only Bits < 32
            bar0_reg[].clk  = clk ;
            bar0_reg[].clrn = rstN;
            IF (LOCAL_CONFIG_ENA == "NO") GENERATE
              bar0_reg[].d  = ad_IR[31..BAR0_READ_ONLY_BITS];
            ELSE  GENERATE
              bar0_reg[].d  = lcfg_dat_in[31..Bar0_Read_ONLY_BITS];
            END GENERATE;
            IF (BAR0_READ_ONLY_BITS < 8) GENERATE
              bar0_reg[31..24].ena            = bar0_ena[3];
              bar0_reg[23..16].ena            = bar0_ena[2];
              bar0_reg[15..8].ena             = bar0_ena[1];
              bar0_reg[7..BAR0_READ_ONLY_BITS].ena  = bar0_ena[0];
            ELSE GENERATE   
              IF (BAR0_READ_ONLY_BITS < 16) GENERATE    
                bar0_reg[31..24].ena            = bar0_ena[3];
                bar0_reg[23..16].ena            = bar0_ena[2];
                bar0_reg[15..BAR0_READ_ONLY_BITS].ena = bar0_ena[1];
              ELSE GENERATE       
                IF (BAR0_READ_ONLY_BITS < 24) GENERATE      
                  bar0_reg[31..24].ena            = bar0_ena[3];
                  bar0_reg[23..BAR0_READ_ONLY_BITS].ena = bar0_ena[2];      
                ELSE GENERATE     
                  bar0_reg[31..BAR0_READ_ONLY_BITS].ena = bar0_ena[3];
                END GENERATE;
              END GENERATE;
            END GENERATE;
          END GENERATE;
        END GENERATE; -- END OF 64-BIT BAR0_REG ENABLE  
      
      -- Set the 32 bit value of BAR0
      -- This was added because I/O Base Address register can have only 16 bytes available
        IF (BAR0_MEM_LOC < 2) GENERATE
            IF (BAR0_READ_ONLY_BITS > 4) GENERATE
              bar_0[] = (bar0_reg[],bar0_ro_bits[BAR0_RO_BITS_MAX..4],(bar_nibble0[]));
            ELSE GENERATE
                IF (BAR0_READ_ONLY_BITS < 3) GENERATE
                  bar_0[] = (bar0_reg[],(bar_nibble0[1..0]));
                ELSE GENERATE
                    IF (BAR0_READ_ONLY_BITS < 4) GENERATE
                      bar_0[] = (bar0_reg[],(bar_nibble0[2..0]));
                    ELSE GENERATE
                      bar_0[] = (bar0_reg[],(bar_nibble0[3..0]));
                    END GENERATE;   
                END GENERATE;   
            END GENERATE;   
        ELSE GENERATE -- 64-Bit BAR
          IF (BAR0_READ_ONLY_BITS_64 < 32) GENERATE
            IF (BAR0_READ_ONLY_BITS > 4) GENERATE
              bar_0[] = (bar0_reg[],bar0_ro_bits[BAR0_RO_BITS_MAX..4],(bar_nibble0[]));
            ELSE GENERATE
              bar_0[] = (bar0_reg[],(bar_nibble0[1..0]));
            END GENERATE;
          ELSE GENERATE
            bar_0[] = (bar0_ro_bits[BAR0_READ_ONLY_BITS_64-1..4],(bar_nibble0[]));
          END GENERATE;
        END GENERATE;
        
      -- Connect The Ports of BAR0 Address Comparator 
      -- If BAR0=H"00000004(C)", READ_ONLY_BITS is greater than or equal to 32.  Therefore, only bar_hit[1] should be evaluated.
        IF (BAR0_MEM_LOC < 2) GENERATE
          bar0_comp.dataa[] = bar0_reg[] ;
          bar0_comp.datab[] = ad_IR_addr[31 .. BAR0_READ_ONLY_BITS];  -- Only Upper Most Address Bits are Decoded
          
          cyc_vld[0]      =   (NOT bar_nibble0[0] and mem_cyc and mem_access_enable)
                    OR  (bar_nibble0[0] and io_cyc and io_access_enable) ;
                        
          bar_hit[0]      = LCELL(bar0_comp.aeb and adr_phase and cyc_vld[0]);

        ELSE GENERATE
          no_op0  = no_op0 or cyc_vld[0] or alz_bar1_64;
        
          
          IF (BAR0_READ_ONLY_BITS_64 < 32) GENERATE
            bar0_comp.dataa[] = bar0_reg[] ;
            bar0_comp.datab[] = ad_IR_addr[31 .. BAR0_READ_ONLY_BITS];  -- Only Upper Most Address Bits are Decoded
            -- Cycle checkes if bar1 is all zero then only bar_hit0 is enough for the cycle to be claimed
            -- If bar1 is not all 0 then both bar_hit0 and bar_hit1 must be true for the cycle to be claimed
            cyc_vld[0]      = (NOT bar_nibble0[0] and mem_access_enable and   ( ( (cben_ir_addr[3..0] == B"1101") and not alz_bar1_64)
                                                OR  (mem_cyc and alz_bar1_64)
                                                ));
            bar_hit[0]      = LCELL(bar0_comp.aeb and adr_phase and cyc_vld[0]);
          ELSE GENERATE
            bar_hit[0]      = adr_phase and dac_cmd;
            cyc_vld[0]      = GND;
          END GENERATE;   
        END GENERATE;

      -- Set BAR0 Address Compare Hit Register Controls
        bar_hitR[0].clk   = clk;
        bar_hitR[0].clrn  = rstN;             
        bar_hitR[0].r   = bar_hit_rst;
        bar_hitR[0].s   = bar_hit[0] ;
    
  --- HARDWIRE_BAR
      ELSE GENERATE -- HARDWIRE_BAR0 == 1
        bar_0[31..0] = HARDWIRE_BAR0;
        bar_selR[0]     = cfg_adr_dec_tmp_node[0];  -- address decode 10h
    
        IF (BAR0_MEM_LOC < 2) GENERATE
          bar0_comp.dataa[] = bar_0[31 .. BAR0_READ_ONLY_BITS] ;
          bar0_comp.datab[] = ad_IR_addr[31 .. BAR0_READ_ONLY_BITS];  
          cyc_vld[0]      =   (NOT bar_nibble0[0]   and mem_cyc )
                    OR  (bar_nibble0[0]     and io_cyc  );

          bar_hit[0]  = LCELL(bar0_comp.aeb and adr_phase and cyc_vld[0]);
        ELSE GENERATE
          IF (BAR0_READ_ONLY_BITS_64 < 32) GENERATE 
            -- Hardwire 64-Bit BAR.  bar_nibble[0][0] is not considered because it is always 0 in 64-Bit BAR
            --             mem_ena is not considered due to Hardwire setting
            bar0_comp.dataa[] = bar_0[31 .. BAR0_READ_ONLY_BITS] ;
            bar0_comp.datab[] = ad_IR_addr[31 .. BAR0_READ_ONLY_BITS];  
            cyc_vld[0]      =   ((cben_ir_addr[3..0] == B"1101") and not alz_bar1_64)
                      OR  (mem_cyc and alz_bar1_64);
            bar_hit[0]      = LCELL(bar0_comp.aeb and adr_phase and cyc_vld[0]);  
          ELSE GENERATE
            
            bar_hit[0] = adr_phase and dac_cmd;
            cyc_vld[0] = GND;
          END GENERATE;
        END GENERATE; 

      -- Set BAR0 Address Compare Hit Register Controls
        bar_hitR[0].clk   = clk;
        bar_hitR[0].clrn  = rstN;             
        bar_hitR[0].r   = bar_hit_rst;
        bar_hitR[0].s   = bar_hit[0] ;
      END GENERATE;
  -- NUMBER_OF_BARS==0      
    ELSE GENERATE
      bar_hit[5..0]     = GND;
      bar_selR[0]       = GND ;   -- Bar0 Register Select
      cyc_vld[5..0]     = GND;
      bar_hitR[5..0].clk    = Clk;
      bar_hitR[5..0].clrn   = rstN;
      bar_hitR[5..0].r    = bar_hit_rst;
      bar_hitR[5..0].s    = GND;
    --  bar[5..0][]       = H"00000000";
            bar_0[]       = H"00000000";
            bar_1[]       = H"00000000";
            bar_2[]       = H"00000000";
            bar_3[]       = H"00000000";
            bar_4[]       = H"00000000";
            bar_5[]       = H"00000000";  
    
    END GENERATE; -- END OF NUMBER_OF_BAR>=1+0
--------------------------------------------------------------------------------------------------- 

---- BAR1: 32-BIT OR 64-BIT BAR ------------------------------------------------------------------- 
    IF (NUMBER_OF_BARS >= 1+1) GENERATE
      -- Check and REPORT value supplied for BAR1
      --  IF (1 == 1) GENERATE ASSERT REPORT "this is bar 1" severity info; END GENERATE;
        IF (BAR0_MEM_LOC < 2) GENERATE
          IF (BAR1_TYPE == 1) GENERATE    -- IO BAR
          --IF (BAR1_MEM_LOC == 0 and BAR1_PREFETCH == 0 ) GENERATE
            ASSERT REPORT "BAR1 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = I/O"
              BAR1_COMP_WIDTH, CEIL(2^BAR1_READ_ONLY_BITS)
            SEVERITY INFO;
          --ELSE GENERATE 
          --  ASSERT REPORT " Illegal Value [%] for BAR1 Parameter" BAR1
          --  SEVERITY ERROR;
          --END GENERATE;
        ELSE GENERATE
      -- MEMORY BAR
        --32-BIT BAR: NON-PREFETCHABLE 
          IF (BAR1_MEM_LOC == 0 and BAR1_PREFETCH == 0 ) GENERATE
            IF (BAR1_OVFL_N == 0) GENERATE
              ASSERT REPORT "BAR1 Settings: Number of Address Bits Decoded = %, Size = 2 GBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Non-Prefetchable"
                BAR1_COMP_WIDTH 
              SEVERITY INFO;
            ELSE GENERATE
              IF (CEIL(2^BAR1_READ_ONLY_BITS) >=   1073741824) GENERATE
                ASSERT REPORT "BAR1 Settings: Number of Address Bits Decoded = %, Size = % GBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Non-Prefetchable"
                  BAR1_COMP_WIDTH, (2^BAR1_READ_ONLY_BITS) DIV  1073741824
                SEVERITY INFO;
              END GENERATE;
              IF (CEIL(2^BAR1_READ_ONLY_BITS) >=  1048576 and (CEIL(2^BAR1_READ_ONLY_BITS) <   1073741824)) GENERATE
                ASSERT REPORT "BAR1 Settings: Number of Address Bits Decoded = %, Size = % MBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Non-Prefetchable"
                  BAR1_COMP_WIDTH, CEIL(2^BAR1_READ_ONLY_BITS) DIV 1048576 
                SEVERITY INFO;
              END GENERATE;
              IF((CEIL(2^BAR1_READ_ONLY_BITS) >= 1024)  and (CEIL(2^BAR1_READ_ONLY_BITS) < 1048576)) GENERATE
                ASSERT REPORT "BAR1 Settings: Number of Address Bits Decoded = %, Size = % KBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Non-Prefetchable"
                  BAR1_COMP_WIDTH, CEIL(2^BAR1_READ_ONLY_BITS) DIV 1024
                SEVERITY INFO;
              END GENERATE;
              IF (CEIL(2^BAR1_READ_ONLY_BITS) < 1024) GENERATE
                ASSERT REPORT "BAR1 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Non-Prefetchable"
                  BAR1_COMP_WIDTH, CEIL(2^BAR1_READ_ONLY_BITS)
                SEVERITY INFO;
              END GENERATE;     
            END GENERATE;   
          END GENERATE;
        -- 32-BIT BAR: PREFETCHABLE 
          IF (BAR1_MEM_LOC == 0 and BAR1_PREFETCH == 1 ) GENERATE
            IF (BAR1_OVFL_N == 0) GENERATE
              ASSERT REPORT "BAR1 Settings: Number of Address Bits Decoded = %, Size = 2 GBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Prefetchable"
                BAR1_COMP_WIDTH 
              SEVERITY INFO;
            ELSE GENERATE     
              IF (CEIL(2^BAR1_READ_ONLY_BITS) >=   1073741824) GENERATE
                ASSERT REPORT "BAR1 Settings: Number of Address Bits Decoded = %, Size = % GBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Prefetchable"
                  BAR1_COMP_WIDTH, CEIL(2^BAR1_READ_ONLY_BITS) DIV  1073741824
                SEVERITY INFO;
              END GENERATE;
              IF (CEIL(2^BAR1_READ_ONLY_BITS) >=  1048576 and (CEIL(2^BAR1_READ_ONLY_BITS) <   1073741824)) GENERATE
                ASSERT REPORT "BAR1 Settings: Number of Address Bits Decoded = %, Size = % MBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Prefetchable"
                  BAR1_COMP_WIDTH, CEIL(2^BAR1_READ_ONLY_BITS) DIV 1048576 
                SEVERITY INFO;
              END GENERATE;
              IF((CEIL(2^BAR1_READ_ONLY_BITS) >= 1024)  and (CEIL(2^BAR1_READ_ONLY_BITS) < 1048576)) GENERATE
                ASSERT REPORT "BAR1 Settings: Number of Address Bits Decoded = %, Size = % KBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Prefetchable"
                  BAR1_COMP_WIDTH, CEIL(2^BAR1_READ_ONLY_BITS) DIV 1024
                SEVERITY INFO;
              END GENERATE;
              IF (CEIL(2^BAR1_READ_ONLY_BITS) < 1024) GENERATE
                ASSERT REPORT "BAR1 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Prefetchable"
                  BAR1_COMP_WIDTH, CEIL(2^BAR1_READ_ONLY_BITS)
                SEVERITY INFO;
              END GENERATE;
            END GENERATE; 
          END GENERATE;
        -- 32-BAR: 1 MEG SPACE NON-PREFETCHABLE   
          IF(BAR1_MEM_LOC == 1 and BAR1_PREFETCH == 0 ) GENERATE      
            IF (BAR1_OVFL_N == 0) GENERATE
              ASSERT REPORT "Error:  The value for BAR1 parameter is incorrect; The allocated memory [2 GBytes] cannot be located below 1 Meg Space." 
              SEVERITY Error;
            ELSE GENERATE       
              IF (CEIL(2^BAR1_READ_ONLY_BITS) >=   1073741824) GENERATE
                ASSERT REPORT "Error:  The value for BAR1 parameter is incorrect; The allocated memory [% GBytes] cannot be located below 1 Meg Space."  CEIL(2^BAR1_READ_ONLY_BITS) DIV  1073741824
                SEVERITY Error;
              END GENERATE;
              IF (CEIL(2^BAR1_READ_ONLY_BITS) >=  1048576 and (CEIL(2^BAR1_READ_ONLY_BITS) <   1073741824)) GENERATE
                ASSERT REPORT "Error:  The value for BAR1 parameter is incorrect; The allocated memory [% MBytes] cannot be located below 1 Meg Space."  CEIL(2^BAR1_READ_ONLY_BITS) DIV 1048576 
                SEVERITY error;
              END GENERATE;
              IF((CEIL(2^BAR1_READ_ONLY_BITS) >= 1024)  and (CEIL(2^BAR1_READ_ONLY_BITS) < 1048576)) GENERATE
                ASSERT REPORT "BAR1 Settings: Number of Address Bits Decoded = %, Size = % KBytes, Type = Memory, Location = Below 1 Meg Space, Non-Prefetchable"
                  BAR1_COMP_WIDTH, CEIL(2^BAR1_READ_ONLY_BITS) DIV 1024
                SEVERITY INFO;
              END GENERATE;
              IF (CEIL(2^BAR1_READ_ONLY_BITS) < 1024) GENERATE
                ASSERT REPORT "BAR1 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = Memory, Location = Below 1 Meg Space, Non-Prefetchable"
                  BAR1_COMP_WIDTH, CEIL(2^BAR1_READ_ONLY_BITS)
                SEVERITY INFO;
              END GENERATE;
            END GENERATE;
          END GENERATE;
        -- 32-BIT BAR: 1 MEG SPACE PREFETCHABLE
          IF (BAR1_MEM_LOC == 1 and BAR1_PREFETCH == 1 ) GENERATE 
            IF (BAR1_OVFL_N == 0) GENERATE
              ASSERT REPORT "Error:  The value for BAR1 parameter is incorrect; The allocated memory [2 GBytes] cannot be located below 1 Meg Space." 
              SEVERITY Error;
            ELSE GENERATE
              IF (CEIL(2^BAR1_READ_ONLY_BITS) >=   1073741824) GENERATE
                ASSERT REPORT "Error:  The value for BAR1 parameter is incorrect; The allocated memory [% GBytes] cannot be located below 1 Meg Space."  CEIL(2^BAR1_READ_ONLY_BITS) DIV  1073741824
                SEVERITY Error;
              END GENERATE;
              IF (CEIL(2^BAR1_READ_ONLY_BITS) >=  1048576 and (CEIL(2^BAR1_READ_ONLY_BITS) <   1073741824)) GENERATE
                ASSERT REPORT "Error:  The value for BAR1 parameter is incorrect; The allocated memory [% MBytes] cannot be located below 1 Meg Space."  CEIL(2^BAR1_READ_ONLY_BITS) DIV 1048576 
                SEVERITY error;
              END GENERATE;
              IF((CEIL(2^BAR1_READ_ONLY_BITS) >= 1024)  and (CEIL(2^BAR1_READ_ONLY_BITS) < 1048576)) GENERATE
                ASSERT REPORT "BAR1 Settings: Number of Address Bits Decoded = %, Size = % KBytes, Type = Memory, Location = Below 1 Meg Space, Prefetchable"
                  BAR1_COMP_WIDTH, CEIL(2^BAR1_READ_ONLY_BITS) DIV 1024
                SEVERITY INFO;
              END GENERATE;
              IF (CEIL(2^BAR1_READ_ONLY_BITS) < 1024) GENERATE
                ASSERT REPORT "BAR1 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = Memory, Location = Below 1 Meg Space, Prefetchable"
                  BAR1_COMP_WIDTH, CEIL(2^BAR1_READ_ONLY_BITS)
                SEVERITY INFO;
              END GENERATE;
            END GENERATE;
          END GENERATE;
        -- 64-BIT BAR: NON-PREFETCHABLE
          IF (BAR1_MEM_LOC == 2 and BAR1_PREFETCH == 0 ) GENERATE
            IF (BAR1_READ_ONLY_BITS_64 < 32) GENERATE -- 64-Bit BAR size <= 2 GBytes
              IF (BAR1_OVFL_N == 0) GENERATE -- 2 GBytes
                ASSERT REPORT "64-Bit BAR Using BAR2,1 Settings: Number of Address Bits Decoded = %, Size = 2 GBytes, Type = Memory, Location = Anywhere in the 64 Bit address Space, Non-Prefetchable"
                BAR1_READ_WRITE_BITS_64 
                SEVERITY INFO;
              ELSE GENERATE     -- < 2Gbytes  
                IF (CEIL(2^BAR1_READ_ONLY_BITS) >=   1073741824) GENERATE
                ASSERT REPORT "64-Bit BAR Using BAR2,1 Settings: Number of Address Bits Decoded = %, Size = % GBytes, Type = Memory, Location = Anywhere in the 64 Bit address Space, Non-Prefetchable"
                  BAR1_READ_WRITE_BITS_64 , (2^BAR1_READ_ONLY_BITS) DIV  1073741824
                SEVERITY INFO;
                END GENERATE;
                IF (CEIL(2^BAR1_READ_ONLY_BITS) >=  1048576 and (CEIL(2^BAR1_READ_ONLY_BITS) <   1073741824)) GENERATE
                  ASSERT REPORT "64-Bit BAR Using BAR2,1 Settings: Number of Address Bits Decoded = %, Size = % MBytes, Type = Memory, Location = Anywhere in the 64 Bit address Space, Non-Prefetchable"
                    BAR1_READ_WRITE_BITS_64 , CEIL(2^BAR1_READ_ONLY_BITS) DIV 1048576 
                  SEVERITY INFO;
                END GENERATE;
                IF((CEIL(2^BAR1_READ_ONLY_BITS) >= 1024)  and (CEIL(2^BAR1_READ_ONLY_BITS) < 1048576)) GENERATE
                  ASSERT REPORT "64-Bit BAR Using BAR2,1 Settings: Number of Address Bits Decoded = %, Size = % KBytes, Type = Memory, Location = Anywhere in the 64 Bit address Space, Non-Prefetchable"
                    BAR1_READ_WRITE_BITS_64 , CEIL(2^BAR1_READ_ONLY_BITS) DIV 1024
                  SEVERITY INFO;
                END GENERATE;
                IF (CEIL(2^BAR1_READ_ONLY_BITS) < 1024) GENERATE
                  ASSERT REPORT "64-Bit BAR Using BAR2,1 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = Memory, Location = Anywhere in the 64 Bit address Space, Non-Prefetchable"
                    BAR1_READ_WRITE_BITS_64 , CEIL(2^BAR1_READ_ONLY_BITS)
                  SEVERITY INFO;
                END GENERATE;
              END GENERATE;     
            ELSE GENERATE     -- 64-Bit BAR Size > 2 GBytes
            
              -- BAR0 READ_ONLY_BITS == 32: BAR0==H"00000004(C)"
              IF (BAR2_OVFL_N == 0) GENERATE
                ASSERT REPORT "64-Bit BAR Using BAR2,1 Settings: Number of Address Bits Decoded = %, Size = 8589934592 GBytes, Type = Memory, Location = Anywhere in the 64 Bit address Space, Non-Prefetchable"
                  BAR1_READ_WRITE_BITS_64 
                SEVERITY INFO;
              ELSE GENERATE
                IF (BAR2_READ_ONLY_BITS_64 == 30) GENERATE
                  ASSERT REPORT "64-Bit BAR Using BAR2,1 Settings: Number of Address Bits Decoded = %, Size = 4294967296  GBytes, Type = Memory, Location = Anywhere in the 64 Bit address Space, Non-Prefetchable"
                    BAR1_READ_WRITE_BITS_64 -- 2^62
                  SEVERITY INFO;
                END GENERATE;   
                IF (BAR2_READ_ONLY_BITS_64 == 29) GENERATE
                ASSERT REPORT "64-Bit BAR Using BAR2,1 Settings: Number of Address Bits Decoded = %, Size = 2147483648 GBytes, Type = Memory, Location = Anywhere in the 64 Bit address Space, Non-Prefetchable"
                  BAR1_READ_WRITE_BITS_64 -- 2^61
                SEVERITY INFO;
                END GENERATE;     
                IF (BAR2_READ_ONLY_BITS_64 <= 28) GENERATE
                  ASSERT REPORT "64-Bit BAR Using BAR2,1 Settings: Number of Address Bits Decoded = %, Size =  % GBytes, Type = Memory, Location = Anywhere in the 64 Bit address Space, Non-Prefetchable"
                    BAR1_READ_WRITE_BITS_64, (2^(MAX_64_BAR_RW_BITS-BAR2_READ_WRITE_BITS) * 4)  -- 2^60
                  SEVERITY INFO;
                END GENERATE;   
              END GENERATE;

            
            END GENERATE; -- END OF BAR1==H"00000004(C)"    
          END GENERATE;
          -- 64-BIT BAR: PREFETCHABLE
          IF (BAR1_MEM_LOC == 2 and BAR1_PREFETCH == 1 ) GENERATE
            IF (BAR1_READ_ONLY_BITS_64 < 32) GENERATE
              IF (BAR1_OVFL_N == 0) GENERATE
                ASSERT REPORT "64-Bit BAR Using BAR2,1 Settings: Number of Address Bits Decoded = %, Size = 2 GBytes, Type = Memory, Location = Anywhere in the 64 Bit address Space, Prefetchable"
                  BAR1_READ_WRITE_BITS_64 
                SEVERITY INFO;
              ELSE GENERATE       
                IF (CEIL(2^BAR1_READ_ONLY_BITS) >=   1073741824) GENERATE
                  ASSERT REPORT "64-Bit BAR Using BAR2,1 Settings: Number of Address Bits Decoded = %, Size = % GBytes, Type = Memory, Location = Anywhere in the 64 Bit address Space, Prefetchable"
                    BAR1_READ_WRITE_BITS_64 , (2^BAR1_READ_ONLY_BITS) DIV  1073741824
                  SEVERITY INFO;
                END GENERATE;
                IF (CEIL(2^BAR1_READ_ONLY_BITS) >=  1048576 and (CEIL(2^BAR1_READ_ONLY_BITS) <   1073741824)) GENERATE
                  ASSERT REPORT "64-Bit BAR Using BAR2,1 Settings: Number of Address Bits Decoded = %, Size = % MBytes, Type = Memory, Location = Anywhere in the 64 Bit address Space, Prefetchable"
                    BAR1_READ_WRITE_BITS_64 , CEIL(2^BAR1_READ_ONLY_BITS) DIV 1048576 
                  SEVERITY INFO;
                END GENERATE;
                IF((CEIL(2^BAR1_READ_ONLY_BITS) >= 1024)  and (CEIL(2^BAR1_READ_ONLY_BITS) < 1048576)) GENERATE
                  ASSERT REPORT "64-Bit BAR Using BAR2,1 Settings: Number of Address Bits Decoded = %, Size = % KBytes, Type = Memory, Location = Anywhere in the 64 Bit address Space, Prefetchable"
                    BAR1_READ_WRITE_BITS_64 , CEIL(2^BAR1_READ_ONLY_BITS) DIV 1024
                  SEVERITY INFO;
                END GENERATE;
                IF (CEIL(2^BAR1_READ_ONLY_BITS) < 1024) GENERATE
                  ASSERT REPORT "64-Bit BAR Using BAR2,1 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = Memory, Location = Anywhere in the 64 Bit address Space, Prefetchable"
                    BAR1_READ_WRITE_BITS_64 , CEIL(2^BAR1_READ_ONLY_BITS)
                  SEVERITY INFO;
                END GENERATE;
              END GENERATE;
            ELSE GENERATE
            -- BAR0_READ_ONLY_BITS==32: BAR1=H"00000004(C)"

              IF (BAR2_OVFL_N == 0) GENERATE
                ASSERT REPORT "64-Bit BAR Using BAR2,1 Settings: Number of Address Bits Decoded = %, Size = 8589934592 GBytes, Type = Memory, Location = Anywhere in the 64 Bit address Space, Prefetchable"
                  BAR1_READ_WRITE_BITS_64 
                SEVERITY INFO;
              ELSE GENERATE
                IF (BAR2_READ_ONLY_BITS_64 == 30) GENERATE
                  ASSERT REPORT "64-Bit BAR Using BAR2,1 Settings: Number of Address Bits Decoded = %, Size = 4294967296  GBytes, Type = Memory, Location = Anywhere in the 64 Bit address Space, Prefetchable"
                    BAR1_READ_WRITE_BITS_64 -- 2^62
                  SEVERITY INFO;
                END GENERATE;   
                IF (BAR2_READ_ONLY_BITS_64 == 29) GENERATE
                ASSERT REPORT "64-Bit BAR Using BAR2,1 Settings: Number of Address Bits Decoded = %, Size = 2147483648 GBytes, Type = Memory, Location = Anywhere in the 64 Bit address Space, Prefetchable"
                  BAR1_READ_WRITE_BITS_64 -- 2^61
                SEVERITY INFO;
                END GENERATE;     
                IF (BAR2_READ_ONLY_BITS_64 <= 28) GENERATE
                  ASSERT REPORT "64-Bit BAR Using BAR2,1 Settings: Number of Address Bits Decoded = %, Size =  % GBytes, Type = Memory, Location = Anywhere in the 64 Bit address Space, Prefetchable"
                    BAR1_READ_WRITE_BITS_64, (2^(MAX_64_BAR_RW_BITS-BAR2_READ_WRITE_BITS) * 4)  -- 2^60
                  SEVERITY INFO;
                END GENERATE;   
              END GENERATE;
            END GENERATE; -- END OF BAR1==H"00000004(C)"    
          END GENERATE; -- END OF 64-BAR: PREFETCHABLE
          -- BAR0_MEM_LOC > 2
          IF (BAR1_MEM_LOC > 2) GENERATE
            ASSERT REPORT " Illegal Memory Type Value for BAR0 "
            SEVERITY ERROR;
          END GENERATE;     
        END GENERATE; -- END OF BAR1_TYPE==0: MEMORY 
      END GENERATE; -- END OF MEMORY BAR
---------------------------------------------------------------------------------------------------
    -- NO HARDWIRE_BAR
      IF (HARDWIRE_BAR1_ENA != 1) GENERATE
        no_op[]       = no_op[] or bar1_ena3 or bar1_ena2 or bar1_ena1 or bar1_ena0 or dac_cfg;     
        bar_selR[1]     = cfg_adr_dec_tmp_node[1];  

        -- Setting Bar1 Enables
        IF (LOCAL_CONFIG_ENA == "NO") GENERATE  
          bar1_ena[3..0]    = bar_selR[1] and cfg_dat_vld and not(cben_IR[3..0]); 
        ELSE  GENERATE
          bar1_ena[3..0]    = bar_selR[1] and lcfg_dat_vld and not lcfg_ben[3..0];  
        END GENERATE;
        
          
        -- Setting BAR1 Read Only Bits
        IF (BAR0_MEM_LOC < 2) GENERATE  -- 32-Bit BAR0  
          IF (BAR1_MEM_LOC < 2) GENERATE -- 32-Bit BAR1
            IF (BAR1_READ_ONLY_BITS > 4) GENERATE
              bar1_ro_bits[BAR1_READ_ONLY_BITS-1..4]        = GND;      -- BAR1 Read Only Bits
            END GENERATE;
          ELSE GENERATE -- 64-BIT bar1,2
            IF (BAR1_READ_ONLY_BITS_64 < 32) GENERATE
              bar1_ro_bits[BAR1_READ_ONLY_BITS-1 ..4]       = GND;
            ELSE GENERATE
              bar1_ro_bits[BAR1_READ_ONLY_BITS_64-1..4]     = GND;
            END GENERATE;
          END GENERATE;
        ELSE GENERATE -- BAR0,1 is 64-Bit
          IF (MAX_64_BAR_RW_BITS == 32) GENERATE
            IF ( BAR1_READ_ONLY_BITS_64 > 0) GENERATE
              bar1_ro_bits_lower[BAR1_READ_ONLY_BITS_64-1..0]   = GND;  
            END GENERATE;
          ELSE GENERATE 
            IF (BAR1_READ_ONLY_BITS_64 > 0) GENERATE
              bar1_ro_bits_upper[31..MAX_64_BAR_RW_BITS]      = GND;
              bar1_ro_bits_lower[BAR1_READ_ONLY_BITS_64-1..0]   = GND;    
            ELSE GENERATE
              bar1_ro_bits_upper[31..MAX_64_BAR_RW_BITS]      = GND;        
            END GENERATE;
          END GENERATE;
        END GENERATE;
      
      -- Set BAR1 R/W Registers Controls
        IF (LOCAL_CONFIG_ENA == "NO") GENERATE
          IF (BAR0_MEM_LOC < 2) GENERATE -- 32-Bit BAR0
            IF (BAR1_MEM_LOC < 2) GENERATE -- 32-Bit BAR1
              bar1_reg[].clk  = clk ;
              bar1_reg[].clrn = rstN;
              bar1_reg[].d  = ad_IR[31..BAR1_READ_ONLY_BITS];
            ELSE GENERATE -- 64-Bit BAR1,2
              IF (BAR1_READ_ONLY_BITS_64 < 32) GENERATE -- Some RW_Bits exist in BAR1
                bar1_reg[].clk  = clk ;
                bar1_reg[].clrn = rstN;
                bar1_reg[].d  = ad_IR[31..BAR1_READ_ONLY_BITS];
              END GENERATE;
            END GENERATE;
          ELSE GENERATE -- 64-Bit BAR0,1
            bar1_reg[].clk  = clk ;
            bar1_reg[].clrn = rstN;
            bar1_reg[].d  = ad_IR[MAX_64_BAR_RW_BITS-1 .. BAR1_READ_ONLY_BITS_64];
          END GENERATE;
        ELSE  GENERATE -- Local Config Enable is ON
          IF (BAR0_MEM_LOC < 2) GENERATE -- 32-Bit BAR0
            IF (BAR1_MEM_LOC < 2) GENERATE -- 32-Bit BAR1
              bar1_reg[].clk  = clk ;
              bar1_reg[].clrn = rstN;
              bar1_reg[].d  = lcfg_dat_in[31..BAR1_READ_ONLY_BITS];
            ELSE GENERATE -- 64-Bit BAR1,2
              IF (BAR1_READ_ONLY_BITS_64 > 0) GENERATE -- Some RW_Bits exist in BAR1
                bar1_reg[].clk  = clk ;
                bar1_reg[].clrn = rstN;
                bar1_reg[].d  = lcfg_dat_in[31..BAR1_READ_ONLY_BITS];
              END GENERATE;
            END GENERATE;
          ELSE GENERATE -- 64-Bit BAR0,1
            bar1_reg[].clk  = clk ;
            bar1_reg[].clrn = rstN;
            bar1_reg[].d  = lcfg_dat_in[MAX_64_BAR_RW_BITS-1 .. BAR1_READ_ONLY_BITS_64];
          END GENERATE;
        END GENERATE;

      -- BAR1 ENABLE
        IF (BAR0_MEM_LOC < 2) GENERATE  -- 32-Bit BAR0
          IF (BAR1_MEM_LOC < 2) GENERATE -- 32-Bit BAR1 
            IF (BAR1_READ_ONLY_BITS < 8) GENERATE       -- Byte 3, 2, 1, 0 Have R/W Bits
              bar1_reg[31..24].ena              = bar1_ena[3];
              bar1_reg[23..16].ena              = bar1_ena[2];
              bar1_reg[15..8].ena               = bar1_ena[1];
              bar1_reg[7..BAR1_READ_ONLY_BITS].ena      = bar1_ena[0];
            ELSE GENERATE
              IF (BAR1_READ_ONLY_BITS < 16) GENERATE      -- Byte 3, 2, 1 Have R/W Bits
                bar1_reg[31..24].ena            = bar1_ena[3];
                bar1_reg[23..16].ena            = bar1_ena[2];
                bar1_reg[15..BAR1_READ_ONLY_BITS].ena   = bar1_ena[1];
              ELSE GENERATE 
                IF (BAR1_READ_ONLY_BITS < 24) GENERATE    -- Byte 3, 2 Have R/W Bits
                  bar1_reg[31..24].ena          = bar1_ena[3];
                  bar1_reg[23..BAR1_READ_ONLY_BITS].ena = bar1_ena[2];
                ELSE GENERATE               -- Byte 3 Has R/W Bits  
                  bar1_reg[31..BAR1_READ_ONLY_BITS].ena = bar1_ena[3];
                END GENERATE;
              END GENERATE;
            END GENERATE;   
          ELSE GENERATE -- 64-Bit BAR1,2
            IF (BAR1_READ_ONLY_BITS_64 < 32) GENERATE -- BAR0 Read Only Bits < 32
              IF (BAR1_READ_ONLY_BITS < 8) GENERATE
                bar1_reg[31..24].ena              = bar1_ena[3];
                bar1_reg[23..16].ena              = bar1_ena[2];
                bar1_reg[15..8].ena               = bar1_ena[1];
                bar1_reg[7..BAR1_READ_ONLY_BITS].ena      = bar1_ena[0];
              ELSE GENERATE   
                IF (BAR1_READ_ONLY_BITS < 16) GENERATE    
                  bar1_reg[31..24].ena            = bar1_ena[3];
                  bar1_reg[23..16].ena            = bar1_ena[2];
                  bar1_reg[15..BAR1_READ_ONLY_BITS].ena   = bar1_ena[1];
                ELSE GENERATE       
                  IF (BAR1_READ_ONLY_BITS < 24) GENERATE      
                    bar1_reg[31..24].ena          = bar1_ena[3];
                    bar1_reg[23..BAR1_READ_ONLY_BITS].ena = bar1_ena[2];      
                  ELSE GENERATE     
                    bar1_reg[31..BAR1_READ_ONLY_BITS].ena = bar1_ena[3];
                  END GENERATE;
                END GENERATE;
              END GENERATE;
            END GENERATE;
          END GENERATE;
        ELSE GENERATE -- 64-Bit BAR0,1
          IF (MAX_64_BAR_RW_BITS  <= 8) GENERATE        -- BAR1 R/W Bits less than 8 
                                    -- Only Byte 0 has R/W Bits
            bar1_reg[MAX_64_BAR_RW_BITS-1.. BAR1_READ_ONLY_BITS_64].ena = bar1_ena[0];
          ELSE GENERATE
            
            IF (MAX_64_BAR_RW_BITS  <= 16) GENERATE     -- BAR1 R/W Bits > 8 and <= 16
              IF (BAR1_READ_ONLY_BITS_64 < 8) GENERATE  --  Byte 1, 0 Have R/W Bits
                bar1_reg[MAX_64_BAR_RW_BITS-1 .. 8].ena   = bar1_ena[1];
                bar1_reg[7 .. BAR1_READ_ONLY_BITS_64].ena   = bar1_ena[0];
              ELSE GENERATE -- Number of R/W Bits is less than 8
                bar1_reg[MAX_64_BAR_RW_BITS-1 .. BAR1_READ_ONLY_BITS_64].ena = bar1_ena[1];
              END GENERATE;
      
            ELSE GENERATE
              IF (MAX_64_BAR_RW_BITS  <= 24) GENERATE     -- BAR1 R/W Bits > 16 and <= 24
                IF (BAR1_READ_ONLY_BITS_64 < 8) GENERATE        -- Byte 2, 1, 0 Have R/W Bits
                  bar1_reg[MAX_64_BAR_RW_BITS-1 .. 16].ena  = bar1_ena[2];
                  bar1_reg[15 .. 8].ena             = bar1_ena[1];
                  bar1_reg[7 .. BAR1_READ_ONLY_BITS_64].ena   = bar1_ena[0];
                ELSE GENERATE
                  IF (BAR1_READ_ONLY_BITS_64 < 16) GENERATE     -- Byte 2, 1 Have R/W Bits
                    bar1_reg[MAX_64_BAR_RW_BITS-1 .. 16 ].ena   = bar1_ena[2];
                    bar1_reg[15 .. BAR1_READ_ONLY_BITS_64].ena  = bar1_ena[1];
                  ELSE GENERATE 
                    IF (BAR1_READ_ONLY_BITS_64 < 24) GENERATE   -- Byte 2 Have R/W Bits
                      bar1_reg[MAX_64_BAR_RW_BITS-1 .. BAR1_READ_ONLY_BITS_64 ].ena   = bar1_ena[2];
                    END GENERATE;
                  END GENERATE;
                END GENERATE;   
              ELSE GENERATE 
                --  MAX BAR1 R/W Bits > 24
                IF (BAR1_READ_ONLY_BITS_64 < 8) GENERATE        -- Byte 3, 2, 1, 0 Have R/W Bits
                  bar1_reg[MAX_64_BAR_RW_BITS-1 .. 24].ena  = bar1_ena[3];
                  bar1_reg[23 .. 16].ena            = bar1_ena[2];
                  bar1_reg[15 .. 8].ena             = bar1_ena[1];
                  bar1_reg[7 .. BAR1_READ_ONLY_BITS_64].ena   = bar1_ena[0];
                ELSE GENERATE
                  IF (BAR1_READ_ONLY_BITS_64 < 16) GENERATE     -- Byte 3, 2, 1 Have R/W Bits
                    bar1_reg[MAX_64_BAR_RW_BITS-1 .. 24 ].ena   = bar1_ena[3];
                    bar1_reg[23 .. 16].ena            = bar1_ena[2];
                    bar1_reg[15 .. BAR1_READ_ONLY_BITS_64].ena  = bar1_ena[1];
                  ELSE GENERATE 
                    IF (BAR1_READ_ONLY_BITS_64 < 24) GENERATE   -- Byte 3, 2 Have R/W Bits
                      bar1_reg[MAX_64_BAR_RW_BITS-1 .. 24 ].ena   = bar1_ena[3];
                      bar1_reg[23 .. BAR1_READ_ONLY_BITS_64 ].ena = bar1_ena[2];
                    ELSE GENERATE               -- Byte 3 Has R/W Bits  
                      bar1_reg[MAX_64_BAR_RW_BITS-1 .. BAR1_READ_ONLY_BITS_64 ].ena   = bar1_ena[3];
                    END GENERATE;
                  END GENERATE;
                END GENERATE;   
              END GENERATE;         
            END GENERATE;   
          END GENERATE;
        END GENERATE;     
             
      -- Set the 32 bit value of BAR1
      -- This was added because I/O Base Address register can have only 16 bytes available
        IF (BAR0_MEM_LOC < 2) GENERATE  -- 32-Bit BAR0
          IF (BAR1_MEM_LOC < 2) GENERATE -- 32-Bit BAR1
            IF (BAR1_READ_ONLY_BITS > 4) GENERATE   
              bar_1[] = (bar1_reg[],bar1_ro_bits[BAR1_READ_ONLY_BITS-1..4],(bar_nibble1[]));
            ELSE GENERATE
              IF (BAR1_READ_ONLY_BITS < 3) GENERATE
                bar_1[] = (bar1_reg[],(bar_nibble1[1..0]));
              ELSE GENERATE
                IF (BAR1_READ_ONLY_BITS < 4) GENERATE
                  bar_1[] = (bar1_reg[],(bar_nibble1[2..0]));
                ELSE GENERATE
                  bar_1[] = (bar1_reg[],(bar_nibble1[3..0]));
                END GENERATE;
              END GENERATE;
            END GENERATE;
          ELSE GENERATE -- 64-Bit BAR1,2
            IF (BAR1_READ_ONLY_BITS_64 < 32) GENERATE
              bar_1[] = (bar1_reg[],bar1_ro_bits[BAR1_READ_ONLY_BITS-1..4],(bar_nibble1[]));
            ELSE GENERATE -- NO R/W Bits
              bar_1[] = (bar1_ro_bits[BAR1_READ_ONLY_BITS_64-1..4],(bar_nibble1[]));
            END GENERATE;
          END GENERATE;
        ELSE GENERATE -- 64-Bit BAR0,1
          IF( MAX_64_BAR_RW_BITS == 32) GENERATE -- MAX Number of BITS allowed for BAR1
            IF (BAR1_READ_ONLY_BITS_64 > 0) GENERATE
              bar_1[] = (bar1_reg[],bar1_ro_bits_lower[BAR1_READ_ONLY_BITS_64-1..0]);
            ELSE GENERATE
              bar_1[] = (bar1_reg[]);
            END GENERATE;
          ELSE GENERATE -- Some High Bits are Read Only
            IF (BAR1_READ_ONLY_BITS_64 > 0) GENERATE 
              bar_1[] = (bar1_ro_bits_upper[31..MAX_64_BAR_RW_BITS],bar1_reg[],bar1_ro_bits_lower[BAR1_READ_ONLY_BITS_64-1..0]);
            ELSE GENERATE -- BAR1_READ_ONLY_BITS_64 = 0
              bar_1[] = (bar1_ro_bits_upper[31..MAX_64_BAR_RW_BITS],bar1_reg[]);
            END GENERATE;
          END GENERATE;
        END GENERATE;

      -- Connect The Ports of BAR1 Address Comparator 
      
        IF (BAR0_MEM_LOC == 2) GENERATE -- 64-Bit BAR0,1
          -- alz_bar1_64 checks if BAR1 is all Zero and therefore no need for compare
          alz_bar1_64.clk   = clk;
          alz_bar1_64.clrn  = rstn;
          alz_bar1_64     = bar1_reg[] == 0;

          bar1_comp.dataa[] = bar1_reg[] ;
          bar1_comp.datab[] = ad_IR_addr[MAX_64_BAR_RW_BITS-1 .. BAR1_READ_ONLY_BITS_64]; 
          cyc_vld[1]      = (mem_cyc and mem_access_enable and dac_adr_phase_r and bar_hitR[0] );
          
          bar_hit[1]      = LCELL (   (alz_bar1_64 and bar_hit[0])
                        OR  (bar1_comp.aeb and cyc_vld[1])
                        );  
              
        ELSE GENERATE -- 32-Bit BAR0
      
          IF (BAR1_MEM_LOC == 2) GENERATE -- 64-Bit BAR1,2
            IF (BAR1_READ_ONLY_BITS_64 < 32) GENERATE
              bar1_comp.dataa[] = bar1_reg[] ;
              bar1_comp.datab[] = ad_IR_addr[BAR1_REG_MAX .. BAR1_REG_MIN]; -- Only Upper Most Address Bits are Decoded
              -- Cycle checkes if bar2 is all zero then only bar_hit1 is enough for the cycle to be claimed
              -- If bar2 is not all 0 then both bar_hit1 and bar_hit2 must be true for the cycle to be claimed
              cyc_vld[1]      = (NOT bar_nibble1[0] and mem_access_enable and   ( ( (cben_ir_addr[3..0] == B"1101") and not alz_bar2_64)
                                                  OR  (mem_cyc and alz_bar2_64)
                                                  ));
              bar_hit[1]      = LCELL(bar1_comp.aeb and adr_phase and cyc_vld[1]);
            ELSE GENERATE
              bar_hit[1]      = adr_phase and dac_cmd;
              cyc_vld[1]      = GND;
            END GENERATE;   
        
          ELSE GENERATE -- 32-Bit BAR1
            bar1_comp.dataa[] = bar1_reg[] ;
            bar1_comp.datab[] = ad_IR_addr[BAR1_REG_MAX .. BAR1_REG_MIN]; 
            cyc_vld[1]      =   ( NOT bar_nibble1[0] and mem_cyc  and mem_access_enable )
                      OR  ( bar_nibble1[0]   and io_cyc   and io_access_enable);
                    
            bar_hit[1]      = LCELL(bar1_comp.aeb and adr_phase and cyc_vld[1]); 
        
          END GENERATE;
        
        END GENERATE;
      
      -- Set BAR1 Address Compare Hit Register Controls 
        bar_hitR[1].clk  = clk;
        bar_hitR[1].clrn = rstN;                
        bar_hitR[1].r = bar_hit_rst;
        bar_hitR[1].s = bar_hit[1] ;
    -- HARDWIRE_BAR         
      ELSE GENERATE -- HARDWIRE_BAR1 == 1
        bar_1[31..0]    = HARDWIRE_BAR1;
        bar_selR[1]     = cfg_adr_dec_tmp_node[1];
  
      -- Connect The Ports of BAR1 Address Comparator
        IF( BAR0_MEM_LOC == 2) GENERATE -- 64-Bit BAR0,1
          -- alz_bar1_64:  Indicates that for 64_bit BAR using BAR 1, 0 BAR 1 is all Zero
          -- In this case the decode for BAR1 is not performed
          alz_bar1_64.clk     = clk;
          alz_bar1_64.clrn    = rstn;
          
          alz_bar1_64       = bar[1][MAX_64_BAR_RW_BITS-1 .. BAR1_READ_ONLY_BITS_64] == 0;

        
          bar1_comp.dataa[] = bar_1[MAX_64_BAR_RW_BITS-1 .. BAR1_READ_ONLY_BITS_64] ;
          bar1_comp.datab[] = ad_IR_addr[MAX_64_BAR_RW_BITS-1 .. BAR1_READ_ONLY_BITS_64];
        
                
          cyc_vld[1]      = ( mem_cyc  and dac_adr_phase_r and bar_hitR[0]);      -- Since Location is 64-Bit Address, bar_nibble[0][0] is not considered
          bar_hit[1]      = LCELL ( (alz_bar1_64 and bar_hit[0])
                        OR  (bar1_comp.aeb and cyc_vld[1])
                        );
        
        ELSE GENERATE -- 32-Bit BAR0
        
          IF (BAR1_MEM_LOC == 2)  GENERATE  -- 64-Bit BAR 1,2
            
            IF (BAR1_READ_ONLY_BITS_64 < 32) GENERATE -- 64-Bit bar using BAR 2,1 is less than 4 Gbytes
              --  bar_nibble1[0] is not considered because it is always 0 in 64-Bit BAR
              --  mem_ena is not considered due to Hardwire setting
              bar1_comp.dataa[] = bar_1[BAR1_REG_MAX .. BAR1_REG_MIN] ;
              bar1_comp.datab[] = ad_IR_addr[BAR1_REG_MAX .. BAR1_REG_MIN]; 
              cyc_vld[1]      =   ((cben_ir_addr[3..0] == B"1101") and not alz_bar2_64)
                        OR  (mem_cyc and alz_bar2_64);
              bar_hit[1]      = LCELL(bar1_comp.aeb and adr_phase and cyc_vld[1]);  
            ELSE GENERATE -- 64-Bit BAR using BAR2,1 is >= 4Gbytes
              bar_hit[1] =  adr_phase and dac_cmd;
              cyc_vld[1]  = GND;
              
            END GENERATE;
        
          ELSE GENERATE   -- 32-Bit BAR1
          
            bar1_comp.dataa[] = bar_1[BAR1_REG_MAX .. BAR1_REG_MIN] ;
            bar1_comp.datab[] = ad_IR_addr[BAR1_REG_MAX .. BAR1_REG_MIN]; 
            cyc_vld[1]      =   (NOT bar_nibble1[0]   and mem_cyc)
                      or  (bar_nibble1[0]     and io_cyc ) ;
            bar_hit[1]      = LCELL(bar1_comp.aeb and adr_phase and cyc_vld[1]); 
        
        
          END GENERATE;
        END GENERATE;
        
        
  
      -- Set BAR1 Address Compare Hit Register Controls
        bar_hitR[1].clk   = clk;
        bar_hitR[1].clrn  = rstN;
        bar_hitR[1].r   = bar_hit_rst;
        bar_hitR[1].s   = bar_hit[1] ;
      END GENERATE; -- END OF HARDWIRE BAR
  -- NUMBER_OF_BARS == 1
    ELSE GENERATE
      bar_hit[5..1]   = GND;
      bar_selR[1]     = GND ;   -- Bar1 Register Select
      cyc_vld[5..1]   = GND;
      bar_hitR[5..1].clk  = Clk;
      bar_hitR[5..1].clrn = rstN;
      bar_hitR[5..1].r  = bar_hit_rst;
      bar_hitR[5..1].s  = GND;
      --bar[5..1][]     = H"00000000";
      bar_1[]     = H"00000000";
      bar_2[]     = H"00000000";
      bar_3[]     = H"00000000";
      bar_4[]     = H"00000000";
      bar_5[]     = H"00000000";
    END GENERATE; -- END OF NUMBER_OF_BARS
---------------------------------------------------------------------------------------------------

---- BAR2: 32-BIT BAR ----------------------------------------------------------------------------- 
  IF (NUMBER_OF_BARS >= 1+2) GENERATE
    -- Check and REPORT value supplied for BAR2
    -- BAR0 must be 32-Bit to consider Bar1 for 64-Bit BAR
    
    
    IF (BAR1_MEM_LOC < 2 OR BAR0_MEM_LOC == 2) GENERATE
        IF (BAR2_TYPE == 1) GENERATE
          --IF (BAR2_MEM_LOC == 0 and BAR2_PREFETCH == 0 ) GENERATE
            ASSERT REPORT "BAR2 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = I/O"
              BAR2_COMP_WIDTH, CEIL(2^BAR2_READ_ONLY_BITS)
            SEVERITY INFO;
          --ELSE GENERATE 
          --  ASSERT REPORT " Illegal Value [%] for BAR2 Parameter" BAR2
          -- SEVERITY ERROR;
          --END GENERATE;
        ELSE GENERATE
          IF (BAR2_MEM_LOC == 0 and BAR2_PREFETCH == 0 ) GENERATE
            IF (BAR2_OVFL_N == 0) GENERATE
              ASSERT REPORT "BAR2 Settings: Number of Address Bits Decoded = %, Size = 2 GBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Non-Prefetchable"
                BAR2_COMP_WIDTH 
              SEVERITY INFO;
            ELSE GENERATE
              IF (CEIL(2^BAR2_READ_ONLY_BITS) >=   1073741824) GENERATE
                ASSERT REPORT "BAR2 Settings: Number of Address Bits Decoded = %, Size = % GBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Non-Prefetchable"
                  BAR2_COMP_WIDTH, (2^BAR2_READ_ONLY_BITS) DIV  1073741824
                SEVERITY INFO;
              END GENERATE;
              IF (CEIL(2^BAR2_READ_ONLY_BITS) >=  1048576 and (CEIL(2^BAR2_READ_ONLY_BITS) <   1073741824)) GENERATE
                ASSERT REPORT "BAR2 Settings: Number of Address Bits Decoded = %, Size = % MBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Non-Prefetchable"
                  BAR2_COMP_WIDTH, CEIL(2^BAR2_READ_ONLY_BITS) DIV 1048576 
                SEVERITY INFO;
              END GENERATE;
              IF((CEIL(2^BAR2_READ_ONLY_BITS) >= 1024)  and (CEIL(2^BAR2_READ_ONLY_BITS) < 1048576)) GENERATE
                ASSERT REPORT "BAR2 Settings: Number of Address Bits Decoded = %, Size = % KBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Non-Prefetchable"
                  BAR2_COMP_WIDTH, CEIL(2^BAR2_READ_ONLY_BITS) DIV 1024
                SEVERITY INFO;
              END GENERATE;
              IF (CEIL(2^BAR2_READ_ONLY_BITS) < 1024) GENERATE
                ASSERT REPORT "BAR2 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Non-Prefetchable"
                  BAR2_COMP_WIDTH, CEIL(2^BAR2_READ_ONLY_BITS)
                SEVERITY INFO;
              END GENERATE;
            END GENERATE;
          END GENERATE;
    
          IF (BAR2_MEM_LOC == 0 and BAR2_PREFETCH == 1 ) GENERATE
            IF (BAR2_OVFL_N == 0) GENERATE
              ASSERT REPORT "BAR2 Settings: Number of Address Bits Decoded = %, Size = 2 GBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Prefetchable"
                BAR2_COMP_WIDTH 
              SEVERITY INFO;
            ELSE GENERATE
              IF (CEIL(2^BAR2_READ_ONLY_BITS) >=   1073741824) GENERATE
                ASSERT REPORT "BAR2 Settings: Number of Address Bits Decoded = %, Size = % GBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Prefetchable"
                  BAR2_COMP_WIDTH, CEIL(2^BAR2_READ_ONLY_BITS) DIV  1073741824
                SEVERITY INFO;
              END GENERATE;
              IF (CEIL(2^BAR2_READ_ONLY_BITS) >=  1048576 and (CEIL(2^BAR2_READ_ONLY_BITS) <   1073741824)) GENERATE
                ASSERT REPORT "BAR2 Settings: Number of Address Bits Decoded = %, Size = % MBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Prefetchable"
                  BAR2_COMP_WIDTH, CEIL(2^BAR2_READ_ONLY_BITS) DIV 1048576 
                SEVERITY INFO;
              END GENERATE;
              IF((CEIL(2^BAR2_READ_ONLY_BITS) >= 1024)  and (CEIL(2^BAR2_READ_ONLY_BITS) < 1048576)) GENERATE
                ASSERT REPORT "BAR2 Settings: Number of Address Bits Decoded = %, Size = % KBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Prefetchable"
                  BAR2_COMP_WIDTH, CEIL(2^BAR2_READ_ONLY_BITS) DIV 1024
                SEVERITY INFO;
              END GENERATE;
              IF (CEIL(2^BAR2_READ_ONLY_BITS) < 1024) GENERATE
                ASSERT REPORT "BAR2 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Prefetchable"
                  BAR2_COMP_WIDTH, CEIL(2^BAR2_READ_ONLY_BITS)
                SEVERITY INFO;
              END GENERATE;
            END GENERATE;
          END GENERATE;
    
          IF(BAR2_MEM_LOC == 1 and BAR2_PREFETCH == 0 ) GENERATE
            IF (BAR2_OVFL_N == 0) GENERATE
              ASSERT REPORT "Error:  The value for BAR0 parameter is incorrect; The allocated memory [2 GBytes] cannot be located below 1 Meg Space." 
              SEVERITY Error;
            ELSE GENERATE
              IF (CEIL(2^BAR2_READ_ONLY_BITS) >=   1073741824) GENERATE
                ASSERT REPORT "Error:  The value for BAR2 parameter is incorrect; The allocated memory [% GBytes] cannot be located below 1 Meg Space."  CEIL(2^BAR2_READ_ONLY_BITS) DIV  1073741824
                SEVERITY Error;
              END GENERATE;
              IF (CEIL(2^BAR2_READ_ONLY_BITS) >=  1048576 and (CEIL(2^BAR2_READ_ONLY_BITS) <   1073741824)) GENERATE
                ASSERT REPORT "Error:  The value for BAR2 parameter is incorrect; The allocated memory [% MBytes] cannot be located below 1 Meg Space."  CEIL(2^BAR2_READ_ONLY_BITS) DIV 1048576 
                SEVERITY error;
              END GENERATE;
              IF((CEIL(2^BAR2_READ_ONLY_BITS) >= 1024)  and (CEIL(2^BAR2_READ_ONLY_BITS) < 1048576)) GENERATE
                ASSERT REPORT "BAR2 Settings: Number of Address Bits Decoded = %, Size = % KBytes, Type = Memory, Location = Below 1 Meg Space, Non-Prefetchable"
                  BAR2_COMP_WIDTH, CEIL(2^BAR2_READ_ONLY_BITS) DIV 1024
                SEVERITY INFO;
              END GENERATE;
              IF (CEIL(2^BAR2_READ_ONLY_BITS) < 1024) GENERATE
                ASSERT REPORT "BAR2 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = Memory, Location = Below 1 Meg Space, Non-Prefetchable"
                  BAR2_COMP_WIDTH, CEIL(2^BAR2_READ_ONLY_BITS)
                SEVERITY INFO;
              END GENERATE;
            END GENERATE;
          END GENERATE;
    
          IF (BAR2_MEM_LOC == 1 and BAR2_PREFETCH == 1 ) GENERATE
            IF (BAR2_OVFL_N == 0) GENERATE
              ASSERT REPORT "Error:  The value for BAR2 parameter is incorrect; The allocated memory [2 GBytes] cannot be located below 1 Meg Space." 
              SEVERITY Error;
            ELSE GENERATE
              IF (CEIL(2^BAR2_READ_ONLY_BITS) >=   1073741824) GENERATE
                ASSERT REPORT "Error:  The value for BAR2 parameter is incorrect; The allocated memory [% GBytes] cannot be located below 1 Meg Space."  CEIL(2^BAR2_READ_ONLY_BITS) DIV  1073741824
                SEVERITY Error;
              END GENERATE;
              IF (CEIL(2^BAR2_READ_ONLY_BITS) >=  1048576 and (CEIL(2^BAR2_READ_ONLY_BITS) <   1073741824)) GENERATE
                ASSERT REPORT "Error:  The value for BAR2 parameter is incorrect; The allocated memory [% MBytes] cannot be located below 1 Meg Space."  CEIL(2^BAR2_READ_ONLY_BITS) DIV 1048576 
                SEVERITY error;
              END GENERATE;
              IF((CEIL(2^BAR2_READ_ONLY_BITS) >= 1024)  and (CEIL(2^BAR2_READ_ONLY_BITS) < 1048576)) GENERATE
                ASSERT REPORT "BAR2 Settings: Number of Address Bits Decoded = %, Size = % KBytes, Type = Memory, Location = Below 1 Meg Space, Prefetchable"
                  BAR2_COMP_WIDTH, CEIL(2^BAR2_READ_ONLY_BITS) DIV 1024
                SEVERITY INFO;
              END GENERATE;
              IF (CEIL(2^BAR2_READ_ONLY_BITS) < 1024) GENERATE
                ASSERT REPORT "BAR2 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = Memory, Location = Below 1 Meg Space, Prefetchable"
                  BAR2_COMP_WIDTH, CEIL(2^BAR2_READ_ONLY_BITS)
                SEVERITY INFO;
              END GENERATE;
            END GENERATE;
          END GENERATE;
    
          IF (BAR2_MEM_LOC > 1) GENERATE
            ASSERT REPORT " Illegal Memory Type Value for BAR2 "
            SEVERITY ERROR;
          END GENERATE;
        END GENERATE;
    END GENERATE;

    IF ( HARDWIRE_BAR2_ENA != 1) GENERATE 
      no_op[]       = no_op[] or bar2_ena3 or bar2_ena2 or bar2_ena1 or bar2_ena0;
      bar_selR[2]     = cfg_adr_dec_tmp_node[2];
      IF (LOCAL_CONFIG_ENA == "NO") GENERATE
        bar2_ena[3..0]    = bar_selR[2] and cfg_dat_vld and not(cben_IR[3..0]);
      ELSE  GENERATE
        bar2_ena[3..0]    = bar_selR[2] and lcfg_dat_vld and not lcfg_ben[3..0];
      END GENERATE;

      IF ((BAR0_MEM_LOC < 2 AND BAR1_MEM_LOC == 2)) GENERATE -- 64-Bit BAR1
        IF (MAX_64_BAR_RW_BITS == 32) GENERATE
          IF ( BAR2_READ_ONLY_BITS_64 > 0) GENERATE
            bar2_ro_bits_lower[BAR2_READ_ONLY_BITS_64-1..0]   = GND;  
          END GENERATE;
        ELSE GENERATE
          IF (BAR2_READ_ONLY_BITS_64 > 0) GENERATE
            bar2_ro_bits_upper[31..MAX_64_BAR_RW_BITS]      = GND;
            bar2_ro_bits_lower[BAR2_READ_ONLY_BITS_64-1..0]   = GND;    
          ELSE GENERATE
            bar2_ro_bits_upper[31..MAX_64_BAR_RW_BITS]      = GND;        
          END GENERATE;
        END GENERATE;
      ELSE GENERATE -- 32-Bit BAR2
        IF (BAR2_READ_ONLY_BITS > 4) GENERATE
          bar2_ro_bits[BAR2_READ_ONLY_BITS-1..4]  = GND;      -- BAR2 Read Only Bits
        END GENERATE;
      END GENERATE;
      -- Set BAR2 R/W Registers Controls
      bar2_reg[].clk  = clk ;
      bar2_reg[].clrn = rstN;
          
      IF (LOCAL_CONFIG_ENA == "NO") GENERATE
        IF ((BAR0_MEM_LOC < 2 AND BAR1_MEM_LOC == 2)) GENERATE  -- 64-Bit BAR1
          bar2_reg[].d  = ad_IR[MAX_64_BAR_RW_BITS-1 .. BAR2_READ_ONLY_BITS_64];
        ELSE GENERATE
          bar2_reg[].d  = ad_IR[31..BAR2_READ_ONLY_BITS];
        END GENERATE;
      ELSE  GENERATE
        IF ((BAR0_MEM_LOC < 2 AND BAR1_MEM_LOC == 2)) GENERATE -- 64-Bit BAR1
          bar2_reg[].d  = lcfg_dat_in[MAX_64_BAR_RW_BITS-1 .. BAR2_Read_ONLY_BITS];
        ELSE GENERATE -- 32-Bit BAR
          bar2_reg[].d  = lcfg_dat_in[31..BAR2_Read_ONLY_BITS];
        END GENERATE;
      END GENERATE;

      IF ((BAR0_MEM_LOC < 2 AND BAR1_MEM_LOC == 2)) GENERATE -- 64-Bit BAR1
        IF (MAX_64_BAR_RW_BITS  <= 8) GENERATE        -- BAR2 R/W Bits less than 8 
                                  -- Only Byte 0 has R/W Bits
          bar2_reg[MAX_64_BAR_RW_BITS-1.. BAR2_READ_ONLY_BITS_64].ena = bar2_ena[0];
        ELSE GENERATE
          IF (MAX_64_BAR_RW_BITS  <= 16) GENERATE     -- BAR2 R/W Bits > 8 and <= 16
            IF (BAR2_READ_ONLY_BITS_64 < 8) GENERATE  --  Byte 1, 0 Have R/W Bits
              bar2_reg[MAX_64_BAR_RW_BITS-1 .. 8].ena   = bar2_ena[1];
              bar2_reg[7 .. BAR2_READ_ONLY_BITS_64].ena   = bar2_ena[0];
            ELSE GENERATE -- Number of R/W Bits is less than 8
              bar2_reg[MAX_64_BAR_RW_BITS-1 .. BAR2_READ_ONLY_BITS_64].ena = bar2_ena[1];
            END GENERATE;
          ELSE GENERATE
            IF (MAX_64_BAR_RW_BITS  <= 24) GENERATE     -- BAR2 R/W Bits > 16 and <= 24
              IF (BAR2_READ_ONLY_BITS_64 < 8) GENERATE        -- Byte 2, 1, 0 Have R/W Bits
                bar2_reg[MAX_64_BAR_RW_BITS-1 .. 16].ena  = bar2_ena[2];
                bar2_reg[15 .. 8].ena             = bar2_ena[1];
                bar2_reg[7 .. BAR2_READ_ONLY_BITS_64].ena   = bar2_ena[0];
              ELSE GENERATE
                IF (BAR2_READ_ONLY_BITS_64 < 16) GENERATE     -- Byte 2, 1 Have R/W Bits
                  bar2_reg[MAX_64_BAR_RW_BITS-1 .. 16 ].ena   = bar2_ena[2];
                  bar2_reg[15 .. BAR2_READ_ONLY_BITS_64].ena  = bar2_ena[1];
                ELSE GENERATE 
                  IF (BAR2_READ_ONLY_BITS_64 < 24) GENERATE   -- Byte 2 Have R/W Bits
                    bar2_reg[MAX_64_BAR_RW_BITS-1 .. BAR2_READ_ONLY_BITS_64 ].ena   = bar2_ena[2];
                  END GENERATE;
                END GENERATE;
              END GENERATE;   
            ELSE GENERATE 
              --  MAX BAR2 R/W Bits > 24
              IF (BAR2_READ_ONLY_BITS_64 < 8) GENERATE        -- Byte 3, 2, 1, 0 Have R/W Bits
                bar2_reg[MAX_64_BAR_RW_BITS-1 .. 24].ena  = bar2_ena[3];
                bar2_reg[23 .. 16].ena            = bar2_ena[2];
                bar2_reg[15 .. 8].ena             = bar2_ena[1];
                bar2_reg[7 .. BAR2_READ_ONLY_BITS_64].ena   = bar2_ena[0];
              ELSE GENERATE
                IF (BAR2_READ_ONLY_BITS_64 < 16) GENERATE     -- Byte 3, 2, 1 Have R/W Bits
                  bar2_reg[MAX_64_BAR_RW_BITS-1 .. 24 ].ena   = bar2_ena[3];
                  bar2_reg[23 .. 16].ena            = bar2_ena[2];
                  bar2_reg[15 .. BAR2_READ_ONLY_BITS_64].ena  = bar2_ena[1];
                ELSE GENERATE 
                  IF (BAR2_READ_ONLY_BITS_64 < 24) GENERATE   -- Byte 3, 2 Have R/W Bits
                    bar2_reg[MAX_64_BAR_RW_BITS-1 .. 24 ].ena   = bar2_ena[3];
                    bar2_reg[23 .. BAR2_READ_ONLY_BITS_64 ].ena = bar2_ena[2];
                  ELSE GENERATE               -- Byte 3 Has R/W Bits  
                    bar2_reg[MAX_64_BAR_RW_BITS-1 .. BAR2_READ_ONLY_BITS_64 ].ena   = bar2_ena[3];
                  END GENERATE;
                END GENERATE;
              END GENERATE;   
            END GENERATE;         
          END GENERATE;   
        END GENERATE;
      ELSE GENERATE -- 32-Bit BAR2
        IF (BAR2_READ_ONLY_BITS < 8) GENERATE
          bar2_reg[31..24].ena            = bar2_ena[3];
          bar2_reg[23..16].ena            = bar2_ena[2];
          bar2_reg[15..8].ena             = bar2_ena[1];
          bar2_reg[7..BAR2_READ_ONLY_BITS].ena  = bar2_ena[0];
        ELSE GENERATE
          IF (BAR2_READ_ONLY_BITS < 16) GENERATE
            bar2_reg[31..24].ena            = bar2_ena[3];
            bar2_reg[23..16].ena            = bar2_ena[2];
            bar2_reg[15..BAR2_READ_ONLY_BITS].ena = bar2_ena[1];
          ELSE GENERATE 
            IF (BAR2_READ_ONLY_BITS < 24) GENERATE
              bar2_reg[31..24].ena            = bar2_ena[3];
              bar2_reg[23..BAR2_READ_ONLY_BITS].ena = bar2_ena[2];
            ELSE GENERATE
              bar2_reg[31..BAR2_READ_ONLY_BITS].ena = bar2_ena[3];
            END GENERATE;
          END GENERATE;
        END GENERATE;
      END GENERATE;
  
      -- Set the 32 bit value of BAR2
      IF ((BAR0_MEM_LOC < 2 AND BAR1_MEM_LOC == 2)) GENERATE -- 64-Bit BAR1
        IF( MAX_64_BAR_RW_BITS == 32) GENERATE -- MAX Number of BITS allowed for BAR2
          IF (BAR2_READ_ONLY_BITS_64 > 0) GENERATE
            bar_2[] = (bar2_reg[],bar2_ro_bits_lower[BAR2_READ_ONLY_BITS_64-1..0]);
          ELSE GENERATE
            bar_2[] = (bar2_reg[]);
          END GENERATE;
        ELSE GENERATE -- Some High Bits are Read Only
          IF (BAR2_READ_ONLY_BITS_64 > 0) GENERATE 
            bar_2[] = (bar2_ro_bits_upper[31..MAX_64_BAR_RW_BITS],bar2_reg[],bar2_ro_bits_lower[BAR2_READ_ONLY_BITS_64-1..0]);
          ELSE GENERATE -- BAR2_READ_ONLY_BITS_64 = 0
            bar_2[] = (bar2_ro_bits_upper[31..MAX_64_BAR_RW_BITS],bar2_reg[]);
          END GENERATE;
        END GENERATE;
      ELSE GENERATE -- 32-Bit BAR2
        IF (BAR2_READ_ONLY_BITS > 4) GENERATE
          bar_2[] = (bar2_reg[],bar2_ro_bits[BAR2_READ_ONLY_BITS-1..4],(bar_nibble2[]));    
        ELSE GENERATE
  	   IF (BAR2_READ_ONLY_BITS < 3) GENERATE
              bar_2[] = (bar2_reg[],(bar_nibble2[1..0]));
           ELSE GENERATE
              IF (BAR2_READ_ONLY_BITS < 4) GENERATE
                 bar_2[] = (bar2_reg[],(bar_nibble2[2..0]));
              ELSE GENERATE
                 bar_2[] = (bar2_reg[],(bar_nibble2[3..0]));
              END GENERATE;   
           END GENERATE;   
	END GENERATE;
      END GENERATE;


      -- Connect The Ports of BAR2 Address Comparator
      IF ((BAR0_MEM_LOC < 2 AND BAR1_MEM_LOC == 2)) GENERATE -- 64-Bit BAR1,2
        -- alz_bar2_64 checks if BAR2 is all Zero and therefore no need for compare
        alz_bar2_64.clk   = clk;
        alz_bar2_64.clrn  = rstn;
        alz_bar2_64     = bar2_reg[] == 0;
        
        no_op0        = alz_bar2_64;

-- Shoud not compare against when all zero        
        bar2_comp.dataa[] = bar2_reg[] ;
        bar2_comp.datab[] = ad_IR_addr[MAX_64_BAR_RW_BITS-1 .. BAR2_READ_ONLY_BITS_64]; 
        
        cyc_vld[2]      = (NOT bar_nibble1[0] and mem_cyc and mem_access_enable and dac_adr_phase_r and bar_hitR[1]);
        bar_hit[2]      = LCELL ( (alz_bar2_64 and bar_hit[1])
                      OR  (bar2_comp.aeb and cyc_vld[2])
                      );  
      ELSE GENERATE -- 32-Bit BAR2
        bar2_comp.dataa[] = bar2_reg[] ;
        bar2_comp.datab[] = ad_IR_addr[31 .. BAR2_READ_ONLY_BITS];  -- Only Upper Most Address Bits are Decoded
      --  bar_hit[2]      = bar2_comp.aeb and lcell ( adr_phase and (   ( NOT bar_nibble2[0] and mem_cyc and mem_access_enable and not dac_cfg)
      --                                    OR  ( bar_nibble2[0]   and io_cyc and io_access_enable)
      --                                     )
      --                             );
        cyc_vld[2]    =   (NOT bar_nibble2[0] and mem_cyc and mem_access_enable)
                OR  (bar_nibble2[0] and io_cyc and io_access_enable);
    
        bar_hit[2]    = LCELL(bar2_comp.aeb and adr_phase AND cyc_vld[2]);    
      END GENERATE;
      -- Set BAR2 Address Compare Hit Register Controls
      bar_hitR[2].clk   = clk;
      bar_hitR[2].clrn  = rstN;
              
      bar_hitR[2].r   = bar_hit_rst;

      bar_hitR[2].s   = bar_hit[2] ;

    ELSE GENERATE  -- Hardwire BAR2 is ON
      bar_2[31..0] = HARDWIRE_BAR2;
      bar_selR[2]     = cfg_adr_dec_tmp_node[2];  

      -- Set the 32 bit value of BAR2
      -- This was added because I/O Base Address register can have only 16 bytes available
      -- Connect The Ports of BAR2 Address Comparator
      IF ((BAR0_MEM_LOC < 2 AND BAR1_MEM_LOC == 2)) GENERATE -- 64-Bit BAR1
        
        alz_bar2_64.clk     = clk;
        alz_bar2_64.clrn    = rstn;
        alz_bar2_64       = bar[2][MAX_64_BAR_RW_BITS-1 .. BAR2_READ_ONLY_BITS_64] == 0;
        
        
        bar2_comp.dataa[] = bar_2[MAX_64_BAR_RW_BITS-1 .. BAR2_READ_ONLY_BITS_64] ;
        bar2_comp.datab[] = ad_IR_addr[MAX_64_BAR_RW_BITS-1 .. BAR2_READ_ONLY_BITS_64];
        cyc_vld[2]      = (NOT bar_nibble1[0] and mem_cyc and dac_adr_phase_r  and bar_hitR[1]);
        
        bar_hit[2]      = LCELL ( (alz_bar2_64 and bar_hit[1])
                      OR  (bar2_comp.aeb and cyc_vld[2])
                      );
        
      ELSE GENERATE -- 32-Bit BAR2
        bar2_comp.dataa[] = bar_2[31 .. BAR2_READ_ONLY_BITS] ;
        bar2_comp.datab[] = ad_IR_addr[31 .. BAR2_READ_ONLY_BITS];  -- Only Upper Most Address Bits are Decoded
      --  bar_hit[2]    = bar2_comp.aeb and lcell ( adr_phase and (   ( NOT bar_nibble2[0] and mem_cyc and mem_access_enable and not dac_cfg)
      --                                    OR  ( bar_nibble2[0]   and io_cyc and io_access_enable)
      --                                     )
      --                             );
        cyc_vld[2]    =   (NOT bar_nibble2[0] and mem_cyc)
              OR  (bar_nibble2[0] and io_cyc );
        bar_hit[2]    = LCELL(bar2_comp.aeb and adr_phase and cyc_vld[2]);
      END GENERATE;

      -- Set BAR2 Address Compare Hit Register Controls
  
      bar_hitR[2].clk   = clk;
      bar_hitR[2].clrn  = rstN;
      bar_hitR[2].r   = bar_hit_rst;
      bar_hitR[2].s = bar_hit[2] ;
    END GENERATE;

  ELSE GENERATE
    bar_hit[5..2] = GND;
    cyc_vld[5..2] = GND ;
    bar_selR[2]   = GND ;   -- Bar2 Register Select
    bar_hitR[5..2].clk = Clk;
    bar_hitR[5..2].clrn = rstN;
    bar_hitR[5..2].r = bar_hit_rst;
    bar_hitR[5..2].s  = GND;
    --bar[5..2][]   = H"00000000";
    bar_2[]   = H"00000000";
    bar_3[]   = H"00000000";
    bar_4[]   = H"00000000";
    bar_5[]   = H"00000000";
  END GENERATE;

IF (NUMBER_OF_BARS >= 1+3) GENERATE


  -- Check and REPORT value supplied for BAR3
--  IF (3 == 1) GENERATE ASSERT REPORT "this is bar 1" severity info; END GENERATE;
  IF (BAR3_TYPE == 1) GENERATE
    --IF (BAR3_MEM_LOC == 0 and BAR3_PREFETCH == 0 ) GENERATE
      ASSERT REPORT "BAR3 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = I/O"
        32-BAR3_READ_ONLY_BITS, CEIL(2^BAR3_READ_ONLY_BITS)
      SEVERITY INFO;
    --else GENERATE 
    --  ASSERT REPORT " Illegal Value [%] for BAR3 Parameter" BAR3
    --  SEVERITY ERROR;
    --end GENERATE;
  
  else GENERATE
    IF (BAR3_MEM_LOC == 0 and BAR3_PREFETCH == 0 ) GENERATE
      IF (BAR3_OVFL_N == 0) GENERATE
        ASSERT REPORT "BAR3 Settings: Number of Address Bits Decoded = %, Size = 2 GBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Non-Prefetchable"
        32-BAR3_READ_ONLY_BITS 
        SEVERITY INFO;
      ELSE GENERATE
        
        IF (CEIL(2^BAR3_READ_ONLY_BITS) >=   1073741824) GENERATE
          ASSERT REPORT "BAR3 Settings: Number of Address Bits Decoded = %, Size = % GBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Non-Prefetchable"
          32-BAR3_READ_ONLY_BITS, (2^BAR3_READ_ONLY_BITS) DIV  1073741824
          SEVERITY INFO;
        END GENERATE;
        IF (CEIL(2^BAR3_READ_ONLY_BITS) >=  1048576 and (CEIL(2^BAR3_READ_ONLY_BITS) <   1073741824)) GENERATE
          ASSERT REPORT "BAR3 Settings: Number of Address Bits Decoded = %, Size = % MBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Non-Prefetchable"
          32-BAR3_READ_ONLY_BITS, CEIL(2^BAR3_READ_ONLY_BITS) DIV 1048576 
          SEVERITY INFO;
        END GENERATE;
        IF((CEIL(2^BAR3_READ_ONLY_BITS) >= 1024)  and (CEIL(2^BAR3_READ_ONLY_BITS) < 1048576)) GENERATE
          ASSERT REPORT "BAR3 Settings: Number of Address Bits Decoded = %, Size = % KBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Non-Prefetchable"
            32-BAR3_READ_ONLY_BITS, CEIL(2^BAR3_READ_ONLY_BITS) DIV 1024
          SEVERITY INFO;
        END GENERATE;
        IF (CEIL(2^BAR3_READ_ONLY_BITS) < 1024) GENERATE
          ASSERT REPORT "BAR3 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Non-Prefetchable"
            32-BAR3_READ_ONLY_BITS, CEIL(2^BAR3_READ_ONLY_BITS)
          SEVERITY INFO;
        END GENERATE;
      
      END GENERATE;
      
      
    END GENERATE;
    
    IF (BAR3_MEM_LOC == 0 and BAR3_PREFETCH == 1 ) GENERATE
      IF (BAR3_OVFL_N == 0) GENERATE
        ASSERT REPORT "BAR3 Settings: Number of Address Bits Decoded = %, Size = 2 GBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Prefetchable"
        32-BAR3_READ_ONLY_BITS 
        SEVERITY INFO;
      ELSE GENERATE
        
        IF (CEIL(2^BAR3_READ_ONLY_BITS) >=   1073741824) GENERATE
          ASSERT REPORT "BAR3 Settings: Number of Address Bits Decoded = %, Size = % GBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Prefetchable"
          32-BAR3_READ_ONLY_BITS, CEIL(2^BAR3_READ_ONLY_BITS) DIV  1073741824
          SEVERITY INFO;
        END GENERATE;
        IF (CEIL(2^BAR3_READ_ONLY_BITS) >=  1048576 and (CEIL(2^BAR3_READ_ONLY_BITS) <   1073741824)) GENERATE
          ASSERT REPORT "BAR3 Settings: Number of Address Bits Decoded = %, Size = % MBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Prefetchable"
          32-BAR3_READ_ONLY_BITS, CEIL(2^BAR3_READ_ONLY_BITS) DIV 1048576 
          SEVERITY INFO;
        END GENERATE;
        IF((CEIL(2^BAR3_READ_ONLY_BITS) >= 1024)  and (CEIL(2^BAR3_READ_ONLY_BITS) < 1048576)) GENERATE
          ASSERT REPORT "BAR3 Settings: Number of Address Bits Decoded = %, Size = % KBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Prefetchable"
            32-BAR3_READ_ONLY_BITS, CEIL(2^BAR3_READ_ONLY_BITS) DIV 1024
          SEVERITY INFO;
        END GENERATE;
        IF (CEIL(2^BAR3_READ_ONLY_BITS) < 1024) GENERATE
          ASSERT REPORT "BAR3 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Prefetchable"
            32-BAR3_READ_ONLY_BITS, CEIL(2^BAR3_READ_ONLY_BITS)
          SEVERITY INFO;
        END GENERATE;
      
      END GENERATE;
    
    END GENERATE;
    
    IF(BAR3_MEM_LOC == 1 and BAR3_PREFETCH == 0 ) GENERATE
    
      IF (BAR3_OVFL_N == 0) GENERATE
        ASSERT REPORT "Error:  The value for BAR3 parameter is incorrect; The allocated memory [2 GBytes] cannot be located below 1 Meg Space." 
        SEVERITY Error;
      ELSE GENERATE
        
        IF (CEIL(2^BAR3_READ_ONLY_BITS) >=   1073741824) GENERATE
          ASSERT REPORT "Error:  The value for BAR3 parameter is incorrect; The allocated memory [% GBytes] cannot be located below 1 Meg Space."  CEIL(2^BAR3_READ_ONLY_BITS) DIV  1073741824
          SEVERITY Error;
        END GENERATE;
        IF (CEIL(2^BAR3_READ_ONLY_BITS) >=  1048576 and (CEIL(2^BAR3_READ_ONLY_BITS) <   1073741824)) GENERATE
          ASSERT REPORT "Error:  The value for BAR3 parameter is incorrect; The allocated memory [% MBytes] cannot be located below 1 Meg Space."  CEIL(2^BAR3_READ_ONLY_BITS) DIV 1048576 
          SEVERITY error;
        END GENERATE;
        IF((CEIL(2^BAR3_READ_ONLY_BITS) >= 1024)  and (CEIL(2^BAR3_READ_ONLY_BITS) < 1048576)) GENERATE
          ASSERT REPORT "BAR3 Settings: Number of Address Bits Decoded = %, Size = % KBytes, Type = Memory, Location = Below 1 Meg Space, Non-Prefetchable"
            32-BAR3_READ_ONLY_BITS, CEIL(2^BAR3_READ_ONLY_BITS) DIV 1024
          SEVERITY INFO;
        END GENERATE;
        IF (CEIL(2^BAR3_READ_ONLY_BITS) < 1024) GENERATE
          ASSERT REPORT "BAR3 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = Memory, Location = Below 1 Meg Space, Non-Prefetchable"
            32-BAR3_READ_ONLY_BITS, CEIL(2^BAR3_READ_ONLY_BITS)
          SEVERITY INFO;
        END GENERATE;
      
      END GENERATE;

    END GENERATE;
    IF (BAR3_MEM_LOC == 1 and BAR3_PREFETCH == 1 ) GENERATE

      IF (BAR3_OVFL_N == 0) GENERATE
        ASSERT REPORT "Error:  The value for BAR3 parameter is incorrect; The allocated memory [2 GBytes] cannot be located below 1 Meg Space." 
        SEVERITY Error;
      ELSE GENERATE
        
        IF (CEIL(2^BAR3_READ_ONLY_BITS) >=   1073741824) GENERATE
          ASSERT REPORT "Error:  The value for BAR3 parameter is incorrect; The allocated memory [% GBytes] cannot be located below 1 Meg Space."  CEIL(2^BAR3_READ_ONLY_BITS) DIV  1073741824
          SEVERITY Error;
        END GENERATE;
        IF (CEIL(2^BAR3_READ_ONLY_BITS) >=  1048576 and (CEIL(2^BAR3_READ_ONLY_BITS) <   1073741824)) GENERATE
          ASSERT REPORT "Error:  The value for BAR3 parameter is incorrect; The allocated memory [% MBytes] cannot be located below 1 Meg Space."  CEIL(2^BAR3_READ_ONLY_BITS) DIV 1048576 
          SEVERITY error;
        END GENERATE;
        IF((CEIL(2^BAR3_READ_ONLY_BITS) >= 1024)  and (CEIL(2^BAR3_READ_ONLY_BITS) < 1048576)) GENERATE
          ASSERT REPORT "BAR3 Settings: Number of Address Bits Decoded = %, Size = % KBytes, Type = Memory, Location = Below 1 Meg Space, Prefetchable"
            32-BAR3_READ_ONLY_BITS, CEIL(2^BAR3_READ_ONLY_BITS) DIV 1024
          SEVERITY INFO;
        END GENERATE;
        IF (CEIL(2^BAR3_READ_ONLY_BITS) < 1024) GENERATE
          ASSERT REPORT "BAR3 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = Memory, Location = Below 1 Meg Space, Prefetchable"
            32-BAR3_READ_ONLY_BITS, CEIL(2^BAR3_READ_ONLY_BITS)
          SEVERITY INFO;
        END GENERATE;
      
      END GENERATE;

    END GENERATE;
    IF (BAR3_MEM_LOC > 1) GENERATE
      ASSERT REPORT " Illegal Memory Type Value for BAR3 "
      SEVERITY ERROR;
    end GENERATE;
  end GENERATE;

 IF ( HARDWIRE_BAR3_ENA != 1) GENERATE

  no_op[]       = no_op[] or bar3_ena3 or bar3_ena2 or bar3_ena1 or bar3_ena0;

  bar_selR[3]     = cfg_adr_dec_tmp_node[3];
  
  IF (LOCAL_CONFIG_ENA == "NO") GENERATE
  
    bar3_ena[3..0]    = bar_selR[3] and cfg_dat_vld and not(cben_IR[3..0]);
  
  ELSE  GENERATE
  
    bar3_ena[3..0]    = bar_selR[3] and lcfg_dat_vld and not lcfg_ben[3..0];
  
  END GENERATE;
  
  IF (BAR3_READ_ONLY_BITS > 4) GENERATE
  
    bar3_ro_bits[BAR3_READ_ONLY_BITS-1..4]  = GND;      -- BAR3 Read Only Bits
    
  END GENERATE;
  

  -- Set BAR3 R/W Registers Controls

  bar3_reg[].clk  = clk ;
  bar3_reg[].clrn = rstN;
  
  IF (LOCAL_CONFIG_ENA == "NO") GENERATE
    bar3_reg[].d  = ad_IR[31..BAR3_READ_ONLY_BITS];

  ELSE  GENERATE
    bar3_reg[].d  = lcfg_dat_in[31..Bar3_Read_ONLY_BITS];

  END GENERATE;
  
  IF (BAR3_READ_ONLY_BITS < 8) GENERATE

    bar3_reg[31..24].ena            = bar3_ena[3];
    bar3_reg[23..16].ena            = bar3_ena[2];
    bar3_reg[15..8].ena             = bar3_ena[1];
    bar3_reg[7..BAR3_READ_ONLY_BITS].ena  = bar3_ena[0];

  ELSE GENERATE
    
    IF (BAR3_READ_ONLY_BITS < 16) GENERATE
    
      bar3_reg[31..24].ena            = bar3_ena[3];
      bar3_reg[23..16].ena            = bar3_ena[2];
      bar3_reg[15..BAR3_READ_ONLY_BITS].ena = bar3_ena[1];
    
    ELSE GENERATE 
      
      IF (BAR3_READ_ONLY_BITS < 24) GENERATE
      
        bar3_reg[31..24].ena            = bar3_ena[3];
        bar3_reg[23..BAR3_READ_ONLY_BITS].ena = bar3_ena[2];
      
      ELSE GENERATE
      
        bar3_reg[31..BAR3_READ_ONLY_BITS].ena = bar3_ena[3];
      
      END GENERATE;

    END GENERATE;

  END GENERATE;
  
  -- Set the 32 bit value of BAR3
  -- This was added because I/O Base Address register can have only 16 bytes available
  IF (BAR3_READ_ONLY_BITS > 4) GENERATE
    
    bar_3[] = (bar3_reg[],bar3_ro_bits[BAR3_READ_ONLY_BITS-1..4],(bar_nibble3[]));

  ELSE GENERATE
    
  	   IF (BAR3_READ_ONLY_BITS < 3) GENERATE
              bar_3[] = (bar3_reg[],(bar_nibble3[1..0]));
           ELSE GENERATE
              IF (BAR3_READ_ONLY_BITS < 4) GENERATE
                 bar_3[] = (bar3_reg[],(bar_nibble3[2..0]));
              ELSE GENERATE
                 bar_3[] = (bar3_reg[],(bar_nibble3[3..0]));
              END GENERATE;   
           END GENERATE;   

  END GENERATE;



  -- Connect The Ports of BAR3 Address Comparator

  bar3_comp.dataa[] = bar3_reg[] ;
  bar3_comp.datab[] = ad_IR_addr[31 .. BAR3_READ_ONLY_BITS];  -- Only Upper Most Address Bits are Decoded
--  bar_hit[3]    = bar3_comp.aeb and lcell ( adr_phase and (   ( NOT bar_nibble[3][0] and mem_cyc and mem_access_enable and not dac_cfg)
--                                    OR  ( bar_nibble[3][0]   and io_cyc and io_access_enable)
--                                     )
--                             );

  cyc_vld[3]  =   (NOT bar_nibble3[0]  and mem_cyc and mem_access_enable)
        OR  (bar_nibble3[0] and io_cyc and io_access_enable);

  bar_hit[3]    = LCELL(bar3_comp.aeb and adr_phase and cyc_vld[3] );


  -- Set BAR3 Address Compare Hit Register Controls
  
  bar_hitR[3].clk   = clk;
  bar_hitR[3].clrn  = rstN;
              
  bar_hitR[3].r   = bar_hit_rst;

  bar_hitR[3].s = bar_hit[3] ;
  ELSE GENERATE
  bar_3[31..0] = HARDWIRE_BAR3;
  bar_selR[3]     = cfg_adr_dec_tmp_node[3];
    

  -- Connect The Ports of BAR3 Address Comparator

  bar3_comp.dataa[] = bar_3[31 .. BAR3_READ_ONLY_BITS] ;
  bar3_comp.datab[] = ad_IR_addr[31 .. BAR3_READ_ONLY_BITS];  -- Only Upper Most Address Bits are Decoded
--  bar_hit[3]    = bar3_comp.aeb and lcell ( adr_phase and (   ( NOT bar_nibble3[0] and mem_cyc and mem_access_enable and not dac_cfg)
--                                    OR  ( bar_nibble3[0]   and io_cyc and io_access_enable)
--                                     )
--                             );

  cyc_vld[3]  =   (NOT bar_nibble3[0]  and mem_cyc )
        OR  (bar_nibble3[0] and io_cyc );

  bar_hit[3]    = LCELL(bar3_comp.aeb and adr_phase and cyc_vld[3] );


  -- Set BAR3 Address Compare Hit Register Controls
  
  bar_hitR[3].clk   = clk;
  bar_hitR[3].clrn  = rstN;
              
  bar_hitR[3].r   = bar_hit_rst;

  bar_hitR[3].s = bar_hit[3] ;
  END GENERATE;
ELSE GENERATE
  bar_hit[5..3] = GND;
  bar_selR[3]   = GND ;   -- Bar3 Register Select
  cyc_vld[5..3] = GND ;
  bar_hitR[5..3].clk = Clk;
  bar_hitR[5..3].clrn = rstN;
  bar_hitR[5..3].r = bar_hit_rst;
  bar_hitR[5..3].s  = GND;
  --bar[5..3][]   = H"00000000";
  bar_3[]   = H"00000000";
  bar_4[]   = H"00000000";
  bar_5[]   = H"00000000";
END GENERATE;


IF (NUMBER_OF_BARS >= 1+4) GENERATE


  -- Check and REPORT value supplied for BAR4
--  IF (4 == 1) GENERATE ASSERT REPORT "this is bar 1" severity info; END GENERATE;
  IF (BAR4_TYPE == 1) GENERATE
    --IF (BAR4_MEM_LOC == 0 and BAR4_PREFETCH == 0 ) GENERATE
      ASSERT REPORT "BAR4 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = I/O"
        32-BAR4_READ_ONLY_BITS, CEIL(2^BAR4_READ_ONLY_BITS)
      SEVERITY INFO;
   -- else GENERATE 
   --   ASSERT REPORT " Illegal Value [%] for BAR4 Parameter" BAR4
   --   SEVERITY ERROR;
   -- end GENERATE;
  
  else GENERATE
    IF (BAR4_MEM_LOC == 0 and BAR4_PREFETCH == 0 ) GENERATE
      IF (BAR4_OVFL_N == 0) GENERATE
        ASSERT REPORT "BAR4 Settings: Number of Address Bits Decoded = %, Size = 2 GBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Non-Prefetchable"
        32-BAR4_READ_ONLY_BITS 
        SEVERITY INFO;
      ELSE GENERATE
        
        IF (CEIL(2^BAR4_READ_ONLY_BITS) >=   1073741824) GENERATE
          ASSERT REPORT "BAR4 Settings: Number of Address Bits Decoded = %, Size = % GBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Non-Prefetchable"
          32-BAR4_READ_ONLY_BITS, (2^BAR4_READ_ONLY_BITS) DIV  1073741824
          SEVERITY INFO;
        END GENERATE;
        IF (CEIL(2^BAR4_READ_ONLY_BITS) >=  1048576 and (CEIL(2^BAR4_READ_ONLY_BITS) <   1073741824)) GENERATE
          ASSERT REPORT "BAR4 Settings: Number of Address Bits Decoded = %, Size = % MBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Non-Prefetchable"
          32-BAR4_READ_ONLY_BITS, CEIL(2^BAR4_READ_ONLY_BITS) DIV 1048576 
          SEVERITY INFO;
        END GENERATE;
        IF((CEIL(2^BAR4_READ_ONLY_BITS) >= 1024)  and (CEIL(2^BAR4_READ_ONLY_BITS) < 1048576)) GENERATE
          ASSERT REPORT "BAR4 Settings: Number of Address Bits Decoded = %, Size = % KBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Non-Prefetchable"
            32-BAR4_READ_ONLY_BITS, CEIL(2^BAR4_READ_ONLY_BITS) DIV 1024
          SEVERITY INFO;
        END GENERATE;
        IF (CEIL(2^BAR4_READ_ONLY_BITS) < 1024) GENERATE
          ASSERT REPORT "BAR4 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Non-Prefetchable"
            32-BAR4_READ_ONLY_BITS, CEIL(2^BAR4_READ_ONLY_BITS)
          SEVERITY INFO;
        END GENERATE;
      
      END GENERATE;
      
      
    END GENERATE;
    
    IF (BAR4_MEM_LOC == 0 and BAR4_PREFETCH == 1 ) GENERATE
      IF (BAR4_OVFL_N == 0) GENERATE
        ASSERT REPORT "BAR4 Settings: Number of Address Bits Decoded = %, Size = 2 GBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Prefetchable"
        32-BAR4_READ_ONLY_BITS 
        SEVERITY INFO;
      ELSE GENERATE
        
        IF (CEIL(2^BAR4_READ_ONLY_BITS) >=   1073741824) GENERATE
          ASSERT REPORT "BAR4 Settings: Number of Address Bits Decoded = %, Size = % GBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Prefetchable"
          32-BAR4_READ_ONLY_BITS, CEIL(2^BAR4_READ_ONLY_BITS) DIV  1073741824
          SEVERITY INFO;
        END GENERATE;
        IF (CEIL(2^BAR4_READ_ONLY_BITS) >=  1048576 and (CEIL(2^BAR4_READ_ONLY_BITS) <   1073741824)) GENERATE
          ASSERT REPORT "BAR4 Settings: Number of Address Bits Decoded = %, Size = % MBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Prefetchable"
          32-BAR4_READ_ONLY_BITS, CEIL(2^BAR4_READ_ONLY_BITS) DIV 1048576 
          SEVERITY INFO;
        END GENERATE;
        IF((CEIL(2^BAR4_READ_ONLY_BITS) >= 1024)  and (CEIL(2^BAR4_READ_ONLY_BITS) < 1048576)) GENERATE
          ASSERT REPORT "BAR4 Settings: Number of Address Bits Decoded = %, Size = % KBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Prefetchable"
            32-BAR4_READ_ONLY_BITS, CEIL(2^BAR4_READ_ONLY_BITS) DIV 1024
          SEVERITY INFO;
        END GENERATE;
        IF (CEIL(2^BAR4_READ_ONLY_BITS) < 1024) GENERATE
          ASSERT REPORT "BAR4 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Prefetchable"
            32-BAR4_READ_ONLY_BITS, CEIL(2^BAR4_READ_ONLY_BITS)
          SEVERITY INFO;
        END GENERATE;
      
      END GENERATE;
    
    END GENERATE;
    
    IF(BAR4_MEM_LOC == 1 and BAR4_PREFETCH == 0 ) GENERATE
    
      IF (BAR4_OVFL_N == 0) GENERATE
        ASSERT REPORT "Error:  The value for BAR0 parameter is incorrect; The allocated memory [2 GBytes] cannot be located below 1 Meg Space." 
        SEVERITY Error;
      ELSE GENERATE
        
        IF (CEIL(2^BAR4_READ_ONLY_BITS) >=   1073741824) GENERATE
          ASSERT REPORT "Error:  The value for BAR4 parameter is incorrect; The allocated memory [% GBytes] cannot be located below 1 Meg Space."  CEIL(2^BAR4_READ_ONLY_BITS) DIV  1073741824
          SEVERITY Error;
        END GENERATE;
        IF (CEIL(2^BAR4_READ_ONLY_BITS) >=  1048576 and (CEIL(2^BAR4_READ_ONLY_BITS) <   1073741824)) GENERATE
          ASSERT REPORT "Error:  The value for BAR4 parameter is incorrect; The allocated memory [% MBytes] cannot be located below 1 Meg Space."  CEIL(2^BAR4_READ_ONLY_BITS) DIV 1048576 
          SEVERITY error;
        END GENERATE;
        IF((CEIL(2^BAR4_READ_ONLY_BITS) >= 1024)  and (CEIL(2^BAR4_READ_ONLY_BITS) < 1048576)) GENERATE
          ASSERT REPORT "BAR4 Settings: Number of Address Bits Decoded = %, Size = % KBytes, Type = Memory, Location = Below 1 Meg Space, Non-Prefetchable"
            32-BAR4_READ_ONLY_BITS, CEIL(2^BAR4_READ_ONLY_BITS) DIV 1024
          SEVERITY INFO;
        END GENERATE;
        IF (CEIL(2^BAR4_READ_ONLY_BITS) < 1024) GENERATE
          ASSERT REPORT "BAR4 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = Memory, Location = Below 1 Meg Space, Non-Prefetchable"
            32-BAR4_READ_ONLY_BITS, CEIL(2^BAR4_READ_ONLY_BITS)
          SEVERITY INFO;
        END GENERATE;
      
      END GENERATE;

    END GENERATE;
    IF (BAR4_MEM_LOC == 1 and BAR4_PREFETCH == 1 ) GENERATE

      IF (BAR4_OVFL_N == 0) GENERATE
        ASSERT REPORT "Error:  The value for BAR4 parameter is incorrect; The allocated memory [2 GBytes] cannot be located below 1 Meg Space." 
        SEVERITY Error;
      ELSE GENERATE
        
        IF (CEIL(2^BAR4_READ_ONLY_BITS) >=   1073741824) GENERATE
          ASSERT REPORT "Error:  The value for BAR4 parameter is incorrect; The allocated memory [% GBytes] cannot be located below 1 Meg Space."  CEIL(2^BAR4_READ_ONLY_BITS) DIV  1073741824
          SEVERITY Error;
        END GENERATE;
        IF (CEIL(2^BAR4_READ_ONLY_BITS) >=  1048576 and (CEIL(2^BAR4_READ_ONLY_BITS) <   1073741824)) GENERATE
          ASSERT REPORT "Error:  The value for BAR4 parameter is incorrect; The allocated memory [% MBytes] cannot be located below 1 Meg Space."  CEIL(2^BAR4_READ_ONLY_BITS) DIV 1048576 
          SEVERITY error;
        END GENERATE;
        IF((CEIL(2^BAR4_READ_ONLY_BITS) >= 1024)  and (CEIL(2^BAR4_READ_ONLY_BITS) < 1048576)) GENERATE
          ASSERT REPORT "BAR4 Settings: Number of Address Bits Decoded = %, Size = % KBytes, Type = Memory, Location = Below 1 Meg Space, Prefetchable"
            32-BAR4_READ_ONLY_BITS, CEIL(2^BAR4_READ_ONLY_BITS) DIV 1024
          SEVERITY INFO;
        END GENERATE;
        IF (CEIL(2^BAR4_READ_ONLY_BITS) < 1024) GENERATE
          ASSERT REPORT "BAR4 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = Memory, Location = Below 1 Meg Space, Prefetchable"
            32-BAR4_READ_ONLY_BITS, CEIL(2^BAR4_READ_ONLY_BITS)
          SEVERITY INFO;
        END GENERATE;
      
      END GENERATE;

    END GENERATE;
    IF (BAR4_MEM_LOC > 1) GENERATE
      ASSERT REPORT " Illegal Memory Type Value for BAR4 "
      SEVERITY ERROR;
    end GENERATE;
  end GENERATE;

 IF ( HARDWIRE_BAR4_ENA != 1) GENERATE

  no_op[]       = no_op[] or bar4_ena3 or bar4_ena2 or bar4_ena1 or bar4_ena0;

  bar_selR[4]     = cfg_adr_dec_tmp_node[4];
  
  IF (LOCAL_CONFIG_ENA == "NO") GENERATE
  
    bar4_ena[3..0]    = bar_selR[4] and cfg_dat_vld and not(cben_IR[3..0]);
  
  ELSE  GENERATE
  
    bar4_ena[3..0]    = bar_selR[4] and lcfg_dat_vld and not lcfg_ben[3..0];
  
  END GENERATE;
  
  IF (BAR4_READ_ONLY_BITS > 4) GENERATE
  
    bar4_ro_bits[BAR4_READ_ONLY_BITS-1..4]  = GND;      -- BAR4 Read Only Bits
    
  END GENERATE;
  

  -- Set BAR4 R/W Registers Controls

  bar4_reg[].clk  = clk ;
  bar4_reg[].clrn = rstN;
  
  IF (LOCAL_CONFIG_ENA == "NO") GENERATE
    bar4_reg[].d  = ad_IR[31..BAR4_READ_ONLY_BITS];

  ELSE  GENERATE
    bar4_reg[].d  = lcfg_dat_in[31..Bar4_Read_ONLY_BITS];

  END GENERATE;
  
  IF (BAR4_READ_ONLY_BITS < 8) GENERATE

    bar4_reg[31..24].ena            = bar4_ena[3];
    bar4_reg[23..16].ena            = bar4_ena[2];
    bar4_reg[15..8].ena             = bar4_ena[1];
    bar4_reg[7..BAR4_READ_ONLY_BITS].ena  = bar4_ena[0];

  ELSE GENERATE
    
    IF (BAR4_READ_ONLY_BITS < 16) GENERATE
    
      bar4_reg[31..24].ena            = bar4_ena[3];
      bar4_reg[23..16].ena            = bar4_ena[2];
      bar4_reg[15..BAR4_READ_ONLY_BITS].ena = bar4_ena[1];
    
    ELSE GENERATE 
      
      IF (BAR4_READ_ONLY_BITS < 24) GENERATE
      
        bar4_reg[31..24].ena            = bar4_ena[3];
        bar4_reg[23..BAR4_READ_ONLY_BITS].ena = bar4_ena[2];
      
      ELSE GENERATE
      
        bar4_reg[31..BAR4_READ_ONLY_BITS].ena = bar4_ena[3];
      
      END GENERATE;

    END GENERATE;

  END GENERATE;
  
  -- Set the 32 bit value of BAR4
  -- This was added because I/O Base Address register can have only 16 bytes available
  IF (BAR4_READ_ONLY_BITS > 4) GENERATE
    
    bar_4[] = (bar4_reg[],bar4_ro_bits[BAR4_READ_ONLY_BITS-1..4],(bar_nibble4[]));

  ELSE GENERATE
    
  	   IF (BAR4_READ_ONLY_BITS < 3) GENERATE
              bar_4[] = (bar4_reg[],(bar_nibble4[1..0]));
           ELSE GENERATE
              IF (BAR4_READ_ONLY_BITS < 4) GENERATE
                 bar_4[] = (bar4_reg[],(bar_nibble4[2..0]));
              ELSE GENERATE
                 bar_4[] = (bar4_reg[],(bar_nibble4[3..0]));
              END GENERATE;   
           END GENERATE;   

  END GENERATE;



  -- Connect The Ports of BAR4 Address Comparator

  bar4_comp.dataa[] = bar4_reg[] ;
  bar4_comp.datab[] = ad_IR_addr[31 .. BAR4_READ_ONLY_BITS];  -- Only Upper Most Address Bits are Decoded
--  bar_hit[4]    = bar4_comp.aeb and lcell ( adr_phase and (   ( NOT bar_nibble4[0] and mem_cyc and mem_access_enable and not dac_cfg)
--                                    OR  ( bar_nibble4[0]   and io_cyc and io_access_enable)
--                                     )
--                             );
  cyc_vld[4]  =   (NOT bar_nibble4[0]  and mem_cyc and mem_access_enable)
        OR  (bar_nibble4[0] and io_cyc and io_access_enable);

  bar_hit[4]    = LCELL(bar4_comp.aeb and adr_phase and cyc_vld[4] );

  -- Set BAR4 Address Compare Hit Register Controls
  
  bar_hitR[4].clk   = clk;
  bar_hitR[4].clrn  = rstN;
              
  bar_hitR[4].r   = bar_hit_rst;

  bar_hitR[4].s = bar_hit[4] ;
  ELSE GENERATE
  bar_4[31..0] = HARDWIRE_BAR4;
    
  bar_selR[4]     = cfg_adr_dec_tmp_node[4];
  
    
  -- Connect The Ports of BAR4 Address Comparator

  bar4_comp.dataa[] = bar_4[31 .. BAR4_READ_ONLY_BITS] ;
  bar4_comp.datab[] = ad_IR_addr[31 .. BAR4_READ_ONLY_BITS];  -- Only Upper Most Address Bits are Decoded
--  bar_hit[4]    = bar4_comp.aeb and lcell ( adr_phase and (   ( NOT bar_nibble4[0] and mem_cyc and mem_access_enable and not dac_cfg)
--                                    OR  ( bar_nibble4[0]   and io_cyc and io_access_enable)
--                                     )
--                             );
  cyc_vld[4]  =   (NOT bar_nibble4[0]  and mem_cyc )
        OR  (bar_nibble4[0] and io_cyc );

  bar_hit[4]    = LCELL(bar4_comp.aeb and adr_phase and cyc_vld[4] );


  -- Set BAR4 Address Compare Hit Register Controls
  
  bar_hitR[4].clk   = clk;
  bar_hitR[4].clrn  = rstN;
              
  bar_hitR[4].r   = bar_hit_rst;

  bar_hitR[4].s = bar_hit[4] ;
  END GENERATE;
ELSE GENERATE
  bar_hit[5..4] = GND;
  bar_selR[4]   = GND ;   -- Bar4 Register Select
  cyc_vld[5..4] = GND;
  bar_hitR[5..4].clk = Clk;
  bar_hitR[5..4].clrn = rstN;
  bar_hitR[5..4].r = bar_hit_rst;
  bar_hitR[5..4].s  = GND;
--  bar[5..4][]   = H"00000000";
       bar_4[]    = H"00000000";
       bar_5[]    = H"00000000";
END GENERATE;


IF (NUMBER_OF_BARS >= 1+5) GENERATE

  -- Check and REPORT value supplied for BAR5
--  IF (5 == 1) GENERATE ASSERT REPORT "this is bar 1" severity info; END GENERATE;
  IF (BAR5_TYPE == 1) GENERATE
    --IF (BAR5_MEM_LOC == 0 and BAR5_PREFETCH == 0 ) GENERATE
      ASSERT REPORT "BAR5 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = I/O"
        32-BAR5_READ_ONLY_BITS, CEIL(2^BAR5_READ_ONLY_BITS)
      SEVERITY INFO;
    --else GENERATE 
    --  ASSERT REPORT " Illegal Value [%] for BAR5 Parameter" BAR5
    --  SEVERITY ERROR;
    --end GENERATE;
  
  else GENERATE
    IF (BAR5_MEM_LOC == 0 and BAR5_PREFETCH == 0 ) GENERATE
      IF (BAR5_OVFL_N == 0) GENERATE
        ASSERT REPORT "BAR5 Settings: Number of Address Bits Decoded = %, Size = 2 GBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Non-Prefetchable"
        32-BAR5_READ_ONLY_BITS 
        SEVERITY INFO;
      ELSE GENERATE
        
        IF (CEIL(2^BAR5_READ_ONLY_BITS) >=   1073741824) GENERATE
          ASSERT REPORT "BAR5 Settings: Number of Address Bits Decoded = %, Size = % GBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Non-Prefetchable"
          32-BAR5_READ_ONLY_BITS, (2^BAR5_READ_ONLY_BITS) DIV  1073741824
          SEVERITY INFO;
        END GENERATE;
        IF (CEIL(2^BAR5_READ_ONLY_BITS) >=  1048576 and (CEIL(2^BAR5_READ_ONLY_BITS) <   1073741824)) GENERATE
          ASSERT REPORT "BAR5 Settings: Number of Address Bits Decoded = %, Size = % MBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Non-Prefetchable"
          32-BAR5_READ_ONLY_BITS, CEIL(2^BAR5_READ_ONLY_BITS) DIV 1048576 
          SEVERITY INFO;
        END GENERATE;
        IF((CEIL(2^BAR5_READ_ONLY_BITS) >= 1024)  and (CEIL(2^BAR5_READ_ONLY_BITS) < 1048576)) GENERATE
          ASSERT REPORT "BAR5 Settings: Number of Address Bits Decoded = %, Size = % KBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Non-Prefetchable"
            32-BAR5_READ_ONLY_BITS, CEIL(2^BAR5_READ_ONLY_BITS) DIV 1024
          SEVERITY INFO;
        END GENERATE;
        IF (CEIL(2^BAR5_READ_ONLY_BITS) < 1024) GENERATE
          ASSERT REPORT "BAR5 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Non-Prefetchable"
            32-BAR5_READ_ONLY_BITS, CEIL(2^BAR5_READ_ONLY_BITS)
          SEVERITY INFO;
        END GENERATE;
      
      END GENERATE;
      
      
    END GENERATE;
    
    IF (BAR5_MEM_LOC == 0 and BAR5_PREFETCH == 1 ) GENERATE
      IF (BAR5_OVFL_N == 0) GENERATE
        ASSERT REPORT "BAR5 Settings: Number of Address Bits Decoded = %, Size = 2 GBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Prefetchable"
        32-BAR5_READ_ONLY_BITS 
        SEVERITY INFO;
      ELSE GENERATE
        
        IF (CEIL(2^BAR5_READ_ONLY_BITS) >=   1073741824) GENERATE
          ASSERT REPORT "BAR5 Settings: Number of Address Bits Decoded = %, Size = % GBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Prefetchable"
          32-BAR5_READ_ONLY_BITS, CEIL(2^BAR5_READ_ONLY_BITS) DIV  1073741824
          SEVERITY INFO;
        END GENERATE;
        IF (CEIL(2^BAR5_READ_ONLY_BITS) >=  1048576 and (CEIL(2^BAR5_READ_ONLY_BITS) <   1073741824)) GENERATE
          ASSERT REPORT "BAR5 Settings: Number of Address Bits Decoded = %, Size = % MBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Prefetchable"
          32-BAR5_READ_ONLY_BITS, CEIL(2^BAR5_READ_ONLY_BITS) DIV 1048576 
          SEVERITY INFO;
        END GENERATE;
        IF((CEIL(2^BAR5_READ_ONLY_BITS) >= 1024)  and (CEIL(2^BAR5_READ_ONLY_BITS) < 1048576)) GENERATE
          ASSERT REPORT "BAR5 Settings: Number of Address Bits Decoded = %, Size = % KBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Prefetchable"
            32-BAR5_READ_ONLY_BITS, CEIL(2^BAR5_READ_ONLY_BITS) DIV 1024
          SEVERITY INFO;
        END GENERATE;
        IF (CEIL(2^BAR5_READ_ONLY_BITS) < 1024) GENERATE
          ASSERT REPORT "BAR5 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Prefetchable"
            32-BAR5_READ_ONLY_BITS, CEIL(2^BAR5_READ_ONLY_BITS)
          SEVERITY INFO;
        END GENERATE;
      
      END GENERATE;
    
    END GENERATE;
    
    IF(BAR5_MEM_LOC == 1 and BAR5_PREFETCH == 0 ) GENERATE
    
      IF (BAR5_OVFL_N == 0) GENERATE
        ASSERT REPORT "Error:  The value for BAR5 parameter is incorrect; The allocated memory [2 GBytes] cannot be located below 1 Meg Space." 
        SEVERITY Error;
      ELSE GENERATE
        
        IF (CEIL(2^BAR5_READ_ONLY_BITS) >=   1073741824) GENERATE
          ASSERT REPORT "Error:  The value for BAR5 parameter is incorrect; The allocated memory [% GBytes] cannot be located below 1 Meg Space."  CEIL(2^BAR5_READ_ONLY_BITS) DIV  1073741824
          SEVERITY Error;
        END GENERATE;
        IF (CEIL(2^BAR5_READ_ONLY_BITS) >=  1048576 and (CEIL(2^BAR5_READ_ONLY_BITS) <   1073741824)) GENERATE
          ASSERT REPORT "Error:  The value for BAR5 parameter is incorrect; The allocated memory [% MBytes] cannot be located below 1 Meg Space."  CEIL(2^BAR5_READ_ONLY_BITS) DIV 1048576 
          SEVERITY error;
        END GENERATE;
        IF((CEIL(2^BAR5_READ_ONLY_BITS) >= 1024)  and (CEIL(2^BAR5_READ_ONLY_BITS) < 1048576)) GENERATE
          ASSERT REPORT "BAR5 Settings: Number of Address Bits Decoded = %, Size = % KBytes, Type = Memory, Location = Below 1 Meg Space, Non-Prefetchable"
            32-BAR5_READ_ONLY_BITS, CEIL(2^BAR5_READ_ONLY_BITS) DIV 1024
          SEVERITY INFO;
        END GENERATE;
        IF (CEIL(2^BAR5_READ_ONLY_BITS) < 1024) GENERATE
          ASSERT REPORT "BAR5 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = Memory, Location = Below 1 Meg Space, Non-Prefetchable"
            32-BAR5_READ_ONLY_BITS, CEIL(2^BAR5_READ_ONLY_BITS)
          SEVERITY INFO;
        END GENERATE;
      
      END GENERATE;

    END GENERATE;
    IF (BAR5_MEM_LOC == 1 and BAR5_PREFETCH == 1 ) GENERATE

      IF (BAR5_OVFL_N == 0) GENERATE
        ASSERT REPORT "Error:  The value for BAR5 parameter is incorrect; The allocated memory [2 GBytes] cannot be located below 1 Meg Space." 
        SEVERITY Error;
      ELSE GENERATE
        
        IF (CEIL(2^BAR5_READ_ONLY_BITS) >=   1073741824) GENERATE
          ASSERT REPORT "Error:  The value for BAR5 parameter is incorrect; The allocated memory [% GBytes] cannot be located below 1 Meg Space."  CEIL(2^BAR5_READ_ONLY_BITS) DIV  1073741824
          SEVERITY Error;
        END GENERATE;
        IF (CEIL(2^BAR5_READ_ONLY_BITS) >=  1048576 and (CEIL(2^BAR5_READ_ONLY_BITS) <   1073741824)) GENERATE
          ASSERT REPORT "Error:  The value for BAR5 parameter is incorrect; The allocated memory [% MBytes] cannot be located below 1 Meg Space."  CEIL(2^BAR5_READ_ONLY_BITS) DIV 1048576 
          SEVERITY error;
        END GENERATE;
        IF((CEIL(2^BAR5_READ_ONLY_BITS) >= 1024)  and (CEIL(2^BAR5_READ_ONLY_BITS) < 1048576)) GENERATE
          ASSERT REPORT "BAR5 Settings: Number of Address Bits Decoded = %, Size = % KBytes, Type = Memory, Location = Below 1 Meg Space, Prefetchable"
            32-BAR5_READ_ONLY_BITS, CEIL(2^BAR5_READ_ONLY_BITS) DIV 1024
          SEVERITY INFO;
        END GENERATE;
        IF (CEIL(2^BAR5_READ_ONLY_BITS) < 1024) GENERATE
          ASSERT REPORT "BAR5 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = Memory, Location = Below 1 Meg Space, Prefetchable"
            32-BAR5_READ_ONLY_BITS, CEIL(2^BAR5_READ_ONLY_BITS)
          SEVERITY INFO;
        END GENERATE;
      
      END GENERATE;

    END GENERATE;
    IF (BAR5_MEM_LOC > 1) GENERATE
      ASSERT REPORT " Illegal Memory Type Value for BAR5 "
      SEVERITY ERROR;
    end GENERATE;
  end GENERATE;


   IF ( HARDWIRE_BAR5_ENA != 1) GENERATE

  no_op[]       = no_op[] or bar5_ena3 or bar5_ena2 or bar5_ena1 or bar5_ena0;

  bar_selR[5]     = cfg_adr_dec_tmp_node[5];
  
  IF (LOCAL_CONFIG_ENA == "NO") GENERATE
  
    bar5_ena[3..0]    = bar_selR[5] and cfg_dat_vld and not(cben_IR[3..0]);
  
  ELSE  GENERATE
  
    bar5_ena[3..0]    = bar_selR[5] and lcfg_dat_vld and not lcfg_ben[3..0];
  
  END GENERATE;
  
  IF (BAR5_READ_ONLY_BITS > 4) GENERATE
  
    bar5_ro_bits[BAR5_READ_ONLY_BITS-1..4]  = GND;      -- BAR5 Read Only Bits
    
  END GENERATE;
  

  -- Set BAR5 R/W Registers Controls

  bar5_reg[].clk  = clk ;
  bar5_reg[].clrn = rstN;
  
  IF (LOCAL_CONFIG_ENA == "NO") GENERATE
    bar5_reg[].d  = ad_IR[31..BAR5_READ_ONLY_BITS];

  ELSE  GENERATE
    bar5_reg[].d  = lcfg_dat_in[31..Bar5_Read_ONLY_BITS];

  END GENERATE;
  
  IF (BAR5_READ_ONLY_BITS < 8) GENERATE

    bar5_reg[31..24].ena            = bar5_ena[3];
    bar5_reg[23..16].ena            = bar5_ena[2];
    bar5_reg[15..8].ena             = bar5_ena[1];
    bar5_reg[7..BAR5_READ_ONLY_BITS].ena  = bar5_ena[0];

  ELSE GENERATE
    
    IF (BAR5_READ_ONLY_BITS < 16) GENERATE
    
      bar5_reg[31..24].ena            = bar5_ena[3];
      bar5_reg[23..16].ena            = bar5_ena[2];
      bar5_reg[15..BAR5_READ_ONLY_BITS].ena = bar5_ena[1];
    
    ELSE GENERATE 
      
      IF (BAR5_READ_ONLY_BITS < 24) GENERATE
      
        bar5_reg[31..24].ena            = bar5_ena[3];
        bar5_reg[23..BAR5_READ_ONLY_BITS].ena = bar5_ena[2];
      
      ELSE GENERATE
      
        bar5_reg[31..BAR5_READ_ONLY_BITS].ena = bar5_ena[3];
      
      END GENERATE;

    END GENERATE;

  END GENERATE;
  
  -- Set the 32 bit value of BAR5
  -- This was added because I/O Base Address register can have only 16 bytes available
  IF (BAR5_READ_ONLY_BITS > 4) GENERATE
    
    bar_5[] = (bar5_reg[],bar5_ro_bits[BAR5_READ_ONLY_BITS-1..4],(bar_nibble5[]));

  ELSE GENERATE
    
  	   IF (BAR5_READ_ONLY_BITS < 3) GENERATE
              bar_5[] = (bar5_reg[],(bar_nibble5[1..0]));
           ELSE GENERATE
              IF (BAR5_READ_ONLY_BITS < 4) GENERATE
                 bar_5[] = (bar5_reg[],(bar_nibble5[2..0]));
              ELSE GENERATE
                 bar_5[] = (bar5_reg[],(bar_nibble5[3..0]));
              END GENERATE;   
           END GENERATE;   

  END GENERATE;



  -- Connect The Ports of BAR5 Address Comparator

  bar5_comp.dataa[] = bar5_reg[] ;
  bar5_comp.datab[] = ad_IR_addr[31 .. BAR5_READ_ONLY_BITS];  -- Only Upper Most Address Bits are Decoded


--  bar_hit[5]    = bar5_comp.aeb and lcell ( adr_phase and (   ( NOT bar_nibble5[0] and mem_cyc and mem_access_enable and not dac_cfg)
--                                    OR  ( bar_nibble5[0] and io_cyc and io_access_enable)
--                                     )
--                             );

  cyc_vld[5]  =   (NOT bar_nibble5[0]  and mem_cyc and mem_access_enable)
        OR  (bar_nibble5[0] and io_cyc and io_access_enable);

  bar_hit[5]    = LCELL(bar5_comp.aeb and adr_phase and cyc_vld[5] );


  -- Set BAR5 Address Compare Hit Register Controls
  
  bar_hitR[5].clk   = clk;
  bar_hitR[5].clrn  = rstN;
              
  bar_hitR[5].r   = bar_hit_rst;

  bar_hitR[5].s = bar_hit[5] ;
  
  
  ELSE GENERATE
  
  bar_5[31..0] = HARDWIRE_BAR5; 
  bar_selR[5]     = cfg_adr_dec_tmp_node[5];
  
    
    
  -- Set the 32 bit value of BAR5
  -- This was added because I/O Base Address register can have only 16 bytes available
  


  -- Connect The Ports of BAR5 Address Comparator

  bar5_comp.dataa[] = bar_5[31 .. BAR5_READ_ONLY_BITS] ;
  bar5_comp.datab[] = ad_IR_addr[31 .. BAR5_READ_ONLY_BITS];  -- Only Upper Most Address Bits are Decoded


--  bar_hit[5]    = bar5_comp.aeb and lcell ( adr_phase and (   ( NOT bar_nibble5[0] and mem_cyc and mem_access_enable and not dac_cfg)
--                                    OR  ( bar_nibble5[0] and io_cyc and io_access_enable)
--                                     )
--                             );
  cyc_vld[5]  =   (NOT bar_nibble5[0]  and mem_cyc )
        OR  (bar_nibble5[0] and io_cyc );

  bar_hit[5]    = LCELL(bar5_comp.aeb and adr_phase and cyc_vld[5] );

  -- Set BAR5 Address Compare Hit Register Controls
  
  bar_hitR[5].clk   = clk;
  bar_hitR[5].clrn  = rstN;
              
  bar_hitR[5].r   = bar_hit_rst;

  bar_hitR[5].s = bar_hit[5] ;
  END GENERATE;
ELSE GENERATE
  bar_hit[5..5] = GND;
  bar_selR[5]   = GND ;
  cyc_vld[5..5] = GND;
  bar_hitR[5..5].clk = Clk;
  bar_hitR[5..5].clrn = rstN;
  bar_hitR[5..5].r = bar_hit_rst;
  bar_hitR[5..5].s  = GND;
  bar_5[]   = H"00000000";
END GENERATE;


IF( NUMBER_OF_BARS  > 6) GENERATE
  ASSERT REPORT " NUMBER_OF_BARS  = %, Number of Base Address Register must be from 1 to 6" NUMBER_OF_BARS  
  SEVERITY ERROR;
END GENERATE;
-- Expansion ROM BAse Address Register
IF (EXP_ROM_ENA == 1) GENERATE
  
  no_op[3..0]       = no_op[3..0] or exp_rom_en[3..0];

  IF (CEIL(2^EXP_ROM_READ_ONLY_BITS) >   16777216) GENERATE   -- If value requested is larger than 16MBytes
        ASSERT REPORT "ERROR:  Expansion ROM BAR is instantiated with [% MBytes] address space larger than allowed 16MBytes." 
        CEIL(2^EXP_ROM_READ_ONLY_BITS) DIV 1048576
        SEVERITY ERROR;
  END GENERATE;


  IF (CEIL(2^EXP_ROM_READ_ONLY_BITS) >=  1048576 ) GENERATE
        ASSERT REPORT "EXP ROM BAR Settings: Number of Address Bits Decoded = %, Size = % MBytes"
        32-EXP_ROM_READ_ONLY_BITS, CEIL(2^EXP_ROM_READ_ONLY_BITS) DIV 1048576 
        SEVERITY INFO;
  END GENERATE;

  IF((CEIL(2^EXP_ROM_READ_ONLY_BITS) >= 1024)  and (CEIL(2^EXP_ROM_READ_ONLY_BITS) < 1048576)) GENERATE
    ASSERT REPORT "EXP ROM BAR Settings: Number of Address Bits Decoded = %, Size = % KBytes"
      32-EXP_ROM_READ_ONLY_BITS, CEIL(2^EXP_ROM_READ_ONLY_BITS) DIV 1024
    SEVERITY INFO;
  END GENERATE;



  IF (HARDWIRE_EXP_ROM_ENA == H"0") GENERATE
  
    IF (LOCAL_CONFIG_ENA == "NO") GENERATE
  
      exp_rom_en[3..0]    = exp_rom_selR and cfg_dat_vld and not cben_IR[3..0];

    ELSE  GENERATE
  
      exp_rom_en[3..0]    = exp_rom_selR and lcfg_dat_vld and not lcfg_ben[3..0];

    END GENERATE;
  
    -- Set BAR#bar# R/W Registers Controls

    exp_rom_reg[].clk = clk ;
    exp_rom_reg[].clrn  = rstN;
  
  
    IF (LOCAL_CONFIG_ENA == "NO") GENERATE
  
      exp_rom_reg[].d     = ad_IR[31..EXP_ROM_READ_ONLY_BITS];

  
    ELSE  GENERATE
  
      exp_rom_reg[].d     = lcfg_dat_in[31..EXP_ROM_Read_ONLY_BITS];
  
    END GENERATE;
  
    IF (EXP_ROM_READ_ONLY_BITS < 8) GENERATE

      exp_rom_reg[31..24].ena           = exp_rom_en[3];
      exp_rom_reg[23..16].ena           = exp_rom_en[2];
      exp_rom_reg[15..8].ena            = exp_rom_en[1];
      exp_rom_reg[7..EXP_ROM_READ_ONLY_BITS].ena  = exp_rom_en[0];

    ELSE GENERATE
      IF (EXP_ROM_READ_ONLY_BITS < 16) GENERATE
        exp_rom_reg[31..24].ena           = exp_rom_en[3];
        exp_rom_reg[23..16].ena           = exp_rom_en[2];
        exp_rom_reg[15..EXP_ROM_READ_ONLY_BITS].ena = exp_rom_en[1];
    
      ELSE GENERATE 
    
        IF (EXP_ROM_READ_ONLY_BITS < 24) GENERATE
    
          exp_rom_reg[31..24].ena           = exp_rom_en[3];
          exp_rom_reg[23..EXP_ROM_READ_ONLY_BITS].ena = exp_rom_en[2];
    
        ELSE GENERATE
    
          exp_rom_reg[31..EXP_ROM_READ_ONLY_BITS].ena = exp_rom_en[3];
    
        END GENERATE;

      END GENERATE;

    END GENERATE;
    
    
    -- Expansion ROM Decode Enable (Bit 0)
    exp_rom_dec_ena.clk   = clk;
    exp_rom_dec_ena.clrn  = rstn;
    exp_rom_dec_ena.ena   = exp_rom_en[0];
    
    IF (LOCAL_CONFIG_ENA == "NO") GENERATE
  
      exp_rom_dec_ena.d   = ad_IR[0];

    ELSE  GENERATE
  
      exp_rom_dec_ena.d   = lcfg_dat_in[0];

    END GENERATE;

    exp_rom_ro_bits[] = gnd;
  
    exp_rom_dat[] = (exp_rom_reg[],exp_rom_ro_bits[],exp_rom_dec_ena);

    -- Connect The Ports of BAR#bar# Address Comparator

    exp_rom_comp.dataa[]  = exp_rom_reg[] ;
    exp_rom_comp.datab[]  = ad_IR_addr[31 .. EXP_ROM_READ_ONLY_BITS]; -- Only Upper Most Address Bits are Decoded
    exp_rom_cyc_vld     = (exp_rom_dec_ena AND mem_cyc  and mem_access_enable);

    exp_rom_hit       = LCELL(exp_rom_comp.aeb and adr_phase and exp_rom_cyc_vld );

    -- Set Address Compare Hit Register Controls

    exp_rom_hitR.clk    = clk;
    exp_rom_hitR.clrn   = rstn;
    exp_rom_hitR.s      = exp_rom_hit ;
    exp_rom_hitR.r      = bar_hit_rst;
    
    exp_rom_bar_hit     = exp_rom_hitR;

    exp_rom_access      = exp_rom_hit ;
    
    
  
  ELSE GENERATE   -- Hardwired EXP ROM
  
  
    IF (LOCAL_CONFIG_ENA == "NO") GENERATE
  
      exp_rom_en[3..0]    = exp_rom_selR and cfg_dat_vld and not cben_IR[3..0];

    ELSE  GENERATE
  
      exp_rom_en[3..0]    = exp_rom_selR and lcfg_dat_vld and not lcfg_ben[3..0];

    END GENERATE;
  
    -- Set Controls
    no_op[31..0]  = exp_rom_temp_dat[];
    
    exp_rom_temp_dat[31..0]   = HARDWIRE_EXP_ROM;
    exp_rom_reg[31.. EXP_ROM_READ_ONLY_BITS]  = exp_rom_temp_dat[31.. EXP_ROM_READ_ONLY_BITS];

    
    -- Expansion ROM Decode Enable (Bit 0)
    -- The reason a not is used to ensure that the exp_rom_dec_ena bit is set to high at power up.
    exp_rom_dec_ena_not.clk   = clk;
    exp_rom_dec_ena_not.clrn  = rstn;
    exp_rom_dec_ena_not.ena   = exp_rom_en[0];
    
    IF (LOCAL_CONFIG_ENA == "NO") GENERATE
  
      exp_rom_dec_ena_not.d   = not ad_IR[0];

    ELSE  GENERATE
  
      exp_rom_dec_ena_not.d   = not lcfg_dat_in[0];

    END GENERATE;
    
    exp_rom_dec_ena       = not exp_rom_dec_ena_not;
    

    exp_rom_ro_bits[] = gnd;
  
    exp_rom_dat[] = (exp_rom_reg[],exp_rom_ro_bits[],exp_rom_dec_ena);

    -- Connect The Ports of BAR#bar# Address Comparator

    exp_rom_comp.dataa[]  = exp_rom_reg[] ;
    exp_rom_comp.datab[]  = ad_IR_addr[31 .. EXP_ROM_READ_ONLY_BITS]; -- Only Upper Most Address Bits are Decoded

    exp_rom_comp.dataa[]  = exp_rom_reg[] ;
    exp_rom_comp.datab[]  = ad_IR_addr[31 .. EXP_ROM_READ_ONLY_BITS]; -- Only Upper Most Address Bits are Decoded
    exp_rom_cyc_vld     = (exp_rom_dec_ena AND mem_cyc  );

    exp_rom_hit       = LCELL(exp_rom_comp.aeb and adr_phase and exp_rom_cyc_vld );
  
    -- Set Address Compare Hit Register Controls

    exp_rom_hitR.clk    = clk;
    exp_rom_hitR.clrn   = rstn;
    exp_rom_hitR.s      = exp_rom_hit ;
    exp_rom_hitR.r      = bar_hit_rst;
    
    exp_rom_bar_hit     = exp_rom_hitR;
    
    exp_rom_access      = exp_rom_hit;
    
    
  
  END GENERATE;
  
ELSE GENERATE  -- EXP DISABLE
  exp_rom_access  = GND;
  exp_rom_bar_hit = GND;
  exp_rom_dat[]   = gnd;

END GENERATE;


-- Configuration Registers Select Signals

--  cfg_adr_dec.clk   = clk;
--  cfg_adr_dec.rstn  = rstn;
--  
--  IF (LOCAL_CONFIG_ENA == "NO") GENERATE
--  
--    cfg_adr_dec.ena   = adr_dec_ena;
--    cfg_adr_dec.dat[] = ad_IR_addr[7..2];
    
--  ELSE  GENERATE
--  
--    cfg_adr_dec.ena   = lcfg_adr_vld;
--    cfg_adr_dec.dat[] = lcfg_adr[7..2];
--  
--  END GENERATE;
  
  
--  dev_vend_selR       = cfg_adr_dec.dec0R;    -- Data = B"000000"
--  stat_cmd_selR       = cfg_adr_dec.dec1R;    -- Data = B"000001"
--  class_rev_selR        = cfg_adr_dec.dec2R;    -- Data = B"000010"
--  bist_hdr_lat_cach_selR    = cfg_adr_dec.dec3R;    -- Data = B"000011"
--  subs_subsvend_selR      = cfg_adr_dec.dec11R;   -- Data = B"001011"
--  exp_rom_selR        = cfg_adr_dec.dec12R;   -- Data = B"001100"
--  cap_ptr_selR        = cfg_adr_dec.dec13R;   -- Data = B"001101"
--  lat_gnt_intpin_intln_selR = cfg_adr_dec.dec15R;   -- Data = B"001111"
  



  END GENERATE; -- P2P_BRIDGE == "NO" 

--==== P2P_BRIDGE == "YES" ========================================================================
  IF (P2P_BRIDGE == "YES") GENERATE
    cmd_in[15..0]         = cfg_dat_in_a[15..0];  -- Command Register Input
    stat_in[15..0]          = cfg_dat_in_a[31..16]; -- Status Register Input
    cache_dat_in[7..0]        = cfg_dat_in_a[39..32]; -- Cache Line Size Register Input
    prim_lat_in[7..0]       = cfg_dat_in_a[47..40]; -- Primary Latency Timer Register
    bar0_dat_in[31..0]        = cfg_dat_in_a[79..48]; -- BAR0
    bar1_dat_in[31..0]        = cfg_dat_in_a[111..80];  -- BAR1
    prim_bus_num_in[7..0]     = cfg_dat_in_a[119..112]; -- Primary Bus Number Input
    sec_bus_num_in[7..0]      = cfg_dat_in_a[127..120]; -- Secondary Bus Number Input
    sub_bus_num_in[7..0]      = cfg_dat_in_a[135..128]; -- Subordinate Bus Number Input
    sec_lat_in[7..0]        = cfg_dat_in_a[143..136]; -- Secondary Bus Number Input
    io_base_in[7..0]        = cfg_dat_in_a[151..144]; -- I/O Base
    io_limit_in[7..0]       = cfg_dat_in_a[159..152]; -- I/O Limit
    sec_stat_in[15..0]        = cfg_dat_in_a[175..160]; -- Secondary Status Register Input
    mem_base_in[15..0]        = cfg_dat_in_a[191..176]; -- Memory Base Register Input 
    mem_limit_in[15..0]       = cfg_dat_in_a[207..192]; -- Memory Limit Register Input
    prfch_mem_base_in[15..0]    = cfg_dat_in_b[15..0];    -- Prefetchable Memory Limit
    prfch_mem_limit_in[15..0]   = cfg_dat_in_b[31..16];   -- Prefetchable Memory Base
    prfch_mem_base_up_in[31..0]   = cfg_dat_in_b[63..32];   -- Prefetchable Memory Base Upper 32 Bits
    prfch_mem_limit_up_in[31..0]  = cfg_dat_in_b[95..64];   -- Prefetchable Memory Limit Upper 32 Bits
    io_base_up_in[15..0]      = cfg_dat_in_b[111..96];  -- I/O Base Upper 16 Bits
    io_limit_up_in[15..0]     = cfg_dat_in_b[127..112]; -- I/O Limit Upper 16 Bits
    exp_rom_in[31..0]       = cfg_dat_in_b[159..128];   -- Expansion ROM Base Address
    brdg_ctrl_in[15..0]       = cfg_dat_in_b[175..160]; -- Bridge Control Register Input
    cap_ptr_in[7..0]        = cfg_dat_in_b[183..176]; -- Capabilities Pointer 
    
    mem_base_1_in[15..0]      = cfg_dat_in_c[15..0];      
    mem_limit_1_in[15..0]           = cfg_dat_in_c[31..16];       
    prfch_mem_base_1_in[15..0]     = cfg_dat_in_c[47..32];      
    prfch_mem_limit_1_in[15..0]    = cfg_dat_in_c[63..48];      
    mem_base_2_in[15..0]            = cfg_dat_in_c[79..64];     
    mem_limit_2_in[15..0]           = cfg_dat_in_c[95..80];     
    prfch_mem_base_2_in[15..0]     = cfg_dat_in_c[111..96];   
    prfch_mem_limit_2_in[15..0]    = cfg_dat_in_c[127..112];      
    mem_base_3_in[15..0]            = cfg_dat_in_c[143..128];     
    mem_limit_3_in[15..0]     = cfg_dat_in_c[159..144];
    prfch_mem_base_3_in[15..0]    = cfg_dat_in_c[175..160];
    prfch_mem_limit_3_in[15..0] = cfg_dat_in_c[191..176];
        
  
    no_op[31..0]      = no_op[31..0]
                or ad_IR_addr[31..0]
                or ad_ir[31..0]
                or bar0_dat_in[31..0]
                or bar1_dat_in[31..0]
                or prfch_mem_base_up_in[31..0]
                or prfch_mem_limit_up_in[31..0]                           
                or exp_rom_in[31..0]
                or lcfg_dat_in[31..0]
                or bar_0[31..0]
                or bar_1[31..0]
                or cfg_adr_40_54_dat[31..0]
                or exp_rom_dat[31..0]
                or cfg_adr_40_54_dat[31..0]
                or cfg_adr_48_54_dat[31..0]
                or cfg_adr_50_54_dat[31..0];
              
    no_op[3..0]       = cben_IR_addr[3..0]
                OR cfg_04_adr_ena[3..0] 
                OR cfg_0C_adr_ena[3..0] 
                OR cfg_18_adr_ena[3..0] 
                OR cfg_1C_adr_ena[3..0] 
                OR cfg_20_adr_ena[3..0] 
                OR cfg_30_adr_ena[3..0]
                OR cfg_3C_adr_ena[3..0]
                OR cben_IR[3..0]  
                or bar_nibble0[]
                or bar_nibble1[]
                or lcfg_ben[3..0];
              
    no_op[15..0]      = sec_stat_in[15..0]
                or  dev_id_dat[15..0]
                or  vend_id_dat[15..0]
                or  stat_dat[15..0]
                or cmd_dat[15..0]
                or sec_stat_dat[15..0]
                or mem_limit_dat[15..0]
                or mem_base_dat[15..0]
                or prfch_mem_limit_dat[15..0]
                or prfch_mem_base_dat[15..0]
                or io_limit_up_dat[15..0]
                or io_base_up_dat[15..0]
                or brdg_ctrl_dat[15..0]
                or stat_set[15..0]
                or cfg_adr_selR[15..0]
                or mem_limit_in[15..0]
                or mem_base_in[15..0]
                or stat_in[15..0]
                or cmd_in[15..0]
                or brdg_ctrl_in[15..0]
                or mem_base_in[15..0]
                or mem_limit_in[15..0]
                or prfch_mem_base_in[15..0]
                or prfch_mem_limit_in[15..0]              
                or io_base_up_in[15..0]
                or io_limit_up_in[15..0]
                or mem_base_1_in[15..0]       
                or mem_limit_1_in[15..0]      
                or prfch_mem_base_1_in[15..0]       
                or prfch_mem_limit_1_in[15..0]      
                or mem_base_2_in[15..0]     
                or mem_limit_2_in[15..0]      
                or prfch_mem_base_2_in[15..0]   
                or prfch_mem_limit_2_in[15..0]      
                or mem_base_3_in[15..0]     
                or mem_limit_3_in[15..0]
                or prfch_mem_base_3_in[15..0]
                or prfch_mem_limit_3_in[15..0];
                
    no_op[7..0]       =  prim_lat_in[7..0]
                or class_dat[7..0]
                or class_dat[15..8]
                or class_dat[23..16]
                or rev_id_dat[7..0]
                or prim_lat_dat[7..0]
                or cache_dat[7..0]
                or sec_lat_dat[7..0]
                or io_limit_dat[7..0]
                or io_base_dat[7..0]
                or cap_ptr_dat[7..0]
                or sub_bus_num_dat[7..0]
                or sec_bus_num_dat[7..0]
                or prim_bus_num_dat[7..0]
                or prim_bus_num_in[7..0]  
                or sec_bus_num_in[7..0]
                or sub_bus_num_in[7..0]
                or sec_lat_in[7..0]
                or cache_dat_in[7..0]
                or io_base_in[7..0]
                or io_limit_in[7..0]
                or cap_ptr_in[7..0]             
                or lcfg_adr[7..0];

    no_op0          = cfg_dat_vld
                OR cfg_adr_selR0
                OR cfg_adr_selR1
                OR cfg_adr_selR2
                or cfg_adr_selR3
                OR cfg_adr_selR4
                OR cfg_adr_selR5
                OR cfg_adr_selR6
                OR cfg_adr_selR7
                OR cfg_adr_selR8
                OR cfg_adr_selR9
                OR cfg_adr_selR12
                OR cfg_adr_selR13
                OR cfg_adr_selR14
                OR cfg_adr_selR15
                OR mem_access_enable
                OR exp_rom_selR
                OR io_access_enable
                or io_cyc
                OR cfg_adr_dec_tmp_node[0]
                OR cfg_adr_dec_tmp_node[1]
                OR cfg_adr_dec_tmp_node[2]
                OR cfg_adr_dec_tmp_node[3]
                OR cfg_adr_dec_tmp_node[4]
                OR cfg_adr_dec_tmp_node[5]
                or tabrt_rcvd_set
                or perr_rep_set
                or serr_det
                or dac_adr_phase_r
                or perr_det_set
                or tabrt_set
                or mabrt_set
                or lcfg_dat_vld
                or dac_cfg
                or lcfg_adr_vld
                or discard_set
                OR cyc_vld[0]
                OR cyc_vld[1]
                OR l_stat_reg_rst[0]
                                OR l_stat_reg_rst[1]
                                OR l_stat_reg_rst[2]
                                OR l_stat_reg_rst[3]
                                OR l_stat_reg_rst[4]
                                OR l_stat_reg_rst[5]
                                OR dac_cmd;
                



  dac_cmd = (cben_IR_addr[3..0]==B"1101");


  --  To support interrupt acknowledge command for the 32-bit.
    IF ( INTERRUPT_ACK_ENA == 0 ) GENERATE
      IF (PCI_32 == "NO") GENERATE
        mem_cyc =   ( cben_IR_addr[3..1] == B"011"  )
                or  ( cben_IR_addr[3..2] == B"11");
      ELSE GENERATE
        mem_cyc =   ( cben_IR_addr[3..1] == B"011"  )
                or  ( cben_IR_addr[3..0] == B"1100")
                or  ( cben_IR_addr[3..1] == B"111");
      END GENERATE; 
    ELSE GENERATE
      IF (PCI_32 == "NO") GENERATE
        mem_cyc =   ( cben_IR_addr[3..1] == B"011"  )
                or  ( cben_IR_addr[3..2] == B"11")
                or  ( cben_IR_addr[3..0] == B"0000");
      ELSE GENERATE
        mem_cyc =   ( cben_IR_addr[3..1] == B"011"  )
                or  ( cben_IR_addr[3..0] == B"1100")
                or  ( cben_IR_addr[3..0] == B"0000")
                or  ( cben_IR_addr[3..1] == B"111");
      END GENERATE; 
    END GENERATE;
  -- iO CYCLE     
    io_cyc  = (cben_IR_addr[3..1] == B"001");
  -- BAR NIBBLES
      bar_nibble0[3..0] = BAR0_LS_NIBBLE;
      bar_nibble1[3..0] = BAR1_LS_NIBBLE;
      base_hit[1..0]    = bar_hitR[1..0]; -- Base Address Hit Signals 
  -- MEMORY/IO ENABLE
    mem_access_enable   = cmd_reg1;
    io_access_enable    = cmd_reg0;
    
    mem_bar_hit     = (bar_hit[0] or bar_hit[1] or exp_rom_access);
  -- Configuration Address Decoder
    cfg_adr_dec.clk     = clk;
    cfg_adr_dec.rstn    = rstn; 
    IF (LOCAL_CONFIG_ENA == "NO") GENERATE
      cfg_adr_dec.ena     = adr_dec_ena;
      cfg_adr_dec.adr[7..0] = ad_IR_addr[7..0];
    ELSE GENERATE
      cfg_adr_dec.ena     = lcfg_adr_vld;
      cfg_adr_dec.adr[7..0] = lcfg_adr[7..0];
    END GENERATE;
    cfg_adr_selR[15..0]   = cfg_adr_dec.selR[15..0];  
    cfg_adr_dec_tmp_node[0] = cfg_adr_dec.selR4;
    cfg_adr_dec_tmp_node[1] = cfg_adr_dec.selR5;
    cfg_adr_dec_tmp_node[2] = cfg_adr_dec.selR6;
    cfg_adr_dec_tmp_node[3] = cfg_adr_dec.selR7;
    cfg_adr_dec_tmp_node[4] = cfg_adr_dec.selR8;
    cfg_adr_dec_tmp_node[5] = cfg_adr_dec.selR9;
    

--BOOKMARK

  ASSERT (NUMBER_OF_BARS >=1) 
  REPORT "NUMBER_OF_BARS = %" NUMBER_OF_BARS
  SEVERITY INFO;
  
  IF (NUMBER_OF_BARS >= 1+0) GENERATE   

    bar_selR[0]     = cfg_adr_selR4;  -- address decode 10h
    no_op[]       = no_op[] or bar0_ena3 or bar0_ena2 or bar0_ena1 or bar0_ena0 or bar_hitR0 or bar_hitR1;  
    bar0_ena[3..0]    = bar_selR[0] and cfg_dat_vld and not(cben_IR[3..0]); 
    IF (BAR0_READ_ONLY_BITS > 4) GENERATE
      bar0_ro_bits[BAR0_RO_BITS_MAX..4]   = GND;      -- BAR0 Read Only Bits < 32
    END GENERATE;
  
  -- Check and REPORT value supplied for BAR0
--  IF (0 == 1) GENERATE ASSERT REPORT "this is bar 1" severity info; END GENERATE;
  
  IF (BAR0_TYPE == 1) GENERATE
---- I/O BAR
    --IF (BAR0_MEM_LOC == 0 and BAR0_PREFETCH == 0 ) GENERATE 
      ASSERT REPORT "BAR0 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = I/O"
        32-BAR0_READ_ONLY_BITS, CEIL(2^BAR0_READ_ONLY_BITS)
      SEVERITY INFO;
    --ELSE GENERATE 
    --  ASSERT REPORT " Illegal Value [%] for BAR0 Parameter" BAR0
    --  SEVERITY ERROR;
    --END GENERATE;
---- MEMORY BAR 
  ELSE GENERATE -- END BAR_TYPE

    IF (BAR0_MEM_LOC == 0 and BAR0_PREFETCH == 0 ) GENERATE
      IF (BAR0_OVFL_N == 0) GENERATE
        ASSERT REPORT "BAR0 Settings: Number of Address Bits Decoded = %, Size = 2 GBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Non-Prefetchable"
        32-BAR0_READ_ONLY_BITS 
        SEVERITY INFO;
      ELSE GENERATE
        
        IF (CEIL(2^BAR0_READ_ONLY_BITS) >=   1073741824) GENERATE
          ASSERT REPORT "BAR0 Settings: Number of Address Bits Decoded = %, Size = % GBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Non-Prefetchable"
          32-BAR0_READ_ONLY_BITS, (2^BAR0_READ_ONLY_BITS) DIV  1073741824
          SEVERITY INFO;
        END GENERATE;
        IF (CEIL(2^BAR0_READ_ONLY_BITS) >=  1048576 and (CEIL(2^BAR0_READ_ONLY_BITS) <   1073741824)) GENERATE
          ASSERT REPORT "BAR0 Settings: Number of Address Bits Decoded = %, Size = % MBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Non-Prefetchable"
          32-BAR0_READ_ONLY_BITS, CEIL(2^BAR0_READ_ONLY_BITS) DIV 1048576 
          SEVERITY INFO;
        END GENERATE;
        IF((CEIL(2^BAR0_READ_ONLY_BITS) >= 1024)  and (CEIL(2^BAR0_READ_ONLY_BITS) < 1048576)) GENERATE
          ASSERT REPORT "BAR0 Settings: Number of Address Bits Decoded = %, Size = % KBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Non-Prefetchable"
            32-BAR0_READ_ONLY_BITS, CEIL(2^BAR0_READ_ONLY_BITS) DIV 1024
          SEVERITY INFO;
        END GENERATE;
        IF (CEIL(2^BAR0_READ_ONLY_BITS) < 1024) GENERATE
          ASSERT REPORT "BAR0 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Non-Prefetchable"
            32-BAR0_READ_ONLY_BITS, CEIL(2^BAR0_READ_ONLY_BITS)
          SEVERITY INFO;
        END GENERATE;
      
      END GENERATE;
      
      
    END GENERATE; -- END BAR_MEM_LOC and BAR_PREFETCH = 0
    
    IF (BAR0_MEM_LOC == 0 and BAR0_PREFETCH == 1 ) GENERATE
      IF (BAR0_OVFL_N == 0) GENERATE
        ASSERT REPORT "BAR0 Settings: Number of Address Bits Decoded = %, Size = 2 GBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Prefetchable"
        32-BAR0_READ_ONLY_BITS 
        SEVERITY INFO;
      ELSE GENERATE
        
        IF (CEIL(2^BAR0_READ_ONLY_BITS) >=   1073741824) GENERATE
          ASSERT REPORT "BAR0 Settings: Number of Address Bits Decoded = %, Size = % GBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Prefetchable"
          32-BAR0_READ_ONLY_BITS, CEIL(2^BAR0_READ_ONLY_BITS) DIV  1073741824
          SEVERITY INFO;
        END GENERATE;
        IF (CEIL(2^BAR0_READ_ONLY_BITS) >=  1048576 and (CEIL(2^BAR0_READ_ONLY_BITS) <   1073741824)) GENERATE
          ASSERT REPORT "BAR0 Settings: Number of Address Bits Decoded = %, Size = % MBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Prefetchable"
          32-BAR0_READ_ONLY_BITS, CEIL(2^BAR0_READ_ONLY_BITS) DIV 1048576 
          SEVERITY INFO;
        END GENERATE;
        IF((CEIL(2^BAR0_READ_ONLY_BITS) >= 1024)  and (CEIL(2^BAR0_READ_ONLY_BITS) < 1048576)) GENERATE
          ASSERT REPORT "BAR0 Settings: Number of Address Bits Decoded = %, Size = % KBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Prefetchable"
            32-BAR0_READ_ONLY_BITS, CEIL(2^BAR0_READ_ONLY_BITS) DIV 1024
          SEVERITY INFO;
        END GENERATE;
        IF (CEIL(2^BAR0_READ_ONLY_BITS) < 1024) GENERATE
          ASSERT REPORT "BAR0 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Prefetchable"
            32-BAR0_READ_ONLY_BITS, CEIL(2^BAR0_READ_ONLY_BITS)
          SEVERITY INFO;
        END GENERATE;
      
      END GENERATE; 
    
    END GENERATE; -- END BAR_MEM_LOC and BAR_PREFETCH = 1


    IF(BAR0_MEM_LOC == 1 and BAR0_PREFETCH == 0 ) GENERATE
    
      IF (BAR0_OVFL_N == 0) GENERATE
        ASSERT REPORT "Error:  The value for BAR0 parameter is incorrect; The allocated memory [2 GBytes] cannot be located below 1 Meg Space." 
        SEVERITY Error;
      ELSE GENERATE
        
        IF (CEIL(2^BAR0_READ_ONLY_BITS) >=   1073741824) GENERATE
          ASSERT REPORT "Error:  The value for BAR0 parameter is incorrect; The allocated memory [% GBytes] cannot be located below 1 Meg Space."  CEIL(2^BAR0_READ_ONLY_BITS) DIV  1073741824
          SEVERITY Error;
        END GENERATE;
        IF (CEIL(2^BAR0_READ_ONLY_BITS) >=  1048576 and (CEIL(2^BAR0_READ_ONLY_BITS) <   1073741824)) GENERATE
          ASSERT REPORT "Error:  The value for BAR0 parameter is incorrect; The allocated memory [% MBytes] cannot be located below 1 Meg Space."  CEIL(2^BAR0_READ_ONLY_BITS) DIV 1048576 
          SEVERITY error;
        END GENERATE;
        IF((CEIL(2^BAR0_READ_ONLY_BITS) >= 1024)  and (CEIL(2^BAR0_READ_ONLY_BITS) < 1048576)) GENERATE
          ASSERT REPORT "BAR0 Settings: Number of Address Bits Decoded = %, Size = % KBytes, Type = Memory, Location = Below 1 Meg Space, Non-Prefetchable"
            32-BAR0_READ_ONLY_BITS, CEIL(2^BAR0_READ_ONLY_BITS) DIV 1024
          SEVERITY INFO;
        END GENERATE;
        IF (CEIL(2^BAR0_READ_ONLY_BITS) < 1024) GENERATE
          ASSERT REPORT "BAR0 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = Memory, Location = Below 1 Meg Space, Non-Prefetchable"
            32-BAR0_READ_ONLY_BITS, CEIL(2^BAR0_READ_ONLY_BITS)
          SEVERITY INFO;
        END GENERATE;
      
      END GENERATE;

    END GENERATE;
    IF (BAR0_MEM_LOC == 1 and BAR0_PREFETCH == 1 ) GENERATE

      IF (BAR0_OVFL_N == 0) GENERATE
        ASSERT REPORT "Error:  The value for BAR0 parameter is incorrect; The allocated memory [2 GBytes] cannot be located below 1 Meg Space." 
        SEVERITY Error;
      ELSE GENERATE
        
        IF (CEIL(2^BAR0_READ_ONLY_BITS) >=   1073741824) GENERATE
          ASSERT REPORT "Error:  The value for BAR0 parameter is incorrect; The allocated memory [% GBytes] cannot be located below 1 Meg Space."  CEIL(2^BAR0_READ_ONLY_BITS) DIV  1073741824
          SEVERITY Error;
        END GENERATE;
        IF (CEIL(2^BAR0_READ_ONLY_BITS) >=  1048576 and (CEIL(2^BAR0_READ_ONLY_BITS) <   1073741824)) GENERATE
          ASSERT REPORT "Error:  The value for BAR0 parameter is incorrect; The allocated memory [% MBytes] cannot be located below 1 Meg Space."  CEIL(2^BAR0_READ_ONLY_BITS) DIV 1048576 
          SEVERITY error;
        END GENERATE;
        IF((CEIL(2^BAR0_READ_ONLY_BITS) >= 1024)  and (CEIL(2^BAR0_READ_ONLY_BITS) < 1048576)) GENERATE
          ASSERT REPORT "BAR0 Settings: Number of Address Bits Decoded = %, Size = % KBytes, Type = Memory, Location = Below 1 Meg Space, Prefetchable"
            32-BAR0_READ_ONLY_BITS, CEIL(2^BAR0_READ_ONLY_BITS) DIV 1024
          SEVERITY INFO;
        END GENERATE;
        IF (CEIL(2^BAR0_READ_ONLY_BITS) < 1024) GENERATE
          ASSERT REPORT "BAR0 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = Memory, Location = Below 1 Meg Space, Prefetchable"
            32-BAR0_READ_ONLY_BITS, CEIL(2^BAR0_READ_ONLY_BITS)
          SEVERITY INFO;
        END GENERATE;
      
      END GENERATE;

    END GENERATE;


    IF (BAR0_MEM_LOC > 2) GENERATE
      ASSERT REPORT " Illegal Memory Type Value for BAR0 "
      SEVERITY ERROR;
    end GENERATE;

  end GENERATE;

  -- Set BAR0 R/W Registers Controls
  
  IF (PRIMARY_INTERFACE == "YES") GENERATE
    bar0_reg[].clk  = clk ;
    bar0_reg[].clrn = rstN;
    bar0_reg[].d  = ad_IR[31..BAR0_READ_ONLY_BITS];

    IF (BAR0_READ_ONLY_BITS < 8) GENERATE
      bar0_reg[31..24].ena            = bar0_ena[3];
      bar0_reg[23..16].ena            = bar0_ena[2];
      bar0_reg[15..8].ena             = bar0_ena[1];
      bar0_reg[7..BAR0_READ_ONLY_BITS].ena    = bar0_ena[0];
    ELSE GENERATE   
      IF (BAR0_READ_ONLY_BITS < 16) GENERATE    
        bar0_reg[31..24].ena          = bar0_ena[3];
        bar0_reg[23..16].ena          = bar0_ena[2];
        bar0_reg[15..BAR0_READ_ONLY_BITS].ena = bar0_ena[1];
      ELSE GENERATE       
        IF (BAR0_READ_ONLY_BITS < 24) GENERATE      
          bar0_reg[31..24].ena          = bar0_ena[3];
          bar0_reg[23..BAR0_READ_ONLY_BITS].ena = bar0_ena[2];      
        ELSE GENERATE     
          bar0_reg[31..BAR0_READ_ONLY_BITS].ena = bar0_ena[3];
        END GENERATE;
      END GENERATE;
    END GENERATE;
  
  ELSE GENERATE -- SECONDARY INTERFACE
    bar0_reg[]    = bar0_dat_in[31..BAR0_READ_ONLY_BITS];
  END GENERATE;


  -- Set the 32 bit value of BAR0
  -- This was added because I/O Base Address register can have only 16 bytes available

    IF (BAR0_READ_ONLY_BITS > 4) GENERATE
      bar_0[] = (bar0_reg[],bar0_ro_bits[BAR0_RO_BITS_MAX..4],(bar_nibble0[]));
    ELSE GENERATE
      bar_0[] = (bar0_reg[],(bar_nibble0[]));
    END GENERATE;


  -- Connect The Ports of BAR0 Address Comparator

  IF (PRIMARY_INTERFACE == "YES") GENERATE
    bar0_comp.dataa[] = bar0_reg[] ;
    bar0_comp.datab[] = ad_IR_addr[31 .. BAR0_READ_ONLY_BITS];  
    cyc_vld[0]      = (NOT bar_nibble0[0] and mem_cyc and mem_access_enable)
              OR  (bar_nibble0[0] and io_cyc and io_access_enable);

    bar_hit[0]  = bar0_comp.aeb and adr_phase and cyc_vld[0];

  
  ELSE GENERATE

    bar0_comp.dataa[] = bar0_reg[] ;
    bar0_comp.datab[] = ad_IR_addr[31 .. BAR0_READ_ONLY_BITS];  
    cyc_vld[0]      = (NOT bar_nibble0[0] and mem_cyc)
              OR  (bar_nibble0[0] and io_cyc );

    bar_hit[0]  = bar0_comp.aeb and adr_phase and cyc_vld[0];
  END GENERATE;

  -- Set BAR0 Address Compare Hit Register Controls
  
    bar_hitR[0].clk   = clk;
    bar_hitR[0].clrn  = rstN;
              
    bar_hitR[0].r = bar_hit_rst;
    bar_hitR[0].s = bar_hit[0] ;

  ELSE GENERATE
    bar_hit[1..0] = GND;
    bar_selR[0]   = GND ;   -- Bar0 Register Select
    cyc_vld[1..0] = GND ;
    bar_hitR[1..0].clk = Clk;
    bar_hitR[1..0].clrn = rstN;
    bar_hitR[1..0].r = bar_hit_rst;
    bar_hitR[1..0].s  = GND;
    --bar[1..0][]   = H"00000000";
    bar_0[]   = H"00000000";
    bar_1[]   = H"00000000";

  END GENERATE;

  IF (NUMBER_OF_BARS >= 1+1) GENERATE

    no_op[]       = no_op[] or bar1_ena3 or bar1_ena2 or bar1_ena1 or bar1_ena0 or bar_hitR0 or bar_hitR1;

    bar_selR[1]     = cfg_adr_selR5;
  
    bar1_ena[3..0]    = bar_selR[1] and cfg_dat_vld and not(cben_IR[3..0]); 

    IF (BAR1_READ_ONLY_BITS > 4) GENERATE
      bar1_ro_bits[BAR1_READ_ONLY_BITS-1..4]  = GND;      -- BAR1 Read Only Bits
    END GENERATE;

--  IF (1 == 1) GENERATE ASSERT REPORT "this is bar 1" severity info; END GENERATE;

    IF (BAR1_TYPE == 1) GENERATE
      --IF (BAR1_MEM_LOC == 0 and BAR1_PREFETCH == 0 ) GENERATE
        ASSERT REPORT "BAR1 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = I/O"
          BAR1_COMP_WIDTH, CEIL(2^BAR1_READ_ONLY_BITS)
        SEVERITY INFO;
      --ELSE GENERATE 
      --  ASSERT REPORT " Illegal Value [%] for BAR1 Parameter" BAR1
      --  SEVERITY ERROR;
      --END GENERATE;
    ELSE GENERATE
      IF (BAR1_MEM_LOC == 0 and BAR1_PREFETCH == 0 ) GENERATE
        IF (BAR1_OVFL_N == 0) GENERATE
          ASSERT REPORT "BAR1 Settings: Number of Address Bits Decoded = %, Size = 2 GBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Non-Prefetchable"
          BAR1_COMP_WIDTH 
          SEVERITY INFO;
        ELSE GENERATE
        
          IF (CEIL(2^BAR1_READ_ONLY_BITS) >=   1073741824) GENERATE
            ASSERT REPORT "BAR1 Settings: Number of Address Bits Decoded = %, Size = % GBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Non-Prefetchable"
            BAR1_COMP_WIDTH, (2^BAR1_READ_ONLY_BITS) DIV  1073741824
            SEVERITY INFO;
          END GENERATE;
          IF (CEIL(2^BAR1_READ_ONLY_BITS) >=  1048576 and (CEIL(2^BAR1_READ_ONLY_BITS) <   1073741824)) GENERATE
            ASSERT REPORT "BAR1 Settings: Number of Address Bits Decoded = %, Size = % MBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Non-Prefetchable"
            BAR1_COMP_WIDTH, CEIL(2^BAR1_READ_ONLY_BITS) DIV 1048576 
            SEVERITY INFO;
          END GENERATE;
          IF((CEIL(2^BAR1_READ_ONLY_BITS) >= 1024)  and (CEIL(2^BAR1_READ_ONLY_BITS) < 1048576)) GENERATE
            ASSERT REPORT "BAR1 Settings: Number of Address Bits Decoded = %, Size = % KBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Non-Prefetchable"
            BAR1_COMP_WIDTH, CEIL(2^BAR1_READ_ONLY_BITS) DIV 1024
            SEVERITY INFO;
          END GENERATE;
          IF (CEIL(2^BAR1_READ_ONLY_BITS) < 1024) GENERATE
            ASSERT REPORT "BAR1 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Non-Prefetchable"
            BAR1_COMP_WIDTH, CEIL(2^BAR1_READ_ONLY_BITS)
            SEVERITY INFO;
          END GENERATE;     
        END GENERATE;   
      END GENERATE;
    
      IF (BAR1_MEM_LOC == 0 and BAR1_PREFETCH == 1 ) GENERATE
        IF (BAR1_OVFL_N == 0) GENERATE
          ASSERT REPORT "BAR1 Settings: Number of Address Bits Decoded = %, Size = 2 GBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Prefetchable"
          BAR1_COMP_WIDTH 
          SEVERITY INFO;
        ELSE GENERATE
        
          IF (CEIL(2^BAR1_READ_ONLY_BITS) >=   1073741824) GENERATE
            ASSERT REPORT "BAR1 Settings: Number of Address Bits Decoded = %, Size = % GBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Prefetchable"
            BAR1_COMP_WIDTH, CEIL(2^BAR1_READ_ONLY_BITS) DIV  1073741824
            SEVERITY INFO;
          END GENERATE;
          IF (CEIL(2^BAR1_READ_ONLY_BITS) >=  1048576 and (CEIL(2^BAR1_READ_ONLY_BITS) <   1073741824)) GENERATE
            ASSERT REPORT "BAR1 Settings: Number of Address Bits Decoded = %, Size = % MBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Prefetchable"
            BAR1_COMP_WIDTH, CEIL(2^BAR1_READ_ONLY_BITS) DIV 1048576 
            SEVERITY INFO;
          END GENERATE;
          IF((CEIL(2^BAR1_READ_ONLY_BITS) >= 1024)  and (CEIL(2^BAR1_READ_ONLY_BITS) < 1048576)) GENERATE
            ASSERT REPORT "BAR1 Settings: Number of Address Bits Decoded = %, Size = % KBytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Prefetchable"
            BAR1_COMP_WIDTH, CEIL(2^BAR1_READ_ONLY_BITS) DIV 1024
            SEVERITY INFO;
          END GENERATE;
          IF (CEIL(2^BAR1_READ_ONLY_BITS) < 1024) GENERATE
            ASSERT REPORT "BAR1 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = Memory, Location = Anywhere in the 32 Bit address Space, Prefetchable"
            BAR1_COMP_WIDTH, CEIL(2^BAR1_READ_ONLY_BITS)
            SEVERITY INFO;
          END GENERATE;
        END GENERATE; 
      END GENERATE;
    
      IF(BAR1_MEM_LOC == 1 and BAR1_PREFETCH == 0 ) GENERATE
    
        IF (BAR1_OVFL_N == 0) GENERATE
          ASSERT REPORT "Error:  The value for BAR0 parameter is incorrect; The allocated memory [2 GBytes] cannot be located below 1 Meg Space." 
          SEVERITY Error;
        ELSE GENERATE
        
          IF (CEIL(2^BAR1_READ_ONLY_BITS) >=   1073741824) GENERATE
            ASSERT REPORT "Error:  The value for BAR1 parameter is incorrect; The allocated memory [% GBytes] cannot be located below 1 Meg Space."  CEIL(2^BAR1_READ_ONLY_BITS) DIV  1073741824
            SEVERITY Error;
          END GENERATE;
          IF (CEIL(2^BAR1_READ_ONLY_BITS) >=  1048576 and (CEIL(2^BAR1_READ_ONLY_BITS) <   1073741824)) GENERATE
            ASSERT REPORT "Error:  The value for BAR1 parameter is incorrect; The allocated memory [% MBytes] cannot be located below 1 Meg Space."  CEIL(2^BAR1_READ_ONLY_BITS) DIV 1048576 
            SEVERITY error;
          END GENERATE;
          IF((CEIL(2^BAR1_READ_ONLY_BITS) >= 1024)  and (CEIL(2^BAR1_READ_ONLY_BITS) < 1048576)) GENERATE
            ASSERT REPORT "BAR1 Settings: Number of Address Bits Decoded = %, Size = % KBytes, Type = Memory, Location = Below 1 Meg Space, Non-Prefetchable"
            BAR1_COMP_WIDTH, CEIL(2^BAR1_READ_ONLY_BITS) DIV 1024
            SEVERITY INFO;
          END GENERATE;
          IF (CEIL(2^BAR1_READ_ONLY_BITS) < 1024) GENERATE
            ASSERT REPORT "BAR1 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = Memory, Location = Below 1 Meg Space, Non-Prefetchable"
            BAR1_COMP_WIDTH, CEIL(2^BAR1_READ_ONLY_BITS)
            SEVERITY INFO;
          END GENERATE;
        END GENERATE;
      END GENERATE;
      IF (BAR1_MEM_LOC == 1 and BAR1_PREFETCH == 1 ) GENERATE

        IF (BAR1_OVFL_N == 0) GENERATE
          ASSERT REPORT "Error:  The value for BAR0 parameter is incorrect; The allocated memory [2 GBytes] cannot be located below 1 Meg Space." 
          SEVERITY Error;
        ELSE GENERATE
          
          IF (CEIL(2^BAR1_READ_ONLY_BITS) >=   1073741824) GENERATE
            ASSERT REPORT "Error:  The value for BAR1 parameter is incorrect; The allocated memory [% GBytes] cannot be located below 1 Meg Space."  CEIL(2^BAR1_READ_ONLY_BITS) DIV  1073741824
            SEVERITY Error;
          END GENERATE;
          IF (CEIL(2^BAR1_READ_ONLY_BITS) >=  1048576 and (CEIL(2^BAR1_READ_ONLY_BITS) <   1073741824)) GENERATE
            ASSERT REPORT "Error:  The value for BAR1 parameter is incorrect; The allocated memory [% MBytes] cannot be located below 1 Meg Space."  CEIL(2^BAR1_READ_ONLY_BITS) DIV 1048576 
            SEVERITY error;
          END GENERATE;
          IF((CEIL(2^BAR1_READ_ONLY_BITS) >= 1024)  and (CEIL(2^BAR1_READ_ONLY_BITS) < 1048576)) GENERATE
            ASSERT REPORT "BAR1 Settings: Number of Address Bits Decoded = %, Size = % KBytes, Type = Memory, Location = Below 1 Meg Space, Prefetchable"
            BAR1_COMP_WIDTH, CEIL(2^BAR1_READ_ONLY_BITS) DIV 1024
            SEVERITY INFO;
          END GENERATE;
          IF (CEIL(2^BAR1_READ_ONLY_BITS) < 1024) GENERATE
            ASSERT REPORT "BAR1 Settings: Number of Address Bits Decoded = %, Size = % Bytes, Type = Memory, Location = Below 1 Meg Space, Prefetchable"
            BAR1_COMP_WIDTH, CEIL(2^BAR1_READ_ONLY_BITS)
            SEVERITY INFO;
          END GENERATE;
        END GENERATE;
      END GENERATE; 

    END GENERATE;

  -- Set BAR1 R/W Registers Controls
  IF (PRIMARY_INTERFACE == "YES") GENERATE
    bar1_reg[].clk  = clk ;
    bar1_reg[].clrn = rstN; 
    bar1_reg[].d  = ad_IR[31..BAR1_READ_ONLY_BITS];

    IF (BAR1_READ_ONLY_BITS < 8) GENERATE
      bar1_reg[31..24].ena            = bar1_ena[3];
      bar1_reg[23..16].ena            = bar1_ena[2];
      bar1_reg[15..8].ena             = bar1_ena[1];
      bar1_reg[7..BAR1_READ_ONLY_BITS].ena    = bar1_ena[0];
    ELSE GENERATE
      IF (BAR1_READ_ONLY_BITS < 16) GENERATE
        bar1_reg[31..24].ena            = bar1_ena[3];
        bar1_reg[23..16].ena            = bar1_ena[2];
        bar1_reg[15..BAR1_READ_ONLY_BITS].ena   = bar1_ena[1];
      ELSE GENERATE 
        IF (BAR1_READ_ONLY_BITS < 24) GENERATE
          bar1_reg[31..24].ena            = bar1_ena[3];
          bar1_reg[23..BAR1_READ_ONLY_BITS].ena   = bar1_ena[2];
        ELSE GENERATE
          bar1_reg[31..BAR1_READ_ONLY_BITS].ena = bar1_ena[3];
        END GENERATE;
      END GENERATE;
    END GENERATE;

  ELSE GENERATE -- SECONDARY INTERFACE
    bar1_reg[]    = bar1_dat_in[31..BAR1_READ_ONLY_BITS];

  END GENERATE;


  -- Set the 32 bit value of BAR1
  -- This was added because I/O Base Address register can have only 16 bytes available


  IF (BAR1_READ_ONLY_BITS > 4) GENERATE   
    bar_1[] = (bar1_reg[],bar1_ro_bits[BAR1_READ_ONLY_BITS-1..4],(bar_nibble1[]));
  ELSE GENERATE
    bar_1[] = (bar1_reg[],(bar_nibble1[]));
  END GENERATE;

  IF (PRIMARY_INTERFACE == "YES") GENERATE
    bar1_comp.dataa[] = bar1_reg[] ;
    bar1_comp.datab[] = ad_IR_addr[31 .. BAR1_READ_ONLY_BITS];  
    
    cyc_vld[1]      = (NOT bar_nibble1[0] and mem_cyc and mem_access_enable)
              OR  (bar_nibble1[0] and io_cyc and io_access_enable);

    bar_hit[1]      = bar1_comp.aeb and adr_phase and cyc_vld[1];

    
  ELSE GENERATE
    bar1_comp.dataa[] = bar1_reg[] ;
    bar1_comp.datab[] = ad_IR_addr[31 .. BAR1_READ_ONLY_BITS];  

    cyc_vld[1]      = (NOT bar_nibble1[0] and mem_cyc)
              OR  (bar_nibble1[0] and io_cyc );

    bar_hit[1]      = bar1_comp.aeb and adr_phase and cyc_vld[1];


  END GENERATE;


  -- Set BAR1 Address Compare Hit Register Controls
  
  bar_hitR[1].clk  = clk;
  bar_hitR[1].clrn = rstN;
              
  bar_hitR[1].r = bar_hit_rst;
  bar_hitR[1].s = bar_hit[1] ;
ELSE GENERATE
  bar_hit[1..1] = GND;
  bar_selR[1]   = GND ;   -- Bar1 Register Select
  cyc_vld[1]    = GND ;
  bar_hitR[1..1].clk = Clk;
  bar_hitR[1..1].clrn = rstN;
  bar_hitR[1..1].r = bar_hit_rst;
  bar_hitR[1..1].s  = GND;
  bar_1[]   = H"00000000";
END GENERATE;

IF( NUMBER_OF_BARS  > 2) GENERATE
  ASSERT REPORT " NUMBER_OF_BARS  = %, Number of Base Address Register must be from 1 to 2" NUMBER_OF_BARS  
  SEVERITY ERROR;
END GENERATE;





  dev_id_dat[15..0]   = DEVICE_ID;
  vend_id_dat[15..0]    = VENDOR_ID;
  rev_id_dat[7..0]    = REVISION_ID;
  class_dat[23..0]    = CLASS_CODE;


  -- This servs as the configuration output multiplexer.
  -- Notice that for the parts which have read only numbers you must use binary to ensure that
  -- the appropriate number of bits is represented.  This is required by AHDL
IF (PRIMARY_INTERFACE == "YES") GENERATE
    config_data[31..0]  =   ((dev_id_dat[15..0], vend_id_dat[15..0]) and cfg_adr_selR0)
          OR  ((stat_dat[15..0], cmd_dat[15..0])      and cfg_adr_selR1)
          OR  ((class_dat[23..0], rev_id_dat[7..0])   and cfg_adr_selR2)
          OR  ((B"00000000", B"00000001", prim_lat_dat[7..0], cache_dat[7..0]) and cfg_adr_selR3)
          OR  ((bar_0[31..0]  and cfg_adr_selR4))
          OR  ((bar_1[31..0]  and cfg_adr_selR5))
          OR  ((sec_lat_dat[7..0], sub_bus_num_dat[7..0], sec_bus_num_dat[7..0], prim_bus_num_dat[7..0]) and cfg_adr_selR6)
          OR  ((sec_stat_dat[15..0], io_limit_dat[7..0], io_base_dat[7..0]) and cfg_adr_selR7)
          OR  ((mem_limit_dat[15..0], mem_base_dat[15..0]) and cfg_adr_selR8)
          OR  ((prfch_mem_limit_dat[15..0], prfch_mem_base_dat[15..0]) and cfg_adr_selR9)         
--          OR  ((prfch_base_up_dat[31..0]) and cfg_adr_selR10)
--          OR  ((prfch_limit_up_dat[31..0]) and cfg_adr_selR11)
          OR  ((io_limit_up_dat[15..0], io_base_up_dat[15..0]) and cfg_adr_selR12)
          OR  ((H"000000", cap_ptr_dat[7..0]) and cfg_adr_selR13)
          OR  ((exp_rom_dat[31..0]) and cfg_adr_selR14)
          OR  ((brdg_ctrl_dat[15..0], B"0000000000000000") and cfg_adr_selR15)
          OR  cfg_adr_40_54_dat[31..0];
ELSE GENERATE
  config_data[31..0]  = GND;

END GENERATE;
  
  ad_dat_out[31..0].clk = clk;
  ad_dat_out[31..0].clrn  = rstn;
  ad_dat_out[31..0]   = config_data[31..0];
  
  -- Configuarion Registers Clock Enables
  
  cfg_04_adr_ena[3..0]  = cfg_adr_selR1 and cfg_dat_vld and not cben_IR[3..0];
  cfg_0C_adr_ena[3..0]  = cfg_adr_selR3 and cfg_dat_vld and not cben_IR[3..0];
  cfg_18_adr_ena[3..0]  = cfg_adr_selR6 and cfg_dat_vld and not cben_IR[3..0];
  cfg_1C_adr_ena[3..0]  = cfg_adr_selR7 and cfg_dat_vld and not cben_IR[3..0];
  cfg_20_adr_ena[3..0]  = cfg_adr_selR8 and cfg_dat_vld and not cben_IR[3..0];
  IF (PREFETCHABLE_MEMORY == "YES") GENERATE
    cfg_24_adr_ena[3..0]  = cfg_adr_selR9 and cfg_dat_vld and not cben_IR[3..0];    
  END GENERATE;
  cfg_30_adr_ena[3..0]  = cfg_adr_selR12 and cfg_dat_vld and not cben_IR[3..0]; 
  cfg_3C_adr_ena[3..0]  = cfg_adr_selR15 and cfg_dat_vld and not cben_IR[3..0];

  -- Command Register
  
  cmd_reg0  = DFFE(ad_IR0, clk, rstn, VCC, cfg_04_adr_ena0);    -- I/O Space Enable
  cmd_reg1  = DFFE(ad_IR1, clk, rstn, VCC, cfg_04_adr_ena0);    -- Memory Space Enable
  IF (TARGET_ONLY == "NO") GENERATE
    cmd_reg2  = DFFE(ad_IR2, clk, rstn, VCC, cfg_04_adr_ena0);  -- Bus Master Enable
  ELSE GENERATE
    cmd_reg2  = gnd;
  END GENERATE;   
  cmd_reg3  = GND;                          -- Read Only Special Cycle
  cmd_reg4  = GND;                          -- Memory Write and Invalidate Enable
  cmd_reg5  = GND;                          -- Read Only VGA Pallet Snoop
  cmd_reg6  = DFFE(ad_IR6, clk, rstn, VCC, cfg_04_adr_ena0);    -- Pariy Error Response Enable 
  cmd_reg7  = GND;                          -- Read Only Wait Cycle Control
  cmd_reg8  = DFFE(ad_IR8, clk, rstn, VCC, cfg_04_adr_ena1);    -- SERR Enable
  cmd_reg9  = GND;                          -- Read Only, Fast Back-to-Back Enable
  cmd_reg10 = DFFE(ad_IR10, clk, rstn, VCC, cfg_04_adr_ena1);  -- Interrupt Disable bit
  cmd_reg[15..11] = B"00000";                    -- Read Only, Reserved

  cmd_dat[15..0]  = cmd_reg[15..0];   -- Command Register Data.
  cmd_out[15..0]  = cmd_dat[15..0];             
  
  -- interrupt status register supporting signals
  lirq = not lirqn;
  lirq_reg = DFFE(lirq,clk,rstn,VCC,VCC);
  lirq_rise = not lirq_reg and lirq;
  lirq_fall = lirq_reg and not lirq;
  intr_stat_set = not cmd_reg10 and lirq_rise;
  intr_stat_rst = lirq_fall;
  
  -- Status Register
  stat_reg[2..0]    = B"000";
  stat_reg3    = pcimt32_sr(intr_stat_set, intr_stat_rst, clk, rstn,VCC);      -- Interrupt status
  
  IF (CAP_LIST_ENA == 1) GENERATE
    stat_reg4     = VCC;                            -- Capability List Enable
  ELSE GENERATE
    stat_reg4   = GND;
  END GENERATE;
  
  IF (PCI_66MHZ_CAPABLE == "YES") GENERATE
    stat_reg5   = VCC;                            -- Read Only, 66 MHZ capable
  ELSE GENERATE
    stat_reg5   = GND;
  END GENERATE;
  
  stat_reg6   = GND;                            -- Read Only, UDF Supported
  stat_reg7   = GND;                            -- Read Only, Fast Back-To-Back Capable
  stat_reg8   = SRFF(stat_set8, mstr_perr_rst, clk, rstn, VCC);     -- Data Parity Error Signaled
  stat_reg[10..9] = B"10";                          -- Read Only, Devsel Timing, SLOW
  stat_reg11    = pcimt32_sr(stat_set11, tabrt_sig_rst, clk, rstn, VCC);    -- Signaled Target Abort
  stat_reg12    = pcimt32_sr(stat_set12, tabrt_rcvd_rst, clk, rstn, VCC);   -- Recieved Target Abort
  stat_reg13    = pcimt32_sr(stat_set13, mabrt_rcvd_rst, clk, rstn, VCC);   -- Recieved Master Abort
  stat_reg14    = pcimt32_sr(stat_set14, serr_sig_rst, clk, rstn, VCC);   -- Signaled SERR
  stat_reg15    = pcimt32_sr(stat_set15, perr_det_rst, clk, rstn, VCC);   -- Detected Parity Error
    
  mstr_perr_rst = LCELL(cfg_04_adr_ena3 and ad_IR24);           -- Reset Signaled Parity Error Bit
  tabrt_sig_rst = LCELL(cfg_04_adr_ena3 and ad_IR27);           -- Reset Signaled Target Abort Bit
  tabrt_rcvd_rst  = LCELL(cfg_04_adr_ena3 and ad_IR28);           -- Reset Received Target Abort Bit
  mabrt_rcvd_rst  = LCELL(cfg_04_adr_ena3 and ad_IR29);           -- Reset Recieved Master Abort Bit
  serr_sig_rst  = LCELL(cfg_04_adr_ena3 and ad_IR30);           -- Reset Signaled SERR Bit
  perr_det_rst  = LCELL(cfg_04_adr_ena3 and ad_IR31);           -- Reset Detected Parity Error Bit

  stat_dat[15..0] = stat_reg[15..0];
  stat_out[15..0] = stat_dat[15..0];

  -- Cache Line Size
  cache_dat_reg0  = DFFE(ad_IR0, clk, rstn, VCC, cfg_0C_adr_ena0);
  cache_dat_reg1  = DFFE(ad_IR1, clk, rstn, VCC, cfg_0C_adr_ena0);
  cache_dat_reg2  = DFFE(ad_IR2, clk, rstn, VCC, cfg_0C_adr_ena0);
  cache_dat_reg3  = DFFE(ad_IR3, clk, rstn, VCC, cfg_0C_adr_ena0);
  cache_dat_reg4  = DFFE(ad_IR4, clk, rstn, VCC, cfg_0C_adr_ena0);
  cache_dat_reg5  = DFFE(ad_IR5, clk, rstn, VCC, cfg_0C_adr_ena0);
  cache_dat_reg6  = DFFE(ad_IR6, clk, rstn, VCC, cfg_0C_adr_ena0);
  cache_dat_reg7  = DFFE(ad_IR7, clk, rstn, VCC, cfg_0C_adr_ena0);

  cache_dat[7..0] = cache_dat_reg[7..0];
  cache_dat_out[7..0] = cache_dat[7..0]; 

  -- Primary Latency Timer Register
  prim_lat_reg0 = GND;
  prim_lat_reg1 = GND;
  prim_lat_reg2 = GND;
  prim_lat_reg3 = DFFE(ad_IR11, clk, rstn, VCC, cfg_0C_adr_ena1);
  prim_lat_reg4 = DFFE(ad_IR12, clk, rstn, VCC, cfg_0C_adr_ena1);
  prim_lat_reg5 = DFFE(ad_IR13, clk, rstn, VCC, cfg_0C_adr_ena1);
  prim_lat_reg6 = DFFE(ad_IR14, clk, rstn, VCC, cfg_0C_adr_ena1);
  prim_lat_reg7 = DFFE(ad_IR15, clk, rstn, VCC, cfg_0C_adr_ena1);

  prim_lat_dat[7..0]  = prim_lat_reg[7..0];
  prim_lat_out[7..0]  = prim_lat_dat[7..0];
  
  -- Primary Bus Number
  prim_bus_num_reg0 = DFFE(ad_IR0, clk, rstn, VCC, cfg_18_adr_ena0);
  prim_bus_num_reg1 = DFFE(ad_IR1, clk, rstn, VCC, cfg_18_adr_ena0);
  prim_bus_num_reg2 = DFFE(ad_IR2, clk, rstn, VCC, cfg_18_adr_ena0);
  prim_bus_num_reg3 = DFFE(ad_IR3, clk, rstn, VCC, cfg_18_adr_ena0);
  prim_bus_num_reg4 = DFFE(ad_IR4, clk, rstn, VCC, cfg_18_adr_ena0);
  prim_bus_num_reg5 = DFFE(ad_IR5, clk, rstn, VCC, cfg_18_adr_ena0);
  prim_bus_num_reg6 = DFFE(ad_IR6, clk, rstn, VCC, cfg_18_adr_ena0);
  prim_bus_num_reg7 = DFFE(ad_IR7, clk, rstn, VCC, cfg_18_adr_ena0);
  
  prim_bus_num_dat[7..0]  = prim_bus_num_reg[7..0];
  prim_bus_num_out[7..0]  = prim_bus_num_dat[7..0];
  
  -- Secondary Bus Number
  sec_bus_num_reg0  = DFFE(ad_IR8, clk, rstn, VCC, cfg_18_adr_ena1);
  sec_bus_num_reg1  = DFFE(ad_IR9, clk, rstn, VCC, cfg_18_adr_ena1);
  sec_bus_num_reg2  = DFFE(ad_IR10, clk, rstn, VCC, cfg_18_adr_ena1);
  sec_bus_num_reg3  = DFFE(ad_IR11, clk, rstn, VCC, cfg_18_adr_ena1);
  sec_bus_num_reg4  = DFFE(ad_IR12, clk, rstn, VCC, cfg_18_adr_ena1);
  sec_bus_num_reg5  = DFFE(ad_IR13, clk, rstn, VCC, cfg_18_adr_ena1);
  sec_bus_num_reg6  = DFFE(ad_IR14, clk, rstn, VCC, cfg_18_adr_ena1);
  sec_bus_num_reg7  = DFFE(ad_IR15, clk, rstn, VCC, cfg_18_adr_ena1);
  
  sec_bus_num_dat[7..0] = sec_bus_num_reg[7..0];
  sec_bus_num_out[7..0] = sec_bus_num_dat[7..0];
  
  -- Subordinate Bus Number Register
  IF (SUBORDINATE_BUS == "NO") GENERATE
    sub_bus_num_dat[7..0] = H"00";
  ELSE GENERATE
    sub_bus_num_reg0  = DFFE(ad_IR16, clk, rstn, VCC, cfg_18_adr_ena2);
    sub_bus_num_reg1  = DFFE(ad_IR17, clk, rstn, VCC, cfg_18_adr_ena2);
    sub_bus_num_reg2  = DFFE(ad_IR18, clk, rstn, VCC, cfg_18_adr_ena2);
    sub_bus_num_reg3  = DFFE(ad_IR19, clk, rstn, VCC, cfg_18_adr_ena2);
    sub_bus_num_reg4  = DFFE(ad_IR20, clk, rstn, VCC, cfg_18_adr_ena2);
    sub_bus_num_reg5  = DFFE(ad_IR21, clk, rstn, VCC, cfg_18_adr_ena2);
    sub_bus_num_reg6  = DFFE(ad_IR22, clk, rstn, VCC, cfg_18_adr_ena2);
    sub_bus_num_reg7  = DFFE(ad_IR23, clk, rstn, VCC, cfg_18_adr_ena2);
  
    sub_bus_num_dat[7..0] = sub_bus_num_reg[7..0];
  END GENERATE;

  sub_bus_num_out[7..0] = sub_bus_num_dat[7..0];
  
  -- Secondary Latency Timer Register

  sec_lat_reg0  = GND;
  sec_lat_reg1  = GND;
  sec_lat_reg2  = GND;
  sec_lat_reg3  = DFFE(ad_IR27, clk, rstn, VCC, cfg_18_adr_ena3);
  sec_lat_reg4  = DFFE(ad_IR28, clk, rstn, VCC, cfg_18_adr_ena3);
  sec_lat_reg5  = DFFE(ad_IR29, clk, rstn, VCC, cfg_18_adr_ena3);
  sec_lat_reg6  = DFFE(ad_IR30, clk, rstn, VCC, cfg_18_adr_ena3);
  sec_lat_reg7  = DFFE(ad_IR31, clk, rstn, VCC, cfg_18_adr_ena3);

  sec_lat_dat[7..0] = sec_lat_reg[7..0];
  sec_lat_out[7..0] = sec_lat_dat[7..0];
  
    
  -- Secondary Status Register
  sec_stat_reg[4..0]  = B"00000";
  IF (PCI_66MHZ_CAPABLE == "YES") GENERATE
      sec_stat_reg5   = VCC;                            -- Read Only, 66 MHz Capable
  ELSE GENERATE
      sec_stat_reg5   = GND;                            -- Read Only, 66 MHz Capable  
  END GENERATE;
  sec_stat_reg6   = GND;                                -- Read Only, UDF Supported
  sec_stat_reg7   = GND;                                -- Read Only, Fast Back-To-Back Capable
  sec_stat_reg8   = pcimt32_sr(sec_stat_set_in8, sec_stat_rst8, clk, rstn, VCC);  -- Master Data Parity Error Signaled
  sec_stat_reg[10..9] = B"10";                              -- Read Only, Devsel Timing, SLOW
  sec_stat_reg11    = pcimt32_sr(sec_stat_set_in11, sec_stat_rst11, clk, rstn, VCC);  -- Signaled Target Abort
  sec_stat_reg12    = pcimt32_sr(sec_stat_set_in12, sec_stat_rst12, clk, rstn, VCC);  -- Recieved Target Abort
  sec_stat_reg13    = pcimt32_sr(sec_stat_set_in13, sec_stat_rst13, clk, rstn, VCC);  -- Recieved Master Abort
  sec_stat_reg14    = pcimt32_sr(sec_stat_set_in14, sec_stat_rst14, clk, rstn, VCC);  -- Signaled SERR
  sec_stat_reg15    = pcimt32_sr(sec_stat_set_in15, sec_stat_rst15, clk, rstn, VCC);  -- Detected Parity Error
    
  sec_stat_rst[7..0]  = GND;
  sec_stat_rst8   = LCELL(cfg_1C_adr_ena3 and ad_IR24);
  sec_stat_rst[10..9] = GND;
  sec_stat_rst11    = LCELL(cfg_1C_adr_ena3 and ad_IR27);           -- Reset Signaled Target Abort Bit
  sec_stat_rst12    = LCELL(cfg_1C_adr_ena3 and ad_IR28);           -- Reset Received Target Abort Bit
  sec_stat_rst13    = LCELL(cfg_1C_adr_ena3 and ad_IR29);           -- Reset Recieved Master Abort Bit
  sec_stat_rst14    = LCELL(cfg_1C_adr_ena3 and ad_IR30);   -- Reset Signaled SERR Bit
  sec_stat_rst15    = LCELL(cfg_1C_adr_ena3 and ad_IR31);   -- Reset Detected Parity Error Bit

  sec_stat_dat[15..0] = sec_stat_reg[15..0];

  sec_stat_out[15..0]   = sec_stat_dat[15..0];
  
  no_op[15..0]      =   sec_stat_rst[15..0]
              OR  sec_stat_set_in[15..0];
  
  
  
  -- Memory Base Register
  -- Has 12 Read/Write Bits.  The bottom 4 bits are read only and are set to 0
  
  mem_base_reg[15..4].clk   = clk;
  mem_base_reg[15..4].clrn  = rstn;
  mem_base_reg[15..4].d   = ad_IR[15..4];
  mem_base_reg[7..4].ena    = cfg_20_adr_ena0;
  mem_base_reg[15..8].ena   = cfg_20_adr_ena1;
  
  mem_base_dat[15..0]     = (mem_base_reg[15..4], B"0000");
  mem_base_out[15..0]     = mem_base_dat[15..0];
  
  -- Memory Limit Register
  -- Has 12 Read/Write Bits
  -- The Bottom 4 bits are read only and are set to 0
  
  mem_limit_reg[15..4].clk  = clk;
  mem_limit_reg[15..4].clrn = rstn;
  mem_limit_reg[15..4].d    = ad_IR[31..20];
  mem_limit_reg[7..4].ena   = cfg_20_adr_ena2;
  mem_limit_reg[15..8].ena  = cfg_20_adr_ena3;
  
  mem_limit_dat[15..0]    = (mem_limit_reg[15..4], B"0000");
  mem_limit_out[15..0]    = mem_limit_dat[15..0];

  IF (PREFETCHABLE_MEMORY == "NO") GENERATE
    prfch_mem_limit_dat[15..0]  = H"0000";
    prfch_mem_base_dat[15..0] = H"0000";
  
    prfch_mem_base_out[15..0]   = prfch_mem_limit_dat[15..0]; -- Memory Base Register Input
    prfch_mem_limit_out[15..0]    = prfch_mem_base_dat[15..0] ; -- Memory Limit Register Input
  
  ELSE GENERATE
    prfch_mem_base_reg[15..4].clk = clk;
    prfch_mem_base_reg[15..4].clrn  = rstn;
    prfch_mem_base_reg[15..4].d   = ad_IR[15..4]; 
    prfch_mem_base_reg[7..4].ena  = cfg_24_adr_ena0;
    prfch_mem_base_reg[15..8].ena   = cfg_24_adr_ena1;
    
    prfch_mem_base_dat[15..0]   = (prfch_mem_base_reg[15..4], B"0000");
    prfch_mem_base_out[15..0]   = prfch_mem_base_dat[15..0];
  
    -- Memory Limit Register
    -- Has 12 Read/Write Bits
    -- The Bottom 4 bits are read only and are set to 0
  
    prfch_mem_limit_reg[15..4].clk  = clk;
    prfch_mem_limit_reg[15..4].clrn = rstn; 
    prfch_mem_limit_reg[15..4].d  = ad_IR[31..20];
    prfch_mem_limit_reg[7..4].ena = cfg_24_adr_ena2;
    prfch_mem_limit_reg[15..8].ena  = cfg_24_adr_ena3;
  
    prfch_mem_limit_dat[15..0]    = (prfch_mem_limit_reg[15..4], B"0000");
    prfch_mem_limit_out[15..0]    = prfch_mem_limit_dat[15..0];
  END GENERATE;
  
  prfch_base_up_dat[31..0]  = H"00000000";
  prfch_limit_up_dat[31..0] = H"00000000";  

  prfch_mem_base_up_out[31..0]  = prfch_base_up_dat[31..0]  ; -- Memory Base Register Input
  prfch_mem_limit_up_out[31..0] = prfch_limit_up_dat[31..0] ; -- Memory Limit Register Input    

  
  IF (IO_ADDR_32BIT == "NO") GENERATE
    -- I/O Base Register
    -- Has 4 Read/Write Bits.  
    -- The bottom 4 bits are read only and are set to 0

    io_base_up_dat[15..0]   = H"0000";
    io_base_up_out[15..0]   = io_base_up_dat[15..0];
    
    io_limit_up_dat[15..0]    = H"0000";
    io_limit_up_out[15..0]    = io_limit_up_dat[15..0];
    
    io_base_reg[7..4].clk   = clk;
    io_base_reg[7..4].clrn    = rstn;
    io_base_reg[7..4].d     = ad_IR[7..4];
    io_base_reg[7..4].ena   = cfg_1c_adr_ena0;
  
    io_base_dat[7..0]     = (io_base_reg[7..4], B"0000");
    io_base_out[7..0]     = io_base_dat[7..0];
  
    -- I/O Limit Register
    -- Has 4 Read/Write Bits
    -- The Bottom 4 bits are read only and are set to 0
  
    io_limit_reg[7..4].clk    = clk;
    io_limit_reg[7..4].clrn   = rstn;
    io_limit_reg[7..4].d    = ad_IR[15..12];  
    io_limit_reg[7..4].ena    = cfg_1c_adr_ena1;
    
    io_limit_dat[7..0]      = (io_limit_reg[7..4], B"0000");
    io_limit_out[7..0]      = io_limit_dat[7..0];
  
  ELSE GENERATE 

    -- I/O Base Register
    -- Has 4 Read/Write Bits.  
    -- The bottom 4 bits are read only and are set to 0

    io_base_up_reg[15..0].clk = clk;
    io_base_up_reg[15..0].clrn  = rstn;
    io_base_up_reg[15..0].d   = ad_IR[15..0];
    io_base_up_reg[7..0].ena  = cfg_30_adr_ena0;
    io_base_up_reg[15..8].ena   = cfg_30_adr_ena1;
    
    io_base_up_dat[15..0]   = (io_base_up_reg[15..0]);
    io_base_up_out[15..0]   = io_base_up_dat[15..0];
    
    io_limit_up_reg[15..0].clk  = clk;
    io_limit_up_reg[15..0].clrn = rstn;
    io_limit_up_reg[15..0].d  = ad_IR[31..16];
    io_limit_up_reg[7..0].ena = cfg_30_adr_ena2;
    io_limit_up_reg[15..8].ena  = cfg_30_adr_ena3;
  
    io_limit_up_dat[15..0]    = (io_limit_up_reg[15..0]);
    io_limit_up_out[15..0]    = io_limit_up_dat[15..0];


    io_base_reg[7..4].clk   = clk;
    io_base_reg[7..4].clrn    = rstn;
    io_base_reg[7..4].d     = ad_IR[7..4];
    io_base_reg[7..4].ena   = cfg_1c_adr_ena0;
  
    io_base_dat[7..0]     = (io_base_reg[7..4], B"0001");
    io_base_out[7..0]     = io_base_dat[7..0];
  
    -- I/O Limit Register
    -- Has 4 Read/Write Bits
    -- The Bottom 4 bits are read only and are set to 0
  
    io_limit_reg[7..4].clk    = clk;
    io_limit_reg[7..4].clrn   = rstn;
    io_limit_reg[7..4].d    = ad_IR[15..12];  
    io_limit_reg[7..4].ena    = cfg_1c_adr_ena1;
    
    io_limit_dat[7..0]      = (io_limit_reg[7..4], B"0001");
    io_limit_out[7..0]      = io_limit_dat[7..0];

  END GENERATE;


  exp_rom_dat[31..0]        = H"00000000";
  exp_rom_out[31..0]      = exp_rom_dat[31..0]; 

  -- Bridge Control Register
  brdg_ctrl_reg0    = DFFE(ad_IR16, clk, rstn, VCC, cfg_3C_adr_ena2);   -- Parity Error Response
  brdg_ctrl_reg1    = DFFE(ad_IR17, clk, rstn, VCC, cfg_3C_adr_ena2);   -- Serr Enable
  brdg_ctrl_reg[4..2] = GND;
  brdg_ctrl_reg5    = DFFE(ad_IR21, clk, rstn, VCC, cfg_3C_adr_ena2);   -- Master Abort Mode
  brdg_ctrl_reg6    = DFFE(ad_IR22, clk, rstn, VCC, cfg_3C_adr_ena2);   -- Secondary Bus Reset
  
  IF (DISCARD_TIMER == "NO") GENERATE
    brdg_ctrl_reg[15..7] = GND;
  ELSE GENERATE
    brdg_ctrl_reg[9..7]   = GND;
    brdg_ctrl_reg10     = pcimt32_sr(discard_set, discard_rst, clk, rstn,VCC);      
    brdg_ctrl_reg11     = DFFE(ad_IR27, clk, rstn, VCC, cfg_3C_adr_ena3);   
    brdg_ctrl_reg[15..12] = GND;

    discard_rst       = ad_IR27 AND cfg_3C_adr_ena3;
  END GENERATE;
  
  brdg_ctrl_dat[15..0]= brdg_ctrl_reg[15..0]; 
  brdg_ctrl_out[15..0]  = brdg_ctrl_dat[15..0];
  
  IF (CAP_LIST_ENA == 1) GENERATE
    cap_ptr_dat[7..0]     = CAP_PTR;    -- Capabilities Pointer
  ELSE GENERATE
    cap_ptr_dat[7..0]     = H"00";    -- Capabilities Pointer
  END GENERATE;

  cap_ptr_out[7..0] = cap_ptr_dat[7..0];
  
-- Additional base/Limit Registers

  IF (P2P_MBS_MLMT_1_ENA == 1 ) GENERATE
    
    assert report " Implementing Memory Base/Limit pair at Address 40 Hex and Prefetchable Memory Base/Limit Pair at Address 44 Hex"
    severity INFO;
    

    cfg_dec_adr_up4   = LCELL (ad_IR_addr[7..4] == B"0100");
    cfg_adr40_selR.clk  = clk;
    cfg_adr40_selR.clrn = rstn;
    cfg_adr40_selR    = cfg_dec_adr_up4 AND ( ad_IR_addr[3..2] == B"00"); 
    
    cfg_adr44_selR.clk  = clk;
    cfg_adr44_selR.clrn = rstn;
    cfg_adr44_selR    = cfg_dec_adr_up4 AND ( ad_IR_addr[3..2] == B"01"); 
    
    cfg_40_adr_ena[3..0]  = cfg_adr40_selR and cfg_dat_vld and not cben_IR[3..0];   
    cfg_44_adr_ena[3..0]  = cfg_adr44_selR and cfg_dat_vld and not cben_IR[3..0];   

    mem_base_1_reg[15..4].clk = clk;
    mem_base_1_reg[15..4].clrn  = rstn;
    mem_base_1_reg[15..4].d   = ad_IR[15..4];
        
    mem_base_1_reg[7..4].ena  = cfg_40_adr_ena0;
    mem_base_1_reg[15..8].ena   = cfg_40_adr_ena1;
    
    mem_base_1_dat[15..0]   = (mem_base_1_reg[15..4], B"0000");
    mem_base_1_out[15..0]   = mem_base_1_dat[15..0];
    
    -- Memory Limit Register
    -- Has 12 Read/Write Bits
    -- The Bottom 4 bits are read only and are set to 0
    
    mem_limit_1_reg[15..4].clk  = clk;
    mem_limit_1_reg[15..4].clrn = rstn;
    mem_limit_1_reg[15..4].d  = ad_IR[31..20];
    mem_limit_1_reg[7..4].ena = cfg_40_adr_ena2;
    mem_limit_1_reg[15..8].ena  = cfg_40_adr_ena3;
    
    mem_limit_1_dat[15..0]    = (mem_limit_1_reg[15..4], B"0000");
    mem_limit_1_out[15..0]    = mem_limit_1_dat[15..0];
    
    mem_base_limit_1_dat[31..0] = (mem_limit_1_dat[15..0], mem_base_1_dat[15..0]);
    
    
    prfch_mem_base_1_reg[15..4].clk   = clk;
    prfch_mem_base_1_reg[15..4].clrn  = rstn;
    prfch_mem_base_1_reg[15..4].d   = ad_IR[15..4]; 
    prfch_mem_base_1_reg[7..4].ena    = cfg_44_adr_ena0;
    prfch_mem_base_1_reg[15..8].ena   = cfg_44_adr_ena1;
      
    prfch_mem_base_1_dat[15..0]     = (prfch_mem_base_1_reg[15..4], B"0000");
    prfch_mem_base_1_out[15..0]     = prfch_mem_base_1_dat[15..0];
    
      -- Memory Limit Register
      -- Has 12 Read/Write Bits
      -- The Bottom 4 bits are read only and are set to 0
    
    prfch_mem_limit_1_reg[15..4].clk  = clk;
    prfch_mem_limit_1_reg[15..4].clrn = rstn; 
    prfch_mem_limit_1_reg[15..4].d    = ad_IR[31..20];
    prfch_mem_limit_1_reg[7..4].ena   = cfg_44_adr_ena2;
    prfch_mem_limit_1_reg[15..8].ena  = cfg_44_adr_ena3;
    
    prfch_mem_limit_1_dat[15..0]    = (prfch_mem_limit_1_reg[15..4], B"0000");
    prfch_mem_limit_1_out[15..0]    = prfch_mem_limit_1_dat[15..0];
    
    prfch_mbase_lim_1_dat[31..0]  = (prfch_mem_limit_1_dat[15..0], prfch_mem_base_1_dat[15..0]);
    
    cfg_adr_40_54_dat[31..0]      =   (mem_base_limit_1_dat[31..0]) and cfg_adr40_selR
                      OR  (prfch_mbase_lim_1_dat[31..0]) and cfg_adr44_selR
                      OR  cfg_adr_48_54_dat[31..0];
                      
    IF (PRIMARY_INTERFACE == "YES") GENERATE
      mem_spc_1_dis_comp.dataa[] = mem_base_1_reg[15..4];
      mem_spc_1_dis_comp.datab[] = mem_limit_1_reg[15..4];

      mem_spc_1_dis.clk     = clk;
      mem_spc_1_dis.clrn      = rstn;
      mem_spc_1_dis.d       = mem_spc_1_dis_comp.agb;


      mem_base_1_comp.dataa[]   =  ad_IR_addr[31..20];
      mem_base_1_comp.datab[]   =  mem_base_1_reg[15..4];
      adr_ge_mem_base1      =  mem_base_1_comp.ageb;
    
      mem_limit_1_comp.dataa[]  = ad_IR_addr[31..20];
      mem_limit_1_comp.datab[]  =   mem_limit_1_reg[15..4];
      adr_le_mem_limit1     =   mem_limit_1_comp.aleb;

      prfch_mem_spc_1_dis_comp.dataa[]  = prfch_mem_base_1_reg[15..4];
      prfch_mem_spc_1_dis_comp.datab[]  = prfch_mem_limit_1_reg[15..4];

      prfch_mem_spc_1_dis.clk   = clk;
      prfch_mem_spc_1_dis.clrn    = rstn;
      prfch_mem_spc_1_dis.d       = prfch_mem_spc_1_dis_comp.agb;


      prfch_mem_base_1_comp.dataa[]   =  ad_IR_addr[31..20];
      prfch_mem_base_1_comp.datab[]     =  prfch_mem_base_1_reg[15..4];
      prfch_adr_ge_mem_base1        =  prfch_mem_base_1_comp.ageb;
    
      prfch_mem_limit_1_comp.dataa[]    = ad_IR_addr[31..20];
      prfch_mem_limit_1_comp.datab[]    =   prfch_mem_limit_1_reg[15..4];
      prfch_adr_le_mem_limit1     =   prfch_mem_limit_1_comp.aleb;


    
    ELSE GENERATE
    
      mem_spc_1_dis_comp.dataa[] = mem_base_1_in[15..4];
      mem_spc_1_dis_comp.datab[] = mem_limit_1_in[15..4];

      mem_spc_1_dis.clk     = clk;
      mem_spc_1_dis.clrn      = rstn;
      mem_spc_1_dis.d       = mem_spc_1_dis_comp.agb;


      mem_base_1_comp.dataa[]   =  ad_IR_addr[31..20];
      mem_base_1_comp.datab[]   =  mem_base_1_in[15..4];
      adr_ge_mem_base1      =  mem_base_1_comp.ageb;
    
      mem_limit_1_comp.dataa[]  = ad_IR_addr[31..20];
      mem_limit_1_comp.datab[]  =   mem_limit_1_in[15..4];
      adr_le_mem_limit1     =   mem_limit_1_comp.aleb;


      prfch_mem_spc_1_dis_comp.dataa[]  = prfch_mem_base_1_in[15..4];
      prfch_mem_spc_1_dis_comp.datab[]  = prfch_mem_limit_1_in[15..4];
                   
      prfch_mem_spc_1_dis.clk   = clk;
      prfch_mem_spc_1_dis.clrn    = rstn;
      prfch_mem_spc_1_dis.d       = prfch_mem_spc_1_dis_comp.agb;
                   
                   
      prfch_mem_base_1_comp.dataa[]   =  ad_IR_addr[31..20];
      prfch_mem_base_1_comp.datab[]     =  prfch_mem_base_1_in[15..4];
      prfch_adr_ge_mem_base1        =  prfch_mem_base_1_comp.ageb;
               
      prfch_mem_limit_1_comp.dataa[]    = ad_IR_addr[31..20];
      prfch_mem_limit_1_comp.datab[]    =   prfch_mem_limit_1_in[15..4];
      prfch_adr_le_mem_limit1     =   prfch_mem_limit_1_comp.aleb;
                   
                   
    END GENERATE;
    
                      
  ELSE GENERATE
    mem_base_1_out[15..0]     = GND;
    mem_limit_1_out[15..0]      = GND;
    prfch_mem_base_1_out[15..0]   = GND;
    prfch_mem_limit_1_out[15..0]  = GND;
    cfg_adr_40_54_dat[31..0]    = GND;
    mem_spc_1_dis         = GND;
    adr_le_mem_limit1       = GND;
    adr_ge_mem_base1        = GND;
    prfch_mem_spc_1_dis       = GND;
    prfch_adr_le_mem_limit1     = GND;
    prfch_adr_ge_mem_base1      = GND;
      
  END GENERATE;
  
  
  IF (P2P_MBS_MLMT_2_ENA == 1 ) GENERATE
    IF (P2P_MBS_MLMT_1_ENA == 0) GENERATE
      assert report "You must enable Memory Base/Limit 1 and Prefetchable Memory Base/Limit 1 registers."
      severity ERROR;
    END GENERATE; 
    assert report " Implementing Memory Base/Limit pair at Address 48 Hex and Prefetchable Memory Base/Limit Pair at Address 4C Hex"
    severity INFO;
    cfg_adr48_selR.clk  = clk;
    cfg_adr48_selR.clrn = rstn;
    cfg_adr48_selR    = cfg_dec_adr_up4 AND ( ad_IR_addr[3..2] == B"10"); 
    
    cfg_adr4C_selR.clk  = clk;
    cfg_adr4C_selR.clrn = rstn;
    cfg_adr4C_selR    = cfg_dec_adr_up4 AND ( ad_IR_addr[3..2] == B"11"); 

    cfg_48_adr_ena[3..0]  = cfg_adr48_selR and cfg_dat_vld and not cben_IR[3..0];   
    cfg_4C_adr_ena[3..0]  = cfg_adr4C_selR and cfg_dat_vld and not cben_IR[3..0];   


    mem_base_2_reg[15..4].clk = clk;
    mem_base_2_reg[15..4].clrn  = rstn;
    mem_base_2_reg[15..4].d   = ad_IR[15..4];
        
    mem_base_2_reg[7..4].ena  = cfg_48_adr_ena0;
    mem_base_2_reg[15..8].ena   = cfg_48_adr_ena1;
    
    mem_base_2_dat[15..0]   = (mem_base_2_reg[15..4], B"0000");
    mem_base_2_out[15..0]   = mem_base_2_dat[15..0];
    
    -- Memory Limit Register
    -- Has 12 Read/Write Bits
    -- The Bottom 4 bits are read only and are set to 0
    
    mem_limit_2_reg[15..4].clk  = clk;
    mem_limit_2_reg[15..4].clrn = rstn;
    mem_limit_2_reg[15..4].d  = ad_IR[31..20];
    mem_limit_2_reg[7..4].ena = cfg_48_adr_ena2;
    mem_limit_2_reg[15..8].ena  = cfg_48_adr_ena3;
    
    mem_limit_2_dat[15..0]    = (mem_limit_2_reg[15..4], B"0000");
    mem_limit_2_out[15..0]    = mem_limit_2_dat[15..0];
    
    mem_base_limit_2_dat[31..0] = (mem_limit_2_dat[15..0], mem_base_2_dat[15..0]);
    
    
    prfch_mem_base_2_reg[15..4].clk   = clk;
    prfch_mem_base_2_reg[15..4].clrn  = rstn;
    prfch_mem_base_2_reg[15..4].d   = ad_IR[15..4]; 
    prfch_mem_base_2_reg[7..4].ena    = cfg_4C_adr_ena0;
    prfch_mem_base_2_reg[15..8].ena   = cfg_4C_adr_ena1;
      
    prfch_mem_base_2_dat[15..0]     = (prfch_mem_base_2_reg[15..4], B"0000");
    prfch_mem_base_2_out[15..0]     = prfch_mem_base_2_dat[15..0];
    
      -- Memory Limit Register
      -- Has 12 Read/Write Bits
      -- The Bottom 4 bits are read only and are set to 0
    
    prfch_mem_limit_2_reg[15..4].clk  = clk;
    prfch_mem_limit_2_reg[15..4].clrn = rstn; 
    prfch_mem_limit_2_reg[15..4].d    = ad_IR[31..20];
    prfch_mem_limit_2_reg[7..4].ena   = cfg_4C_adr_ena2;
    prfch_mem_limit_2_reg[15..8].ena  = cfg_4C_adr_ena3;
    
    prfch_mem_limit_2_dat[15..0]    = (prfch_mem_limit_2_reg[15..4], B"0000");
    prfch_mem_limit_2_out[15..0]    = prfch_mem_limit_2_dat[15..0];
    
    prfch_mbase_lim_2_dat[31..0]  = (prfch_mem_limit_2_dat[15..0], prfch_mem_base_2_dat[15..0]);
    
    cfg_adr_48_54_dat[31..0]      =   (mem_base_limit_2_dat[31..0]) and cfg_adr48_selR
                      OR  (prfch_mbase_lim_2_dat[31..0]) and cfg_adr4C_selR
                      OR  cfg_adr_50_54_dat[31..0];
                      
    IF (PRIMARY_INTERFACE == "YES") GENERATE
      mem_spc_2_dis_comp.dataa[] = mem_base_2_reg[15..4];
      mem_spc_2_dis_comp.datab[] = mem_limit_2_reg[15..4];

      mem_spc_2_dis.clk     = clk;
      mem_spc_2_dis.clrn      = rstn;
      mem_spc_2_dis.d       = mem_spc_2_dis_comp.agb;


      mem_base_2_comp.dataa[]   =  ad_IR_addr[31..20];
      mem_base_2_comp.datab[]   =  mem_base_2_reg[15..4];
      adr_ge_mem_base2      =  mem_base_2_comp.ageb;
    
      mem_limit_2_comp.dataa[]  = ad_IR_addr[31..20];
      mem_limit_2_comp.datab[]  =   mem_limit_2_reg[15..4];
      adr_le_mem_limit2     =   mem_limit_2_comp.aleb;


      
      prfch_mem_spc_2_dis_comp.dataa[]  = prfch_mem_base_2_reg[15..4];
      prfch_mem_spc_2_dis_comp.datab[]  = prfch_mem_limit_2_reg[15..4];

      prfch_mem_spc_2_dis.clk     = clk;
      prfch_mem_spc_2_dis.clrn    = rstn;
      prfch_mem_spc_2_dis.d       = prfch_mem_spc_2_dis_comp.agb;


      prfch_mem_base_2_comp.dataa[]   =  ad_IR_addr[31..20];
      prfch_mem_base_2_comp.datab[]     =  prfch_mem_base_2_reg[15..4];
      prfch_adr_ge_mem_base2        =  prfch_mem_base_2_comp.ageb;
    
      prfch_mem_limit_2_comp.dataa[]    = ad_IR_addr[31..20];
      prfch_mem_limit_2_comp.datab[]    =   prfch_mem_limit_2_reg[15..4];
      prfch_adr_le_mem_limit2     =   prfch_mem_limit_2_comp.aleb;


    
    ELSE GENERATE
      mem_spc_2_dis_comp.dataa[] = mem_base_2_in[15..4];
      mem_spc_2_dis_comp.datab[] = mem_limit_2_in[15..4];

      mem_spc_2_dis.clk     = clk;
      mem_spc_2_dis.clrn      = rstn;
      mem_spc_2_dis.d       = mem_spc_2_dis_comp.agb;


      mem_base_2_comp.dataa[]   =  ad_IR_addr[31..20];
      mem_base_2_comp.datab[]   =  mem_base_2_in[15..4];
      adr_ge_mem_base2      =  mem_base_2_comp.ageb;
    
      mem_limit_2_comp.dataa[]  = ad_IR_addr[31..20];
      mem_limit_2_comp.datab[]  =   mem_limit_2_in[15..4];
      adr_le_mem_limit2     =   mem_limit_2_comp.aleb;

                            
      prfch_mem_spc_2_dis_comp.dataa[]  = prfch_mem_base_2_in[15..4];
      prfch_mem_spc_2_dis_comp.datab[]  = prfch_mem_limit_2_in[15..4];
                   
      prfch_mem_spc_2_dis.clk       = clk;
      prfch_mem_spc_2_dis.clrn      = rstn;
      prfch_mem_spc_2_dis.d         = prfch_mem_spc_2_dis_comp.agb;
                   
                   
      prfch_mem_base_2_comp.dataa[]   =  ad_IR_addr[31..20];
      prfch_mem_base_2_comp.datab[]     =  prfch_mem_base_2_in[15..4];
      prfch_adr_ge_mem_base2        =  prfch_mem_base_2_comp.ageb;
               
      prfch_mem_limit_2_comp.dataa[]    = ad_IR_addr[31..20];
      prfch_mem_limit_2_comp.datab[]    =   prfch_mem_limit_2_in[15..4];
      prfch_adr_le_mem_limit2     =   prfch_mem_limit_2_comp.aleb;
                   
                   
    END GENERATE;
    
                      
  ELSE GENERATE
    mem_base_2_out[15..0]     = GND;
    mem_limit_2_out[15..0]      = GND;
    prfch_mem_base_2_out[15..0]   = GND;
    prfch_mem_limit_2_out[15..0]  = GND;
    cfg_adr_48_54_dat[31..0]      = GND;
    mem_spc_2_dis           = GND;
    adr_le_mem_limit2         = GND;
    adr_ge_mem_base2          = GND;
    prfch_mem_spc_2_dis       = GND;
    prfch_adr_le_mem_limit2     = GND;
    prfch_adr_ge_mem_base2        = GND;
  END GENERATE;

  IF (P2P_MBS_MLMT_3_ENA == 1 ) GENERATE
  -- Additional Decode functions for the additional base and limit registers
    IF ((P2P_MBS_MLMT_1_ENA == 0) OR (P2P_MBS_MLMT_2_ENA == 0)) GENERATE
      assert report "You must enable Memory Base/Limit 1,2 and Prefetchable Memory Base/Limit 1,2 registers."
      severity ERROR;
    END GENERATE; 
    assert report " Implementing Memory Base/Limit pair at Address 50 Hex and Prefetchable Memory Base/Limit Pair at Address 54 Hex"
    severity INFO;
    cfg_dec_adr_up5       = LCELL (ad_IR_addr[7..4] == B"0101");
    cfg_adr50_selR.clk      = clk;
    cfg_adr50_selR.clrn     = rstn;
    cfg_adr50_selR        = cfg_dec_adr_up5 AND ( ad_IR_addr[3..2] == B"00"); 
    
    cfg_adr54_selR.clk      = clk;
    cfg_adr54_selR.clrn     = rstn;
    cfg_adr54_selR        = cfg_dec_adr_up5 AND ( ad_IR_addr[3..2] == B"01"); 

    cfg_50_adr_ena[3..0]    = cfg_adr50_selR and cfg_dat_vld and not cben_IR[3..0];   
    cfg_54_adr_ena[3..0]    = cfg_adr54_selR and cfg_dat_vld and not cben_IR[3..0];   


    mem_base_3_reg[15..4].clk = clk;
    mem_base_3_reg[15..4].clrn  = rstn;
    mem_base_3_reg[15..4].d   = ad_IR[15..4];
        
    mem_base_3_reg[7..4].ena  = cfg_50_adr_ena0;
    mem_base_3_reg[15..8].ena   = cfg_50_adr_ena1;
  
    mem_base_3_dat[15..0]   = (mem_base_3_reg[15..4], B"0000");
    mem_base_3_out[15..0]   = mem_base_3_dat[15..0];
    
    -- Memory Limit Register
    -- Has 12 Read/Write Bits
    -- The Bottom 4 bits are read only and are set to 0
    
    mem_limit_3_reg[15..4].clk  = clk;
    mem_limit_3_reg[15..4].clrn = rstn;
    mem_limit_3_reg[15..4].d  = ad_IR[31..20];
    mem_limit_3_reg[7..4].ena = cfg_50_adr_ena2;
    mem_limit_3_reg[15..8].ena  = cfg_50_adr_ena3;
    
    mem_limit_3_dat[15..0]    = (mem_limit_3_reg[15..4], B"0000");
    mem_limit_3_out[15..0]    = mem_limit_3_dat[15..0];
    
    mem_base_limit_3_dat[31..0] = (mem_limit_3_dat[15..0], mem_base_3_dat[15..0]);
    
    
    prfch_mem_base_3_reg[15..4].clk   = clk;
    prfch_mem_base_3_reg[15..4].clrn  = rstn;
    prfch_mem_base_3_reg[15..4].d   = ad_IR[15..4]; 
    prfch_mem_base_3_reg[7..4].ena    = cfg_54_adr_ena0;
    prfch_mem_base_3_reg[15..8].ena   = cfg_54_adr_ena1;
      
    prfch_mem_base_3_dat[15..0]     = (prfch_mem_base_3_reg[15..4], B"0000");
    prfch_mem_base_3_out[15..0]     = prfch_mem_base_3_dat[15..0];
    
      -- Memory Limit Register
      -- Has 12 Read/Write Bits
      -- The Bottom 4 bits are read only and are set to 0
    
    prfch_mem_limit_3_reg[15..4].clk  = clk;
    prfch_mem_limit_3_reg[15..4].clrn = rstn; 
    prfch_mem_limit_3_reg[15..4].d    = ad_IR[31..20];
    prfch_mem_limit_3_reg[7..4].ena   = cfg_54_adr_ena2;
    prfch_mem_limit_3_reg[15..8].ena  = cfg_54_adr_ena3;
    
    prfch_mem_limit_3_dat[15..0]    = (prfch_mem_limit_3_reg[15..4], B"0000");
    prfch_mem_limit_3_out[15..0]    = prfch_mem_limit_3_dat[15..0];
    
    prfch_mbase_lim_3_dat[31..0]  = (prfch_mem_limit_3_dat[15..0], prfch_mem_base_3_dat[15..0]);
    
    cfg_adr_50_54_dat[31..0]      =   (mem_base_limit_3_dat[31..0]) and cfg_adr50_selR
                      OR  (prfch_mbase_lim_3_dat[31..0]) and cfg_adr54_selR;
                      
    IF (PRIMARY_INTERFACE == "YES") GENERATE
      mem_spc_3_dis_comp.dataa[] = mem_base_3_reg[15..4];
      mem_spc_3_dis_comp.datab[] = mem_limit_3_reg[15..4];

      mem_spc_3_dis.clk     = clk;
      mem_spc_3_dis.clrn      = rstn;
      mem_spc_3_dis.d       = mem_spc_3_dis_comp.agb;


      mem_base_3_comp.dataa[]   =  ad_IR_addr[31..20];
      mem_base_3_comp.datab[]   =  mem_base_3_reg[15..4];
      adr_ge_mem_base3      =  mem_base_3_comp.ageb;
    
      mem_limit_3_comp.dataa[]  = ad_IR_addr[31..20];
      mem_limit_3_comp.datab[]  =   mem_limit_3_reg[15..4];
      adr_le_mem_limit3     =   mem_limit_3_comp.aleb;


    
      prfch_mem_spc_3_dis_comp.dataa[]  = prfch_mem_base_3_reg[15..4];
      prfch_mem_spc_3_dis_comp.datab[]  = prfch_mem_limit_3_reg[15..4];

      prfch_mem_spc_3_dis.clk     = clk;
      prfch_mem_spc_3_dis.clrn    = rstn;
      prfch_mem_spc_3_dis.d       = prfch_mem_spc_3_dis_comp.agb;


      prfch_mem_base_3_comp.dataa[]   =  ad_IR_addr[31..20];
      prfch_mem_base_3_comp.datab[]     =  prfch_mem_base_3_reg[15..4];
      prfch_adr_ge_mem_base3        =  prfch_mem_base_3_comp.ageb;
    
      prfch_mem_limit_3_comp.dataa[]    = ad_IR_addr[31..20];
      prfch_mem_limit_3_comp.datab[]    =   prfch_mem_limit_3_reg[15..4];
      prfch_adr_le_mem_limit3     =   prfch_mem_limit_3_comp.aleb;


    ELSE GENERATE
      mem_spc_3_dis_comp.dataa[] = mem_base_3_in[15..4];
      mem_spc_3_dis_comp.datab[] = mem_limit_3_in[15..4];

      mem_spc_3_dis.clk     = clk;
      mem_spc_3_dis.clrn      = rstn;
      mem_spc_3_dis.d       = mem_spc_3_dis_comp.agb;


      mem_base_3_comp.dataa[]   =  ad_IR_addr[31..20];
      mem_base_3_comp.datab[]   =  mem_base_3_in[15..4];
      adr_ge_mem_base3      =  mem_base_3_comp.ageb;
    
      mem_limit_3_comp.dataa[]  = ad_IR_addr[31..20];
      mem_limit_3_comp.datab[]  =   mem_limit_3_in[15..4];
      adr_le_mem_limit3     =   mem_limit_3_comp.aleb;


      prfch_mem_spc_3_dis_comp.dataa[]  = prfch_mem_base_3_in[15..4];
      prfch_mem_spc_3_dis_comp.datab[]  = prfch_mem_limit_3_in[15..4];
                   
      prfch_mem_spc_3_dis.clk     = clk;
      prfch_mem_spc_3_dis.clrn    = rstn;
      prfch_mem_spc_3_dis.d       = prfch_mem_spc_3_dis_comp.agb;
                   
                   
      prfch_mem_base_3_comp.dataa[]   =  ad_IR_addr[31..20];
      prfch_mem_base_3_comp.datab[]     =  prfch_mem_base_3_in[15..4];
      prfch_adr_ge_mem_base3        =  prfch_mem_base_3_comp.ageb;
               
      prfch_mem_limit_3_comp.dataa[]    = ad_IR_addr[31..20];
      prfch_mem_limit_3_comp.datab[]    =   prfch_mem_limit_3_in[15..4];
      prfch_adr_le_mem_limit3       =   prfch_mem_limit_3_comp.aleb;
                   
                   
    END GENERATE;
    
                      
  ELSE GENERATE
    mem_base_3_out[15..0]     = GND;
    mem_limit_3_out[15..0]      = GND;
    prfch_mem_base_3_out[15..0]   = GND;
    prfch_mem_limit_3_out[15..0]  = GND;
    cfg_adr_50_54_dat[31..0]      = GND;
    mem_spc_3_dis           = GND;
    adr_le_mem_limit3         = GND;
    adr_ge_mem_base3          = GND;
    prfch_mem_spc_3_dis       = GND;
    prfch_adr_le_mem_limit3     = GND;
    prfch_adr_ge_mem_base3        = GND;

  END GENERATE;
  
  IF (PRIMARY_INTERFACE == "YES") GENERATE
  
    mem_space_disabled.clk  = clk;
    mem_space_disabled.clrn = rstn;
  --- IF (mem_base_reg[15..4] < mem_limit_reg[15..4]) Then
  --    mem_space_disabled  = GND;
  --  ELSE
  --    mem_space_disabled  = VCC;
  --  END IF;
  
    mem_space_disabled_comp.dataa[] = mem_base_reg[15..4];
    mem_space_disabled_comp.datab[] = mem_limit_reg[15..4];
    mem_space_disabled.d      = mem_space_disabled_comp.agb;

--    IF ( ad_IR_addr[31..20] >= mem_base_reg[15..4]) Then
--      adr_ge_mem_base     = VCC;
--    else
--      adr_ge_mem_base     = gnd;
--    end if;

    mem_base_comp.dataa[]   =  ad_IR_addr[31..20];
    mem_base_comp.datab[]     =  mem_base_reg[15..4];
    adr_ge_mem_base       =  mem_base_comp.ageb;
    
--    IF (ad_IR_addr[31..20] <= mem_limit_reg[15..4]) Then
--      adr_le_mem_limit    = VCC;
--    else
--      adr_le_mem_limit    = GND;
--    end if;

    mem_limit_comp.dataa[]  = ad_IR_addr[31..20];
    mem_limit_comp.datab[]  =   mem_limit_reg[15..4];
    adr_le_mem_limit    =   mem_limit_comp.aleb;


    -- This node is set if the core is Primary PCI interface and 
    -- the primary master is enabled, The primary memory Space is enabled
    -- and the address is greater than memory base and less than memory limit
    -- the memory space can be disabled by setting the memroy limit 
    -- less than the memory base.
    -- This equation assumes that there are no prefetchable address space 
      mem_adr_vld_cascade   = ( mem_cyc 
                        and adr_phase 
                        and mem_access_enable);
      mem_adr_vld       =   ( LCELL ( not mem_spc_1_dis 
                        and adr_ge_mem_base1    
                        and adr_le_mem_limit1
                        )
                  OR  LCELL ( not mem_spc_2_dis 
                        and adr_ge_mem_base2    
                        and adr_le_mem_limit2
                        )
                  OR  LCELL ( not mem_spc_3_dis 
                        and adr_ge_mem_base3    
                        and adr_le_mem_limit3
                        )
                  OR  ( not mem_space_disabled 
                    and adr_ge_mem_base
                    and adr_le_mem_limit
                    )
                  )
                  and mem_adr_vld_cascade;
    
    
    IF (PREFETCHABLE_MEMORY == "YES") GENERATE      -- PRFCH

      prfch_mem_space_disabled.clk    = clk;
      prfch_mem_space_disabled.clrn   = rstn;
      
      prfch_mem_space_disabled_comp.dataa[] = prfch_mem_base_reg[15..4] ;
      prfch_mem_space_disabled_comp.datab[] = prfch_mem_limit_reg[15..4];
      
      prfch_mem_space_disabled      =   prfch_mem_space_disabled_comp.agb;

      
      prfch_base_comp.dataa[]       = ad_IR_addr[31..20] ;
      prfch_base_comp.datab[]       = prfch_mem_base_reg[15..4];
      adr_ge_prfch_mem_base       =   prfch_base_comp.ageb;


      prfch_limit_comp.dataa[]      = ad_IR_addr[31..20] ;
      prfch_limit_comp.datab[]      = prfch_mem_limit_reg[15..4];
      adr_le_prfch_mem_limit        =   prfch_limit_comp.aleb;



      -- This node is set if the core is Primary PCI interface and 
      -- the primary master is enabled, The primary memory Space is enabled
      -- and the address is greater than memory base and less than memory limit
      -- the memory space can be disabled by setting the memroy limit 
      -- less than the memory base.
      -- This equation assumes that there are no prefetchable address space 
      
        prfch_mem_adr_vld_cascade = mem_cyc  
                        and adr_phase 
                        and mem_access_enable;
        prfch_mem_adr_vld =   ( LCELL ( not prfch_mem_spc_1_dis 
                        and prfch_adr_ge_mem_base1    
                        and prfch_adr_le_mem_limit1
                        )
                  OR  LCELL ( not prfch_mem_spc_2_dis 
                        and prfch_adr_ge_mem_base2    
                        and prfch_adr_le_mem_limit2
                        )
                  OR  LCELL ( not prfch_mem_spc_3_dis 
                        and prfch_adr_ge_mem_base3    
                        and prfch_adr_le_mem_limit3
                        )
                  OR  ( not prfch_mem_space_disabled 
                      and adr_ge_prfch_mem_base
                      and adr_le_prfch_mem_limit
                    )
                  )
                  and prfch_mem_adr_vld_cascade;

      
                  

    END GENERATE;

  ELSE GENERATE
  
    mem_space_disabled.clk  = clk;
    mem_space_disabled.clrn = rstn;
    
--    IF ( mem_base_in[15..4] > mem_limit_in[15..4]) Then
--      mem_space_disabled  = VCC;
--    ELSE
--      mem_space_disabled  = GND;
--    END IF;
    
    mem_space_disabled_comp.dataa[] = mem_base_in[15..4];
    mem_space_disabled_comp.datab[] = mem_limit_in[15..4];
    mem_space_disabled.d      = mem_space_disabled_comp.agb;
    
--    IF ( ad_IR_addr[31..20] >= mem_base_in[15..4]) Then
--      adr_ge_mem_base     = VCC;
--    else
--      adr_ge_mem_base     = gnd;
--    end if;
    
    mem_base_comp.dataa[]   =  ad_IR_addr[31..20];
    mem_base_comp.datab[]     =  mem_base_in[15..4];
    adr_ge_mem_base       =  mem_base_comp.ageb;
    
    
--    IF (ad_IR_addr[31..20] <= mem_limit_in[15..4]) Then
--      adr_le_mem_limit      = VCC;
--    else
--      adr_le_mem_limit      = GND;
--    end if;
    
    mem_limit_comp.dataa[]  = ad_IR_addr[31..20];
    mem_limit_comp.datab[]  =   mem_limit_in[15..4];
    adr_le_mem_limit    =   mem_limit_comp.aleb;





    IF (PREFETCHABLE_MEMORY == "YES") GENERATE
    
      prfch_mem_space_disabled.clk    = clk;
      prfch_mem_space_disabled.clrn   = rstn;

--      IF (prfch_mem_base_in[15..4] < prfch_mem_limit_in[15..4]) Then
--        prfch_mem_space_disabled  = GND;
--      ELSE
--        prfch_mem_space_disabled  = VCC;
--      END IF;
      
      prfch_mem_space_disabled_comp.dataa[] = prfch_mem_base_in[15..4] ;
      prfch_mem_space_disabled_comp.datab[] = prfch_mem_limit_in[15..4];
      prfch_mem_space_disabled      =   prfch_mem_space_disabled_comp.alb;

      
--      IF ( ad_IR_addr[31..20] >= prfch_mem_base_in[15..4]) Then
--        adr_ge_prfch_mem_base     = VCC;
--      else
--        adr_ge_prfch_mem_base     = gnd;
--      end if;
    
      prfch_base_comp.dataa[]       = ad_IR_addr[31..20] ;
      prfch_base_comp.datab[]       = prfch_mem_base_in[15..4];
      adr_ge_prfch_mem_base       =   prfch_base_comp.ageb;
      
      
--      IF (ad_IR_addr[31..20] <= prfch_mem_limit_in[15..4]) Then
--        adr_le_prfch_mem_limit    = VCC;
--      else
--        adr_le_prfch_mem_limit    = GND;
--      end if;
      
      prfch_limit_comp.dataa[]      = ad_IR_addr[31..20] ;
      prfch_limit_comp.datab[]      = prfch_mem_limit_in[15..4];
      adr_le_prfch_mem_limit        =   prfch_limit_comp.aleb;

      
      
    END GENERATE; 
    
    -- This node is set if the core is secondary PCI interface and 
    -- the primary master is enabled, The primary memory Space is enabled
    -- and the address is either larger than the memory limit or less than
    -- the memory base.  Additionally if the memory space is disabled
    -- by setting the memory limit smaller than the memory base, all memory
    -- transactions are accepted
    IF (PREFETCHABLE_MEMORY == "YES") GENERATE

      mem_adr_disabled_lc[0]  =   LCELL(  mem_space_disabled 
                      AND prfch_mem_space_disabled
                      AND mem_spc_1_dis
                      AND mem_adr_disabled_lc[1]
                      );
                      
      mem_adr_disabled_lc[1]  =   LCELL(  mem_spc_2_dis
                      AND mem_spc_3_dis
                      AND prfch_mem_spc_1_dis
                      AND prfch_mem_spc_2_dis
                      AND prfch_mem_spc_3_dis
                      );
                      
      mem_adr_vld_lc[0]   =  LCELL  (   NOT (adr_ge_mem_base AND adr_le_mem_limit)
                        AND NOT (adr_ge_prfch_mem_base AND adr_le_prfch_mem_limit)
                        AND mem_adr_vld_lc[1]
                        AND mem_adr_vld_lc[2]
                        AND mem_adr_vld_lc[3]
                        );
      mem_adr_vld_lc[1]   = NOT (adr_ge_mem_base1 AND adr_le_mem_limit1)
                  AND NOT (adr_ge_mem_base2 AND adr_le_mem_limit2);
      
      mem_adr_vld_lc[2]   =   NOT (adr_ge_mem_base3 AND adr_le_mem_limit3)
                  AND NOT (prfch_adr_ge_mem_base1 AND prfch_adr_le_mem_limit1);
      
      mem_adr_vld_lc[3]   = NOT (prfch_adr_ge_mem_base2 AND prfch_adr_le_mem_limit2)
                  AND NOT (prfch_adr_ge_mem_base3 AND prfch_adr_le_mem_limit3);
    
    --  mem_adr_vld       =   (cmd_in[2] and adr_phase and mem_cyc) 
    --              AND ( (   NOT (adr_ge_mem_base AND adr_le_mem_limit)
    --                  AND NOT (adr_ge_prfch_mem_base AND adr_le_prfch_mem_limit)
    --                  AND NOT (adr_ge_mem_base1 AND adr_le_mem_limit1)
    --                  AND NOT (adr_ge_mem_base2 AND adr_le_mem_limit2)
    --                  AND NOT (adr_ge_mem_base3 AND adr_le_mem_limit3)
    --                  AND NOT (prfch_adr_ge_mem_base1 AND prfch_adr_le_mem_limit1)
    --                  AND NOT (prfch_adr_ge_mem_base2 AND prfch_adr_le_mem_limit2)
    --                  AND NOT (prfch_adr_ge_mem_base3 AND prfch_adr_le_mem_limit3)
    --                  )
    --                OR  ( mem_space_disabled 
    --                  AND prfch_mem_space_disabled
    --                  AND mem_spc_1_dis
    --                  AND mem_spc_2_dis
    --                  AND mem_spc_3_dis
    --                  AND prfch_mem_spc_1_dis
    --                  AND prfch_mem_spc_2_dis
    --                  AND prfch_mem_spc_3_dis)
    --                );

        mem_adr_vld_cascade   = adr_phase and mem_cyc;
        mem_adr_vld       =   LCELL ( (cmd_in[2] and mem_adr_vld_cascade) 
                        AND     ( mem_adr_vld_lc[0]
                              OR  mem_adr_disabled_lc[0]
                              )
                        );
      
      -- The prfch_mem_adr_vld is being set to GND because the  mem_adr_vld already covers
      -- the logic.
      prfch_mem_adr_vld     = GND;
                  
    ELSE GENERATE
      mem_adr_vld       =   (cmd_in[2] and adr_phase and mem_cyc) 
                  AND ( (   NOT (adr_ge_mem_base AND adr_le_mem_limit)
                      AND NOT (adr_ge_mem_base1 AND adr_le_mem_limit1)
                      AND NOT (adr_ge_mem_base2 AND adr_le_mem_limit2)
                      AND NOT (adr_ge_mem_base3 AND adr_le_mem_limit3)
                      )
                    OR  ( mem_space_disabled 
                      AND mem_spc_1_dis
                      AND mem_spc_2_dis
                      AND mem_spc_3_dis)
                    );
      
    END GENERATE;   

  END GENERATE;

  IF (PRIMARY_INTERFACE == "YES") GENERATE    --PRM
  
    IF (IO_ADDR_32BIT == "NO") GENERATE   -- IO 32 NO
      io_space_disabled.clk = clk;
      io_space_disabled.clrn  = rstn;
      
      io_addr_16bit     = ad_ir_addr[31..16] == H"0000";

--      IF ((io_base_reg[7..4] > io_limit_reg[7..4])) Then
--        io_space_disabled = VCC;
--      ELSE
--        io_space_disabled = GND;
--      END IF;

      io_space_disabled_comp.dataa[] =  io_base_reg[7..4];
      io_space_disabled_comp.datab[] =  io_limit_reg[7..4];
      io_space_disabled.d        =  io_space_disabled_comp.agb;

  
--      IF ( ad_IR_addr[15..12] >= io_base_reg[7..4]) Then
--        adr_ge_io_base      = VCC;
--      ELSE
--        adr_ge_io_base      = gnd;
--      END IF;
    
      io_base_comp.dataa[]  = ad_IR_addr[15..12];
      io_base_comp.datab[]  = io_base_reg[7..4];
      adr_ge_io_base      = io_base_comp.ageb;

--      IF (ad_IR_addr[15..12] <= io_limit_reg[7..4]) Then
--        adr_le_io_limit   = VCC;
--      ELSE
--        adr_le_io_limit   = GND;
--      END IF;

      io_limit_comp.dataa[] = ad_IR_addr[15..12];
      io_limit_comp.datab[] = io_limit_reg[7..4];
      adr_le_io_limit     = io_limit_comp.aleb;

      -- This node is set if the core is Primary PCI interface and 
      -- the primary master is enabled, The primary memory Space is enabled
      -- and the address is greater than memory base and less than memory limit
      -- the memory space can be disabled by setting the memroy limit 
      -- less than the memory base.
      -- This equation assumes that there are no prefetchable address space 
        io_adr_vld_cascade  = adr_le_io_limit 
                      and adr_phase 
                      and io_access_enable
                      and io_addr_16bit;
        io_adr_vld        =   (not io_space_disabled 
                      and adr_ge_io_base
                      and io_cyc
                      AND io_adr_vld_cascade
                    );
      
    ELSE GENERATE --IO 32 YES
      io_space_disabled.clk = clk;
      io_space_disabled.clrn  = rstn;
    --  IF ((io_base_up_reg[15..0],io_base_reg[7..4]) < (io_limit_up_reg[15..0],io_limit_reg[7..4])) Then
    --    io_space_disabled = GND; -- IO space is not disabled
    --  ELSE
    --    io_space_disabled = VCC; -- IO space is disabled
    --  END IF;
    
      io_space_disabled_comp.dataa[] =  (io_base_up_reg[15..0],io_base_reg[7..4]);
      io_space_disabled_comp.datab[] =  (io_limit_up_reg[15..0],io_limit_reg[7..4]);
      io_space_disabled.d        = io_space_disabled_comp.agb;
  
    --  IF ( ad_IR_addr[31..12] >= (io_base_up_reg[15..0],io_base_reg[7..4])) Then
    --    adr_ge_io_base      = VCC;
    --  ELSE
    --    adr_ge_io_base      = gnd;
    --  END IF;
      io_base_comp.dataa[]  = ad_IR_addr[31..12];
      io_base_comp.datab[]  = (io_base_up_reg[15..0],io_base_reg[7..4]);
      adr_ge_io_base      = io_base_comp.ageb;

    
    --  IF (ad_IR_addr[31..12] <= (io_limit_up_reg[15..0],io_limit_reg[7..4])) Then
    --    adr_le_io_limit   = VCC;
    --  ELSE
    --    adr_le_io_limit   = GND;
    --  END IF;


      io_limit_comp.dataa[] = ad_IR_addr[31..12];
      io_limit_comp.datab[] = (io_limit_up_reg[15..0],io_limit_reg[7..4]);
      adr_le_io_limit     = io_limit_comp.aleb;


      -- This node is set if the core is Primary PCI interface and 
      -- the primary master is enabled, The primary memory Space is enabled
      -- and the address is greater than memory base and less than memory limit
      -- the memory space can be disabled by setting the memroy limit 
      -- less than the memory base.
      -- This equation assumes that there are no prefetchable address space 
        io_adr_vld_cascade  =  io_cyc 
                      and adr_le_io_limit 
                      and adr_phase 
                      and io_access_enable;
                      
        io_adr_vld        =   (not io_space_disabled 
                      and adr_ge_io_base
                      AND io_adr_vld_cascade);  
                    
    END GENERATE; -- IO_ADDR_32BIT                  
    
  ELSE GENERATE   -- SEC
  
  
    IF (IO_ADDR_32BIT == "NO") GENERATE   -- IO 32 NO   
      io_space_disabled.clk = clk;
      io_space_disabled.clrn  = rstn;
      
      io_addr_16bit     = ad_ir_addr[31..16] == H"0000";
      
--      IF ((io_base_in[7..4] > io_limit_in[7..4])) Then
--        io_space_disabled = VCC;
--      ELSE
--        io_space_disabled = GND;
--      END IF;
      
      io_space_disabled_comp.dataa[] =  io_base_in[7..4];
      io_space_disabled_comp.datab[] =  io_limit_in[7..4];
      io_space_disabled.d        =  io_space_disabled_comp.agb;
      
--      IF ( ad_IR_addr[15..12] < (io_base_in[7..4])) Then
--        adr_l_io_base     = VCC;
--      ELSE
--        adr_l_io_base     = gnd;
--      END IF;
    
      io_base_comp.dataa[]  = ad_IR_addr[15..12];
      io_base_comp.datab[]  = io_base_in[7..4];
      adr_l_io_base     = io_base_comp.alb;
      
--      IF (ad_IR_addr[15..12] > (io_limit_in[7..4])) Then
--        adr_g_io_limit      = VCC;
--      ELSE
--        adr_g_io_limit      = GND;
--      END IF;
    
      io_limit_comp.dataa[] = ad_IR_addr[15..12];
      io_limit_comp.datab[] = io_limit_in[7..4];
      adr_g_io_limit      = io_limit_comp.agb;

  
      -- This node is set if the core is secondary PCI interface and 
      -- the primary master is enabled, The primary memory Space is enabled
      -- and the address is either larger than the memory limit or less than
      -- the memory base.  Additionally if the memory space is disabled 
      -- by setting the memory limit smaller than the memory base, all memory
      -- transactions are accepted
        io_adr_vld_cascade  = io_addr_16bit and 
                    (io_space_disabled or   adr_l_io_base or  adr_g_io_limit);
        io_adr_vld        =    LCELL( cmd_in[2] and adr_phase and io_cyc and  
                          io_adr_vld_cascade
                        );
      
    ELSE GENERATE           -- IO 32 YES
      io_space_disabled.clk = clk;
      io_space_disabled.clrn  = rstn;
    --  IF ((io_base_up_in[15..0],io_base_in[7..4]) < (io_limit_up_in[15..0], io_limit_in[7..4])) Then
    --    io_space_disabled = GND;
    --  ELSE
    --    io_space_disabled = VCC;
    --  END IF;

      io_space_disabled_comp.dataa[] =  (io_base_up_in[15..0],io_base_in[7..4]);
      io_space_disabled_comp.datab[] =  (io_limit_up_in[15..0], io_limit_in[7..4]);
      io_space_disabled.d     = io_space_disabled_comp.agb;

      
      
    --  IF ( ad_IR_addr[31..12] < (io_base_up_in[15..0],io_base_in[7..4])) Then
    --    adr_l_io_base     = VCC;
    --  ELSE
    --    adr_l_io_base     = gnd;
    --  END IF;
    
      
      io_base_comp.dataa[]  = ad_IR_addr[31..12];
      io_base_comp.datab[]  = (io_base_up_in[15..0],io_base_in[7..4]);
      adr_l_io_base     = io_base_comp.alb;

    --  IF (ad_IR_addr[31..12] > (io_limit_up_in[15..0],io_limit_in[7..4])) Then
    --    adr_g_io_limit      = VCC;
    --  ELSE
    --    adr_g_io_limit      = GND;
    --  END IF;

      io_limit_comp.dataa[] = ad_IR_addr[31..12];
      io_limit_comp.datab[] = (io_limit_up_in[15..0],io_limit_in[7..4]);
      adr_g_io_limit      = io_limit_comp.agb;

    
      -- This node is set if the core is secondary PCI interface and 
      -- the primary master is enabled, The primary memory Space is enabled
      -- and the address is either larger than the memory limit or less than
      -- the memory base.  Additionally if the memory space is disabled 
      -- by setting the memory limit smaller than the memory base, all memory
      -- transactions are accepted
        io_adr_vld_cascade    = io_space_disabled or adr_l_io_base or  adr_g_io_limit;
        io_adr_vld        =    LCELL( cmd_in[2] and adr_phase and io_cyc and  
                              io_adr_vld_cascade
                       );
      
    END GENERATE; -- IO_ADDR_32BIT                        
                              

  END GENERATE; -- PRIMARY_INTERFACE


-- Internal Signals for cfg_dat_out

  -- Configuration Space Output
  cfg_dat_out_a[15..0]    = cmd_out[15..0]      ; -- Command Register Data
  cfg_dat_out_a[31..16]   = stat_out[15..0]     ; -- Status Register Data
  cfg_dat_out_a[39..32]   =   cache_dat_out[7..0]   ; -- Cache Line Size Register Data
  cfg_dat_out_a[47..40]   = prim_lat_out[7..0]    ; -- Latency Timer Register Data
  cfg_dat_out_a[79..48]   =   bar_0[31..0]      ; -- BAR0
  cfg_dat_out_a[111..80]    =   bar_1[31..0]      ;   -- BAR1
  cfg_dat_out_a[119..112]   = prim_bus_num_out[7..0]  ; -- Primary Bus Number Register Output
  cfg_dat_out_a[127..120]   = sec_bus_num_out[7..0] ; -- Secondary Bus Number Register Output
  cfg_dat_out_a[135..128]   = sub_bus_num_out[7..0] ; -- Subordiante Bus Number Register Output
  cfg_dat_out_a[143..136]   = sec_lat_out[7..0]   ; -- Secondary Latency Timer Register Output  
  cfg_dat_out_a[151..144]   =   io_base_out[7..0]   ;   -- I/O Base Register Output
  cfg_dat_out_a[159..152]   =   io_limit_out[7..0]    ; -- I/O Limit Register Output
  cfg_dat_out_a[175..160]   = sec_stat_out[15..0]   ; -- Secondary Status Register Data 
  cfg_dat_out_a[191..176]   = mem_base_out[15..0]   ; -- Memory Base Register Output
  cfg_dat_out_a[207..192]   = mem_limit_out[15..0]  ; -- Memory Limit Register Output
  cfg_dat_out_b[15..0]    =   prfch_mem_base_out[15..0];
  cfg_dat_out_b[31..16]   =   prfch_mem_limit_out[15..0];
  cfg_dat_out_b[63..32]   =   prfch_mem_base_up_out[31..0];
  cfg_dat_out_b[95..64]   =   prfch_mem_limit_up_out[31..0];
  cfg_dat_out_b[111..96]    = io_base_up_out[15..0] ; -- Bridge Control Register Data
  cfg_dat_out_b[127..112]   = io_limit_up_out[15..0]  ; -- Bridge Control Register Data 
  cfg_dat_out_b[159..128]   =   exp_rom_out[31..0];
  cfg_dat_out_b[175..160]   = brdg_ctrl_out[15..0]  ; -- Bridge Control Register Data
  cfg_dat_out_b[183..176]   = cap_ptr_out[7..0];
  
  
    
           
     cfg_dat_out_c[15..0]     =      mem_base_1_out[15..0]         ;
     cfg_dat_out_c[31..16]    =      mem_limit_1_out[15..0]         ;       
     cfg_dat_out_c[47..32]    =      prfch_mem_base_1_out[15..0]   ;       
     cfg_dat_out_c[63..48]    =      prfch_mem_limit_1_out[15..0]  ;       
     cfg_dat_out_c[79..64]      =      mem_base_2_out[15..0]          ;   
     cfg_dat_out_c[95..80]      =      mem_limit_2_out[15..0]         ;   
     cfg_dat_out_c[111..96]     =      prfch_mem_base_2_out[15..0]   ;     
     cfg_dat_out_c[127..112]    =      prfch_mem_limit_2_out[15..0]  ;     
     cfg_dat_out_c[143..128]    =      mem_base_3_out[15..0]          ;     
     cfg_dat_out_c[159..144]    =      mem_limit_3_out[15..0]    ;      
     cfg_dat_out_c[175..160]    =      prfch_mem_base_3_out[15..0]   ;      
     cfg_dat_out_c[191..176]      =      prfch_mem_limit_3_out[15..0]  ; 
                                  
                                  
                                  
-------------- Expansion ROM Section ------------------------------------------------
                                    
IF (EXP_ROM_ENA == 1) GENERATE      
  exp_rom_selR      = cfg_adr_selR14;
  no_op[3..0]       = no_op[3..0] or exp_rom_en[3..0];

  IF (CEIL(2^EXP_ROM_READ_ONLY_BITS) >   16777216) GENERATE   -- If value requested is larger than 16MBytes
        ASSERT REPORT "ERROR:  Expansion ROM BAR is instantiated with [% MBytes] address space larger than allowed 16MBytes." 
        CEIL(2^EXP_ROM_READ_ONLY_BITS) DIV 1048576
        SEVERITY ERROR;
  END GENERATE;


  IF (CEIL(2^EXP_ROM_READ_ONLY_BITS) >=  1048576 ) GENERATE
        ASSERT REPORT "EXP ROM BAR Settings: Number of Address Bits Decoded = %, Size = % MBytes"
        32-EXP_ROM_READ_ONLY_BITS, CEIL(2^EXP_ROM_READ_ONLY_BITS) DIV 1048576 
        SEVERITY INFO;
  END GENERATE;

  IF((CEIL(2^EXP_ROM_READ_ONLY_BITS) >= 1024)  and (CEIL(2^EXP_ROM_READ_ONLY_BITS) < 1048576)) GENERATE
    ASSERT REPORT "EXP ROM BAR Settings: Number of Address Bits Decoded = %, Size = % KBytes"
      32-EXP_ROM_READ_ONLY_BITS, CEIL(2^EXP_ROM_READ_ONLY_BITS) DIV 1024
    SEVERITY INFO;
  END GENERATE;



  --IF (HARDWIRE_EXP_ROM_ENA == H"0") GENERATE ( not supported in P2P)
  
    IF (LOCAL_CONFIG_ENA == "NO") GENERATE
  
      exp_rom_en[3..0]    = exp_rom_selR and cfg_dat_vld and not cben_IR[3..0];

    ELSE  GENERATE
  
      exp_rom_en[3..0]    = exp_rom_selR and lcfg_dat_vld and not lcfg_ben[3..0];

    END GENERATE;
  
    -- Set BAR#bar# R/W Registers Controls

    
  
  
    IF (PRIMARY_INTERFACE == "YES") GENERATE
        
          exp_rom_reg[].clk = clk ;
        exp_rom_reg[].clrn  = rstN;
      exp_rom_reg[].d     = ad_IR[31..EXP_ROM_READ_ONLY_BITS];
      
      exp_rom_dec_ena.clk   = clk;
        exp_rom_dec_ena.clrn  = rstn;
        exp_rom_dec_ena.ena   = exp_rom_en[0];
            exp_rom_dec_ena.d   = ad_IR[0];
  
      
      IF (EXP_ROM_READ_ONLY_BITS < 8) GENERATE

      exp_rom_reg[31..24].ena           = exp_rom_en[3];
      exp_rom_reg[23..16].ena           = exp_rom_en[2];
      exp_rom_reg[15..8].ena            = exp_rom_en[1];
      exp_rom_reg[7..EXP_ROM_READ_ONLY_BITS].ena  = exp_rom_en[0];  

      ELSE GENERATE
      IF (EXP_ROM_READ_ONLY_BITS < 16) GENERATE
        exp_rom_reg[31..24].ena           = exp_rom_en[3];
        exp_rom_reg[23..16].ena           = exp_rom_en[2];
        exp_rom_reg[15..EXP_ROM_READ_ONLY_BITS].ena = exp_rom_en[1];
    
      ELSE GENERATE 
    
        IF (EXP_ROM_READ_ONLY_BITS < 24) GENERATE
    
          exp_rom_reg[31..24].ena           = exp_rom_en[3];
          exp_rom_reg[23..EXP_ROM_READ_ONLY_BITS].ena = exp_rom_en[2];
    
        ELSE GENERATE
    
          exp_rom_reg[31..EXP_ROM_READ_ONLY_BITS].ena = exp_rom_en[3];
    
        END GENERATE;

      END GENERATE;

    END GENERATE;
    
  ELSE  GENERATE   -- secondary
  
      exp_rom_dec_ena = exp_rom_in[0];
           exp_rom_reg[]    = exp_rom_in[31..EXP_ROM_READ_ONLY_BITS] ;
  END GENERATE;

    exp_rom_ro_bits[] = gnd;
  
    exp_rom_dat[] = (exp_rom_reg[],exp_rom_ro_bits[],exp_rom_dec_ena);

    -- Connect The Ports of BAR#bar# Address Comparator

    exp_rom_comp.dataa[]  = exp_rom_reg[] ;
    exp_rom_comp.datab[]  = ad_IR_addr[31 .. EXP_ROM_READ_ONLY_BITS]; -- Only Upper Most Address Bits are Decoded
    exp_rom_cyc_vld     = (exp_rom_dec_ena AND mem_cyc  and mem_access_enable);

    exp_rom_hit       = LCELL(exp_rom_comp.aeb and adr_phase and exp_rom_cyc_vld );

    -- Set Address Compare Hit Register Controls

    exp_rom_hitR.clk    = clk;
    exp_rom_hitR.clrn   = rstn;
    exp_rom_hitR.s      = exp_rom_hit ;
    exp_rom_hitR.r      = bar_hit_rst;
    
    exp_rom_bar_hit     = exp_rom_hitR;

    exp_rom_access      = exp_rom_hit ;
    
    
  
% ELSE GENERATE   -- Hardwired EXP ROM not supported in P2P
  
  
  
      exp_rom_en[3..0]    = exp_rom_selR and cfg_dat_vld and not cben_IR[3..0];

      
    -- Set Controls
    no_op[31..0]  = exp_rom_temp_dat[];
    
    exp_rom_temp_dat[31..0]   = HARDWIRE_EXP_ROM;
    exp_rom_reg[31.. EXP_ROM_READ_ONLY_BITS]  = exp_rom_temp_dat[31.. EXP_ROM_READ_ONLY_BITS];

    
    -- Expansion ROM Decode Enable (Bit 0)
    -- The reason a not is used to ensure that the exp_rom_dec_ena bit is set to high at power up.
    exp_rom_dec_ena_not.clk   = clk;
    exp_rom_dec_ena_not.clrn  = rstn;
    exp_rom_dec_ena_not.ena   = exp_rom_en[0];
    
    
  
    exp_rom_dec_ena_not.d   = not ad_IR[0];

        
    exp_rom_dec_ena       = not exp_rom_dec_ena_not;
    

    exp_rom_ro_bits[] = gnd;
  
    exp_rom_dat[] = (exp_rom_reg[],exp_rom_ro_bits[],exp_rom_dec_ena);

    -- Connect The Ports of BAR#bar# Address Comparator

    exp_rom_comp.dataa[]  = exp_rom_reg[] ;
    exp_rom_comp.datab[]  = ad_IR_addr[31 .. EXP_ROM_READ_ONLY_BITS]; -- Only Upper Most Address Bits are Decoded

    exp_rom_comp.dataa[]  = exp_rom_reg[] ;
    exp_rom_comp.datab[]  = ad_IR_addr[31 .. EXP_ROM_READ_ONLY_BITS]; -- Only Upper Most Address Bits are Decoded
    exp_rom_cyc_vld     = (exp_rom_dec_ena AND mem_cyc  );

    exp_rom_hit       = LCELL(exp_rom_comp.aeb and adr_phase and exp_rom_cyc_vld );
  
    -- Set Address Compare Hit Register Controls

    exp_rom_hitR.clk    = clk;
    exp_rom_hitR.clrn   = rstn;
    exp_rom_hitR.s      = exp_rom_hit ;
    exp_rom_hitR.r      = bar_hit_rst;
    
    exp_rom_bar_hit     = exp_rom_hitR;
    
    exp_rom_access      = exp_rom_hit;
    
    
  
  END GENERATE; %
  
ELSE GENERATE  -- EXP DISABLE
    exp_rom_selR      = GND;
  exp_rom_access  = GND;
  exp_rom_bar_hit = GND;
  exp_rom_dat[]   = gnd;

END GENERATE; 

--
  END GENERATE; -- END OF P2P_BRIDGE == "YES"

--==== END OF P2P_BRIDGE == "YES" =================================================================
END;

