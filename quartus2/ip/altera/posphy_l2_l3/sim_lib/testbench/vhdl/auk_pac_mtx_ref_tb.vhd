-------------------------------------------------------------------------
-------------------------------------------------------------------------
--
-- Title        : Reference design for POS-PHY Level 3 Link Source (Tx) top level architecture
-- Project      : Pos-Phy
--
-- Description	: Reference design for Altera POS-PHY Level 3 Core
--
-- Copyright 1999, 2000 (c) Altera Corporation
-- All rights reserved
--
-------------------------------------------------------------------------
-------------------------------------------------------------------------


library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use std.textio.all;
-- library auk_pac_lib;

-------------------------------------------------------------------------
-- Main entity, the reference design testbench
-------------------------------------------------------------------------
entity auk_pac_mtx_ref is
end auk_pac_mtx_ref;

-------------------------------------------------------------------------
-- RTL architecture of the reference design testbench
-------------------------------------------------------------------------
architecture rtl of auk_pac_mtx_ref is

    constant thold_ns       : time    := 1 ns;
    constant DPAV_WIDTH     : natural := 1;  -- direct status mode
    constant ADDR_WIDTH     : natural := 0;  -- single PHY
    constant DATA_WIDTH     : natural := 32; -- data bus is 32 bits wide
    constant MOD_WIDTH      : natural := 2;  -- two bits of mod for 4 bytes of data
    constant CUSTOM_WIDTH   : natural := 32; -- custom width, not used?
    constant PARITY_MODE    : std_logic := '1'; -- odd parity

    ---------------------------------------------------------------------
    -- Declare a component, which was automatically generated by megawizard
    ---------------------------------------------------------------------
    component auk_pac_mtx_pl3_link
	    PORT
	    (
		    a_tfclk		: IN STD_LOGIC ;
		    a_treset_n		: IN STD_LOGIC ;
		    a_dtpa		: IN STD_LOGIC_VECTOR (0 DOWNTO 0);
		    a_tenb		: OUT STD_LOGIC ;
		    a_tdat		: OUT STD_LOGIC_VECTOR (31 DOWNTO 0);
		    a_tsop		: OUT STD_LOGIC ;
		    a_teop		: OUT STD_LOGIC ;
		    a_terr		: OUT STD_LOGIC ;
		    a_tprty		: OUT STD_LOGIC ;
		    a_tmod		: OUT STD_LOGIC_VECTOR (1 DOWNTO 0);

		    b_clk		: IN STD_LOGIC ;
		    b_reset_n		: IN STD_LOGIC ;
		    b_ena		: IN STD_LOGIC ;
		    b_dat		: IN STD_LOGIC_VECTOR (31 DOWNTO 0);
		    b_sop		: IN STD_LOGIC ;
		    b_eop		: IN STD_LOGIC ;
		    b_err		: IN STD_LOGIC ;
		    b_par		: IN STD_LOGIC ;
		    b_mty		: IN STD_LOGIC_VECTOR (1 DOWNTO 0);
		    b_dav		: OUT STD_LOGIC 
	    );
    end component;

    ---------------------------------------------------------------------
    -- A function to calculate odd parity
    ---------------------------------------------------------------------
    function generate_parity
    (
        data : in std_logic_vector(DATA_WIDTH-1 downto 0)
    ) return std_logic is
        variable result  : std_logic := '1';
    begin
        for i in 0 to DATA_WIDTH-1 loop
            result := result xor data(i);
        end loop;
        return result;
    end;

    ---------------------------------------------------------------------
    -- A function to create an incrementing data pattern
    ---------------------------------------------------------------------
    function generate_incrementing_data
    (
        data : in std_logic_vector(7 downto 0)
    ) return std_logic_vector is
        variable result : std_logic_vector(7 downto 0);
    begin
        for i in 0 to 1 loop
            result( (i*4)+3 downto (i*4)+0 ) := std_logic_vector( unsigned( data( (i*4)+3 downto (i*4)+0 ) ) +1);
        end loop;
        return result;
    end;


    -- signal declarations for the POS-PHY side
    signal clk_inA               : std_logic;
    signal reset_inA             : std_logic := '1';
    signal dpav_inA              : std_logic_vector(0 downto 0) := "0";
    signal wr_outA               : std_logic;
    signal sx_outA               : std_logic;
    signal data_outA             : std_logic_vector(DATA_WIDTH-1 downto 0);
    signal sop_outA              : std_logic;
    signal eop_outA              : std_logic;
    signal err_outA              : std_logic;
    signal prty_outA             : std_logic;
    signal mod_outA              : std_logic_vector(1 downto 0); -- !!!!! SHould be AUTO

    -- signal declarations for the Atlantic interface side
    signal dav_outB              : std_logic;
    signal wr_inB                : std_logic := '0';
    signal data_inB              : std_logic_vector(DATA_WIDTH-1 downto 0);
    signal sop_inB               : std_logic := '0';
    signal eop_inB               : std_logic := '0';
    signal err_inB               : std_logic := '0';
    signal prty_inB              : std_logic := '0';
    signal mod_inB               : std_logic_vector(1 downto 0);
    signal clk_inB               : std_logic := '0';
    signal reset_inB             : std_logic := '1';

    -- general purpose signals
--    file   f                     : text is out "STD_OUTPUT";

-------------------------------------------------------------------------
begin -- rtl architecture


    ---------------------------------------------------------------------
    -- instatiate the automatically generated entity
    ---------------------------------------------------------------------
    mtx: auk_pac_mtx_pl3_link
        port map
        (
            a_dtpa      => dpav_inA,
            a_tenb      => wr_outA,
            a_tdat      => data_outA,
            a_tsop      => sop_outA,
            a_teop      => eop_outA,
            a_terr      => err_outA,
            a_tprty     => prty_outA,
            a_tmod      => mod_outA,
            a_tfclk     => clk_inA,
            a_treset_n  => reset_inA,

            b_dav       => dav_outB,
            b_ena       => wr_inB,
            b_dat       => data_inB,
            b_sop       => sop_inB,
            b_eop       => eop_inB,
            b_err       => err_inB,
            b_par       => prty_inB,
            b_mty       => mod_inB,
            b_clk       => clk_inB,
            b_reset_n   => reset_inB
        );


    -- 100 MHz clock, wait for 5 us
    pos_phy_clk_gen: process
    begin
        while now <= 50000 ns loop
            clk_inA <= '0';
            wait for 5 ns;
            clk_inA <= '1';
            wait for 5 ns;
        end loop;
        wait;
    end process;

    -- 100 MHz clock, wait for 5 us
    atlantic_clk_gen: process
    begin
        while now <= 50000 ns loop
            clk_inB <= '0';
            wait for 5 ns;
            clk_inB <= '1';
            wait for 5 ns;
        end loop;
        wait;
    end process;

--=======================================================================
-- Process to generate data on the input side, the Atlantic interface
--=======================================================================
    send_data_to_atlantic: process

    ---------------------------------------------------------------------
    -- Send a reset pulse to the Atlantic interface
    ---------------------------------------------------------------------
        procedure reset_pulse is
        begin
            reset_inB <= '0';
            wait until rising_edge(clk_inB);
            reset_inB <= '1';
        end;

    ---------------------------------------------------------------------
    -- A function to wait for N clock cycles
    ---------------------------------------------------------------------
        procedure delay_n_clocks ( delay : integer ) is
        begin
            for i in 1 to delay loop
                wait until rising_edge(clk_inB);
            end loop;
        end;

    ---------------------------------------------------------------------
    -- Produce a data packet for the Atlantic i/f
    --
    -- In this case, the test bench is a master source, and the
    -- core is acting as a slave sink.
    ---------------------------------------------------------------------
        procedure generate_atlantic_data_packet(
            packet_number : integer;
            packet_length    : integer) is

            variable sop : std_logic := '1';
            variable eop : std_logic := '0';
            variable err : std_logic := '0';
            variable val : std_logic := '0';
            variable par : std_logic := '0';
            variable mty : std_logic_vector(1 downto 0) := (others => '0');
            variable dat : std_logic_vector(DATA_WIDTH-1 downto 0) := (others => '0');
            variable temp_dat : std_logic_vector(7 downto 0) := (others => '0');
            variable num_cycles : integer;
            variable bytes_sent : integer := 0;

        begin
            if packet_length > 4 then
                num_cycles := (packet_length * 8)/DATA_WIDTH;
            else
                num_cycles := 1;   -- ensure that at least one cycle happens
            end if;

            -- loop until the end of the packet
            while true loop
                -- wait for slave sink to take dav_outB high
                while dav_outB = '0' loop
                    val := '0';
                    wr_inB <= val after thold_ns;
                    wait until rising_edge(clk_inB);
                end loop;

                -- take wr_inB high to indicate valid data
                val := '1';

                for i in (DATA_WIDTH/8)-1 downto 0 loop -- setup a simple pattern of incrementing data
                    if sop = '1' and i = (DATA_WIDTH/8)-1 then  -- first two bytes, set pkt no
                        dat((i*8)+7 downto (i*8)+0 ) := std_logic_vector(to_unsigned(packet_number,8));
                    else
                        dat((i*8)+7 downto (i*8)+0 ) := temp_dat; -- set data
                    end if;
                    par := generate_parity(dat);

                    temp_dat := generate_incrementing_data(temp_dat);
                end loop;

                -- if nearly finished, set eop and mod signals
                if packet_length - bytes_sent <= (DATA_WIDTH / 8) then
                    eop := '1';
                    mty := std_logic_vector(DATA_WIDTH/8 - to_unsigned(packet_length mod (DATA_WIDTH/8), 2) ); -- num of invalid bytes in cycle
                end if;

                -- drive variables onto signals
                data_inB <= dat after thold_ns;
                prty_inB <= par after thold_ns;
                sop_inb <= sop after thold_ns;
                eop_inb <= eop after thold_ns;
                mod_inB <= mty after thold_ns;
                err_inB <= err after thold_ns;
                wr_inB <= val after thold_ns;
                wait until rising_edge(clk_inB);

                -- keep track of the number of bytes sent
                bytes_sent := bytes_sent + (DATA_WIDTH/8 - to_integer(unsigned(mty)));

                -- clear sop flag
                if sop = '1' then
                    sop := '0';
                    sop_inB <= sop after thold_ns;
                end if;

                -- if this is the last cycle, exit the loop as the packet is finished
                if eop = '1' then
                    eop_inB <= '0' after thold_ns;
                    wr_inB <= '0' after thold_ns;
                    mod_inB <= (others => '0') after thold_ns;
                    exit;
                end if;

            end loop;
        end; -- generate_atlantic_data_packet

    begin
        --reset Atlantic interface
        reset_pulse;
        delay_n_clocks(6);

        generate_atlantic_data_packet(0, 64);
        delay_n_clocks(4);
        generate_atlantic_data_packet(1, 63);
        generate_atlantic_data_packet(2, 61);
        delay_n_clocks(2);
        generate_atlantic_data_packet(3, 3);
        delay_n_clocks(2);
        generate_atlantic_data_packet(4, 128);
        generate_atlantic_data_packet(5, 256);
        wait;
    end process;

--=======================================================================
-- Process to listen for data on the output side, the POS-PHY interface
--=======================================================================
    listen_for_data_on_posphy: process

        variable l  : line;
        variable simulation_passed : boolean := true;

    ---------------------------------------------------------------------
    -- Send a reset pulse to the POS-PHY interface
    ---------------------------------------------------------------------
        procedure reset_pulse is
        begin
            reset_inA <= '0';
            wait until rising_edge(clk_inA);
            reset_inA <= '1';
        end;

    ---------------------------------------------------------------------
    -- A function to wait for N clock cycles
    ---------------------------------------------------------------------
        procedure delay_n_clocks ( delay : integer ) is
        begin
            for i in 1 to delay loop
                wait until rising_edge(clk_inA);
            end loop;
        end;

    --------------------------------------------------------------------
    -- Listen for a data packet on the POS-PHY i/f
    --
    -- In this case, the test bench is a slave sink, and the
    -- core is acting as a master source.
    ---------------------------------------------------------------------
        procedure receive_posphy_data_packet(
            packet_number : integer;
            packet_length : integer) is

            variable recvd_dat : std_logic_vector(7 downto 0) := (others => '0');
            variable temp_dat  : std_logic_vector(7 downto 0) := (others => '0');
            variable bytes_received : integer := 0;
            variable num_errs  : integer := 0;

        begin
            -- tell core that the testbench can receive data
            dpav_inA(0) <= '1' after thold_ns;

            -- wait for core to acknowledge
            while wr_outA = '1' loop
                wait until rising_edge(clk_inA);
            end loop;

            -- check for presence of sop
            while bytes_received < packet_length loop

                if wr_outA = '0' then
                    if (sop_outA /= '1') then
                        assert false report "receive_posphy_data_packet(): missing sop signal!";
                        num_errs := num_errs + 1;
                    end if;

                    if sop_outA = '1' then
                        -- check that packet number is the first two bytes of data
                        temp_dat := std_logic_vector(to_unsigned(packet_number,8));
                        recvd_dat := data_outA(DATA_WIDTH-1 downto DATA_WIDTH-8);
                        bytes_received := bytes_received + 1;

                        if (recvd_dat /= temp_dat) then
                            assert false report "receive_posphy_data_packet(): invalid packet number!";
                            num_errs := num_errs + 1;
                        end if;

                        -- check parity
                        if ((generate_parity(data_outA) xor prty_outA) = PARITY_MODE) then
                            assert false report "receive_posphy_data_packet(): parity error!";
                            num_errs := num_errs + 1;
                        end if;

                       exit; -- have checked both parity and packet number
                    end if;
                end if;

            end loop;

            -- check the rest of the packet
            while bytes_received < packet_length loop

                if wr_outA = '0' then

                    for i in (DATA_WIDTH/8)-1 downto 0 loop -- for each byte
                        -- wait if the core indicates it can't receive any more data
                        while wr_outA = '1' loop
                            wait until rising_edge(clk_inA);
                        end loop;

                        if i = (DATA_WIDTH/8)-1 and sop_outA = '1' then -- for each byte in the data cycle
                            temp_dat := (others => '0');  -- reset it back to start of incrementing data
                            null; -- ignore the first byte, the packet number
                        else
                            -- check data
                            temp_dat := generate_incrementing_data(temp_dat);
                            recvd_dat := data_outA((i*8)+7 downto (i*8)+0);
                            bytes_received := bytes_received + 1;

                            if (recvd_dat /= temp_dat) then
                                assert false report "receive_posphy_data_packet(): invalid data received!";
                                num_errs := num_errs + 1;
                            end if;

                            -- check parity
                            if ((generate_parity(data_outA) xor prty_outA) = PARITY_MODE) then
                                assert false report "receive_posphy_data_packet(): parity error!";
                                num_errs := num_errs + 1;
                            end if;

                            -- check for eop and get out of the loop
                            if (eop_outA = '1') and (mod_outA = std_logic_vector(to_unsigned(i, 2))) then
                                exit;
                            end if;
                        end if;
                    end loop;
                end if;

                -- check for end of packet
                if eop_outA = '1' then
                    wait until rising_edge(clk_inA);
                    exit;
                end if;

                wait until rising_edge(clk_inA);
            end loop;

            -- check that the right number of bytes were received
            if (bytes_received /= packet_length) then
                assert false report "receive_posphy_data_packet(): wrong number of bytes in packet!";
                num_errs := num_errs + 1;
            end if;

            if (num_errs = 0) then
                write(l,string'("receive_posphy_data_packet(): succesfully received packet number "));
                write(l,packet_number);
                write(l,string'(", length "));
                write(l,bytes_received);
                write(l,string'(" bytes."));
--                writeline(f,l);
            else
                simulation_passed := false;
            end if;

            dpav_inA(0) <= '0' after thold_ns;

        end; -- receive_posphy_data_packet
-------------------------------------------------------------------------

    begin
        reset_pulse;
        delay_n_clocks(3); -- wait for a while for things to settle down

        receive_posphy_data_packet(0, 64);
        receive_posphy_data_packet(1, 63);
        receive_posphy_data_packet(2, 61);
        receive_posphy_data_packet(3, 3);
        receive_posphy_data_packet(4, 128);
        receive_posphy_data_packet(5, 256);

        if (simulation_passed = true ) then
            assert false report "** Simulation PASSED **." severity note;
        else
            assert false report "############# Simulation FAILED #############." severity note;
        end if;

        wait;
    end process;


end rtl;
