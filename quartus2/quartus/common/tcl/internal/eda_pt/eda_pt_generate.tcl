set pvcs_revision(eda_pt_generate) [regsub -nocase -- {\$revision:\s*(\S+)\s*\$} {$Revision: #1 $} {\1}]

# **************************************************************************
#
# File: eda_pt_generate.tcl
#
# Used by eda_pt_script.tcl
#
# Description:
#		This file defines eda_pt_generate namespace that generates PrimeTime
#		Tcl scripts. It takes in one of the files dumped by TimeQuest using
#		"write_sdc -pt":
#
#		1. <revision>.constraints.sdc
#			Contains the SDC constraints from the original user SDC file.
#			The main different between this file and the original file would
#			be that all collection will be removed and replaced with
#			variable names (defined in <revision>.collections.sdc).
#			This file contains both Standard SDC constraints and TimeQuest
#			SDC extension contraints.
#
#		Example format of the file <revision>.constraints.sdc:
#		set_multicycle_path -setup -end -from $_col40 -thru $_col41 -to $_col42 20
#
#		This file writes a Header Section, where search paths, link paths
#		and library files are defined.
#
#		This file writes a Design Entry Section, where the design and SDO
#		files are linked, entry level is defined and various PrimeTime
#		settings are made.
#
#		This file sources <revision>.collections.sdc and
#		<revision>.constraints.sdc.
#
#		This file writes output pin and bidirectional pin (if exist) loads.
#
# **************************************************************************


# --------------------------------------------------------------------------
#
namespace eval eda_pt_generate {
#
# Description:	Define the namespace and internal variables.
#
# Warning:	All defined variables are not allowed to be accessed outside
#			this namespace!!! To access them, use the defined accessors.
#
# --------------------------------------------------------------------------
	# No variable
}


# --------------------------------------------------------------------------
# --------------------------------------------------------------------------
proc eda_pt_generate::generate_script { input_tq_constraint output_pt_collection output_pt_script hdl_type is_fast } {
	# Generates PrimeTime Tcl scripts
# --------------------------------------------------------------------------
# --------------------------------------------------------------------------
	global quartus
	global pvcs_revision
	global outfile

	# SPR 214571
	#if { $hdl_type == "verilog" } {
	#	set output_pt_script ${output_pt_script}_v
	#} elseif { $hdl_type == "vhdl" } {
	#	set output_pt_script ${output_pt_script}_vhd
	#}
	#
	#if { $is_fast } {
	#	set output_pt_script ${output_pt_script}_fast.tcl
	#} else {
	#	set output_pt_script ${output_pt_script}.tcl
	#}

	# Open file to output generated PrimeTime commands
	if [catch { set outfile [open $output_pt_script w] } result] {
		msg_vdebug $result
		eda_pt_msg::post_msg "" E_CANNOT_OPEN_OUTPUT_FILE $output_pt_script
		qexit -error
	}

	set current_device "AUTO"
	if [catch { set current_device [get_global_assignment -name DEVICE] } result] {
		msg_vdebug $result
	}

	if { $current_device != "AUTO" && $current_device != "" } {
		if [catch { set current_device [get_dstr_string -part $current_device] } result] {
			set current_device "AUTO"
			msg_vdebug $result
		}
	}

	eda_pt_util::formatted_write $outfile "
		####################################################################################
		#
		# Generated by [file tail [info script]]\t$pvcs_revision(eda_pt_script)
		#              eda_pt_generate.tcl\t$pvcs_revision(eda_pt_generate)
		#              in [file dirname [info script]]/.
		#
		# Quartus:  $quartus(version)
		#
		# Project:  $quartus(project)
		# Revision: $quartus(settings)
		# Device:   $current_device
		#
		# Date: [clock format [clock seconds]]
		#
		# $quartus(copyright)
		#
		####################################################################################
	"

	eda_pt_util::formatted_write $outfile "


		##################
		# Header Section #
		##################

	"
	# Write Header Section
	eda_pt_generate::generate_header $hdl_type

	eda_pt_util::formatted_write $outfile "


		########################
		# Design Entry Section #
		########################

	"
	# Write Design Entry Section
	eda_pt_generate::generate_design_entry $hdl_type $is_fast	; # last arg is for SPR 214571

	#eda_pt_util::formatted_write $outfile "


		##############################
		# Set PLL AND DQS pin delays #
		##############################

	#"
	# Set the PLL and DQS pin annotated delay
	#generate_pll_delays
	#generate_dqs_delays

	eda_pt_util::formatted_write $outfile "


		######################
		# Timing Constraints #
		######################

	"
	if { [file exists $output_pt_collection] } {
		puts $outfile "source [file tail $output_pt_collection]"
	} else {
		eda_pt_msg::post_msg "" E_CANNOT_OPEN_FILE $output_pt_collection
		qexit -error
	}

	if { [file exists $input_tq_constraint] } {
		puts $outfile "source [file tail $input_tq_constraint]"
	} else {
		eda_pt_msg::post_msg "" E_CANNOT_OPEN_FILE $input_tq_constraint
		qexit -error
	}

	# Get output pin loading and input pin transition times
	generate_output_pin_loadings

	# Unload all reports
	unload_report

	close $outfile
	eda_pt_util::post_msgs "info" \
	"--------------------------------------------------------" \
	"Generated $output_pt_script" \
	"--------------------------------------------------------"
}


# --------------------------------------------------------------------------
# --------------------------------------------------------------------------
proc eda_pt_generate::generate_header { hdl_type } {
	# Writes a Header Section, where search paths, link paths and library
	# files are defined.
# --------------------------------------------------------------------------
# --------------------------------------------------------------------------
	global outfile

	set tool_type [get_global_assignment -name EDA_TIMING_ANALYSIS_TOOL]
	set family [get_global_assignment -name FAMILY]
	set quartus_root [file dirname $::quartus(binpath)]
	if { [string compare -nocase [get_ini_var -name eda_pt_regtest_mode] on] == 0 } {
		set quartus_root "~/quartus"
	}

	puts $outfile "# This Tcl script should be used for $tool_type only"
	puts $outfile "set report_default_significant_digits 3"
	puts $outfile "set hierarchy_separator ."
	puts $outfile "set quartus_root \"$quartus_root/\""
	puts $outfile {set search_path [list . [format "%s%s" $quartus_root "eda/synopsys/primetime/lib"] ]}
	puts $outfile "set link_path \[list * [eda_pt_lib::get_pt_libs $family] alt_vtl.db]"
	if { $hdl_type == "verilog" } {
		puts $outfile "read_verilog [eda_pt_lib::get_pt_v $family]"
	} elseif { $hdl_type == "vhdl" } {
		puts $outfile "read_vhdl -vhdl_compiler [eda_pt_lib::get_pt_vhd $family]"
	}
}


# --------------------------------------------------------------------------
# --------------------------------------------------------------------------
proc eda_pt_generate::generate_design_entry { hdl_type is_fast } {
	# Writes a Design Entry Section, where the design and SDO files are
	# linked, entry level is defined and various PrimeTime settings are
	# made.
# --------------------------------------------------------------------------
# --------------------------------------------------------------------------
	global outfile

	set module_name [string tolower [get_current_revision]]
	set top_lvl_entity_name [get_name_info -info entity_name [get_top_level_entity]]
	set family [get_global_assignment -name FAMILY]
	set family_is_fusion [expr "[string compare -nocase [get_dstr_string -debug -family $family] FUSION] == 0"]
	set family_is_titan [expr "[string compare -nocase [get_dstr_string -debug -family $family] TITAN] == 0"]
        set family_is_cuda [expr "[string compare -nocase [get_dstr_string -debug -family $family] CUDA] == 0"]
	set ocv_is_enabled [expr "[string compare -nocase [get_global_assignment -name EDA_ENABLE_OCV_TIMING_ANALYSIS] on] == 0"]
	set pt_ocv_condition_is_on [expr "[string compare -nocase [get_ini_var -name pt_ocv_condition] on] == 0"]
	set neto_no_sdo_is_on [expr "[string compare -nocase [get_ini_var -name neto_no_sdo] on] == 0"]

	if { $hdl_type == "verilog" } {
		puts $outfile "read_verilog ${module_name}.vo"
	} elseif { $hdl_type == "vhdl" } {
		puts $outfile "read_vhdl -vhdl_compiler ${module_name}.vho"
	}

	puts $outfile "current_design $top_lvl_entity_name"
	puts $outfile "link"

	if { ($family_is_fusion && $ocv_is_enabled) || $pt_ocv_condition_is_on } {
		puts $outfile "set_operating_conditions -analysis_type on_chip_variation"
		if { $neto_no_sdo_is_on == 0 } {
			puts $outfile "read_sdf -analysis_type on_chip_variation"
		}
		puts $outfile "set timing_remove_clock_reconvergence_pessimism true"

	} elseif { ($family_is_titan || $family_is_cuda) } {
	        puts $outfile "set_operating_conditions -analysis_type on_chip_variation"
	        
                set sdf_type ""
		if { $hdl_type == "verilog" } {
			set sdf_type "_v"
		} elseif { $hdl_type == "vhdl" } {
			set sdf_type "_vhd"
		}

		puts $outfile "## Use \"slow\" for slow corner or \"fast\" for fast corner"
		puts $outfile "set corner slow"
		puts $outfile "if \[string equal -nocase \$corner slow] \{"
		puts $outfile "\tread_sdf -analysis_type on_chip_variation ${module_name}${sdf_type}.sdo"
		puts $outfile "\} elseif \[string equal -nocase \$corner fast] \{"
		puts $outfile "\tread_sdf -analysis_type on_chip_variation ${module_name}${sdf_type}_fast.sdo"
		puts $outfile "\}"
		
		puts $outfile "## To remove clock reconvergence pessimism, uncomment the following line:"
	        puts $outfile "## set timing_remove_clock_reconvergence_pessimism true"

	} else {
		puts $outfile "## Set variable timing_propagate_single_condition_min_slew to false only for versions 2004.06 and earlier"
		puts $outfile "regexp \{(\[1-9]\[0-9]\[0-9]\[0-9]\\.\[0-9]\[0-9])\} \$sh_product_version dummy version"
		puts $outfile "if \{ \[string compare \"2004.06\" \$version ] != -1 \} \{"
		puts $outfile "\tset timing_propagate_single_condition_min_slew false"
		puts $outfile "\}"
		puts $outfile "set_operating_conditions -analysis_type single"

		set sdf_type ""
		if { $hdl_type == "verilog" } {
			set sdf_type "_v"
		} elseif { $hdl_type == "vhdl" } {
			set sdf_type "_vhd"
		}

		puts $outfile "## Use \"slow\" for slow corner or \"fast\" for fast corner"
		puts $outfile "set corner slow"
		puts $outfile "if \[string equal -nocase \$corner slow] \{"
		puts $outfile "\tread_sdf ${module_name}${sdf_type}.sdo"
		puts $outfile "\} elseif \[string equal -nocase \$corner fast] \{"
		puts $outfile "\tread_sdf ${module_name}${sdf_type}_fast.sdo"
		puts $outfile "\}"

		# SPR 214571
		#if { $is_fast } {
		#	puts $outfile "\tread_sdf ${module_name}${sdf_type}_fast.sdo"
		#} else {
		#	puts $outfile "\tread_sdf ${module_name}${sdf_type}.sdo"
		#}
	}
}


# --------------------------------------------------------------------------
# --------------------------------------------------------------------------
proc eda_pt_generate::generate_output_pin_loadings { } {
	# Use Fitter "Output Pins" and "Bidir Pins" panels to get output pin
	# loadings to generate PrimeTime "set_load" commands.
# --------------------------------------------------------------------------
# --------------------------------------------------------------------------
	global outfile

	# We need to load_report to get output pin loads
	load_report
	if ![is_report_loaded] {
		eda_pt_msg::post_msg "" E_NO_REPORT_DB
		qexit -error
	}

	# Get Report panels.
	set rpt_name "Fitter report"
	set panel_names {"*Output Pins" "*Bidir Pins"}
	
	# Keep the PADIO Port Name and Node ID in pair
	# The key is PADIO Name and the value is Node ID
	array set padio_name_list {}
        foreach_in_collection node [get_atom_nodes -type PIN] {
                set padio_port [get_atom_oport_by_type -node $node -type PADIO]
                if { $padio_port != -1 } {
	                set padio_name [get_atom_port_info -node $node -type oport -port_id $padio_port -key name]
	                set padio_name_list($padio_name) $node
                }
	}

	foreach panel_name $panel_names {
		set panel_id [get_report_panel_id $panel_name]
		if {$panel_id != -1} {
			set header_line_1 "#############################################"
			set header_line_2 "# [string range $panel_name 1 end] Loadings #"
			set header_line_len [string length $header_line_2]

			eda_pt_util::formatted_write $outfile "

				[string range $header_line_1 1 $header_line_len]
				$header_line_2
				[string range $header_line_1 1 $header_line_len]

			"

			# Get the number of rows
			set row_cnt [get_number_of_rows -id $panel_id]

			for {set i 1} {$i < $row_cnt} {incr i} {
				set pin_name [get_report_panel_data -row $i -col_name "Name" -id $panel_id]
				# Call ::quartus::eda_pt::get_pt_port_names_by_node_name
				if [catch { set p_signal_name [get_pt_port_names_by_node_name -node $pin_name] } result] {
					post_message -type warning $result
					set p_signal_name $pin_name
				}

                                set atom_id ""
				if [catch { set atom_id [get_atom_node_by_name -name $pin_name] } result] {
				          set atom_id $padio_name_list($pin_name)
				          if { $atom_id == "" } {
					msg_vdebug $result
				          }
                            	}

                            	if { $atom_id != "" } {

					if [catch { set io_reserved_type [get_atom_node_info -key ENUM_IO_RESERVED_TYPE -node $atom_id] } result] {
						msg_vdebug $result
						set io_reserved_type "NONE"
					}

					if { $io_reserved_type == "NONE" } {
						set pin_location [get_report_panel_data -row $i -col_name "Pin \#" -id $panel_id]

						# Get the Load value and remove the unit.
						set load [lindex [get_report_panel_data -row $i -col_name "Load" -id $panel_id] 0]

						# Generate the output pin load PrimeTime script.
						puts $outfile "# Pin $pin_name ( Location = $pin_location )"
						eda_pt_util::write_command "set_load -pin_load $load \[get_ports \{ $p_signal_name \} ]"
					}
				}
			}
		} else {
			# If specified panel cannot be found, post a warning message.
			# Bidirectional pins doesn't always exist.
			eda_pt_msg::post_debug_msg	W_REPORT_PANEL_NOT_FOUND \
										[list $panel_name $rpt_name]
		}
	}
}


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
proc eda_pt_generate::generate_dqs_delays { } {
	# For DQS, set_annotated_delay is used to communicate delay chain
	# settings
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
	# TODO: unused
	global outfile

	foreach_in_collection atom_id [get_atom_nodes -type PIN] {

		set oterms [get_atom_oports -node $atom_id]
		foreach oterm_id $oterms {
			set oterm_type [get_atom_port_info -node $atom_id -type oport -port_id $oterm_id -key type]
			if {[string equal -nocase $oterm_type OUT_STAGE4] } {
				set q_ioc_name [get_atom_node_info -node $atom_id -key name]
				set p_ioc_name [convert_cell_name_to_hcii $q_ioc_name -cell_type PIN -use_sdc_format]
				puts $outfile "# IOC (DQS Mode): $q_ioc_name"
				set p_pin_name "$p_ioc_name/PIN"
				set ff_delay [get_atom_node_info -node $atom_id -key INT_DQS_DELAY_VALUE_FOR_BACKEND_FF]
				set ss_delay [get_atom_node_info -node $atom_id -key INT_DQS_DELAY_VALUE_FOR_BACKEND_SS]
				# Convert to "ns"
				set ff_delay [eda_pt_util::tsm_delay_to_ns $ff_delay]
				set ss_delay [eda_pt_util::tsm_delay_to_ns $ss_delay]

				eda_pt_util::write_command "set annotated_delay(ffsi) $ff_delay"
				eda_pt_util::write_command "set annotated_delay(sssi) $ss_delay"
				eda_pt_util::write_command "set_annotated_delay \$annotated_delay(\$delay_type) -incre -to $p_pin_name -net \n"
			}
		}
	}
}


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
proc eda_pt_generate::generate_pll_delays { } {
	# Set PLL Annotated Delay
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
	# TODO: unused
	global outfile

	# Use this constant to represent an illegal or unset compensation delay
	variable illegal_pll_compensation
	set illegal_pll_compensation -2147483647

	foreach_in_collection atom_id [get_atom_nodes -type PLL] {

		set q_atom_name [get_atom_node_info -node $atom_id -key name]
		puts $outfile "\n# PLL block name: $q_atom_name"

		# Get iport of PLL
		# Note that a PLL can have at most two input clocks
		set pll_in_list [get_atom_node_info -node $atom_id -key STRING_VEC_PORT_NAME_VEC]

		# Check which real PLL oterms are used
		set oterms [get_atom_oports -node $atom_id]
		foreach oterm_id $oterms {
			set oterm_fanout [get_atom_port_info -node $atom_id -type oport -port_id $oterm_id -key fanout]
			if {[llength $oterm_fanout] > 0} {
				set oterm_type [get_atom_port_info -node $atom_id -type oport -port_id $oterm_id -key type]
				set oterm_index [get_atom_port_info -node $atom_id -type oport -port_id $oterm_id -key literal_index]
				set q_oport_name [get_atom_port_info -node $atom_id -type oport -port_id $oterm_id -key name]

				set max_compensation_delay $illegal_pll_compensation
				set min_compensation_delay $illegal_pll_compensation

				switch -glob $oterm_type {
					EXTCLKOUT* {
						set ext_clock_p2p_delay_list [get_atom_node_info -node $atom_id -key INT_VEC_EXT_CLOCK_P2P_DELAY]
						set ext_clock_p2p_delay_fast_list [get_atom_node_info -node $atom_id -key INT_VEC_EXT_CLOCK_P2P_DELAY_FAST]
						set max_compensation_delay [lindex $ext_clock_p2p_delay_list $oterm_index]
						set min_compensation_delay [lindex $ext_clock_p2p_delay_fast_list $oterm_index]
					}
					CCLK* {
						set clock_out_p2p_delay_list [get_atom_node_info -node $atom_id -key INT_VEC_CLOCK_OUT_P2P_DELAY]
						set clock_out_p2p_delay_fast_list [get_atom_node_info -node $atom_id -key INT_VEC_CLOCK_OUT_P2P_DELAY_FAST]
						set max_compensation_delay [lindex $clock_out_p2p_delay_list $oterm_index]
						set min_compensation_delay [lindex $clock_out_p2p_delay_fast_list $oterm_index]
					}
					SCLK* {
						set sclk_out_p2p_delay_list [get_atom_node_info -node $atom_id -key INT_VEC_SCLK_OUT_P2P_DELAY]
						set sclk_out_p2p_delay_fast_list [get_atom_node_info -node $atom_id -key INT_VEC_SCLK_OUT_P2P_DELAY_FAST]
						set max_compensation_delay [lindex $sclk_out_p2p_delay_list $oterm_index]
						set min_compensation_delay [lindex $sclk_out_p2p_delay_fast_list $oterm_index]
					}
					default { }
				}

				if {($max_compensation_delay != $illegal_pll_compensation) || \
					($min_compensation_delay != $illegal_pll_compensation)} {
					# Get corresponding PrimeTime HC name for the PLL block
					set p_block_name [convert_cell_name_to_hcii $q_atom_name -cell_type PLL -use_sdc_format]
					# Create PT HC name of this oterm using the type and index
					set p_opin_name "$p_block_name/${oterm_type}${oterm_index}"

					# Hard-code delay of the clock net as the compensation delay
					# already accounts for it.
					puts $::outfile "# --> PLL oport name: $q_oport_name"
					eda_pt_util::write_command "set_annotated_delay -net -from $p_opin_name 0.0"

					# For every PLL clock iport/oport pair, set_annotated_delay.
					foreach pll_in $pll_in_list {
						# There are up to 2 inputs but it is likely only one is used.
						if {$pll_in != ""} {
							# Remove "[]" from PLL input port name 
							regsub -all {[]]} $pll_in "" pll_in 
							regsub -all {[[]} $pll_in "" pll_in
							msg_vdebug "==> Found PLL input: $pll_in"
							set p_ipin_name "$p_block_name/$pll_in"
							if {$min_compensation_delay != $illegal_pll_compensation} {
								set pt_min_delay [eda_pt_util::tsm_delay_to_ns $min_compensation_delay]
								eda_pt_util::write_command "set annotated_delay(ffsi) $pt_min_delay"
							}
							if {$max_compensation_delay != $illegal_pll_compensation} {
								set pt_max_delay [eda_pt_util::tsm_delay_to_ns $max_compensation_delay]
								eda_pt_util::write_command "set annotated_delay(sssi) $pt_max_delay"
							}
							eda_pt_util::write_command "set_annotated_delay -cell -from $p_ipin_name -to $p_opin_name \$annotated_delay(\$delay_type) \n"
						}
					}
				}
			}
		}
	}

	puts $::outfile ""
}