set pvcs_revision(eda_pt_conversion) [regsub -nocase -- {\$revision:\s*(\S+)\s*\$} {$Revision: #1 $} {\1}]

# **************************************************************************
#
# File: eda_pt_conversion.tcl
#
# Used by eda_pt_script.tcl
#
# Description:
#		This file defines eda_pt_conversion namespace that do node name
#		translation and generates <revision>.collections.sdc. It takes in
#		one of the files dumped by TimeQuest using "write_sdc -pt":
#
#		1. <revision>.sta_col
#			Contain the necessary information to generate the required flow-
#			specific SDC collections references by <revision>.constraints.sdc
#
#		Example format of the file <revision>.sta_col:
#		set col(_col40) { cell { 344 257 261 265 269 } }
#		set col(_col41) { net { 256 } }
#		set col(_col42) { cell { 264 268 254 260 277 280 } }
#
#		This file source <revision>.sta_col and translates the node ids
#		into PrimeTime node names with the aid of ::quartus::eda_pt.
#
# **************************************************************************


# --------------------------------------------------------------------------
#
namespace eval eda_pt_conversion {
#
# Description:	Define the namespace and internal variables.
#
# Warning:	All defined variables are not allowed to be accessed outside
#			this namespace!!! To access them, use the defined accessors.
#
# --------------------------------------------------------------------------
	# Hierarchy separator
	#variable hier_sep "|"

	# An hash from collection types to the corresponding commands.
	# Note that we cannot create clock collections because it requires
	# clocks must be created first.
	variable col_type_to_cmd;
	array set col_type_to_cmd {
		clk		get_clocks
		port	get_ports
		pin		get_pins
		cell	get_cells
		net		get_nets
	}

	# An hash from collection options to command options.
	variable col_opt_to_cmd_opt;
	array set col_opt_to_cmd_opt {
		n		nocase
		h		hier		;# hierarchical
	}
}


# --------------------------------------------------------------------------
# --------------------------------------------------------------------------
proc eda_pt_conversion::generate_col_script { input_tq_collection output_pt_collection } {
	# Process TimeQuest dumped out file.
	# It will convert the HDB_NAME_ID to a vo/vho naming with the aid of
	# ::quartus::eda_pt
# --------------------------------------------------------------------------
# --------------------------------------------------------------------------
	global quartus
	global pvcs_revision
	global col_outfile
	variable col_type_to_cmd

	# Open file to output generated PrimeTime collections
	if [catch { set col_outfile [open $output_pt_collection w] } result] {
		eda_pt_msg::post_msg "" E_CANNOT_OPEN_OUTPUT_FILE $output_pt_collection
		qexit -error
	}

	eda_pt_util::formatted_write $col_outfile "
		####################################################################################
		#
		# Generated by [file tail [info script]]\t$pvcs_revision(eda_pt_script)
		#              eda_pt_conversion.tcl\t$pvcs_revision(eda_pt_conversion)
		#              in [file dirname [info script]]/.
		#
		# Quartus:  $quartus(version)
		#
		# Project:  $quartus(project)
		# Revision: $quartus(settings)
		#
		# Date: [clock format [clock seconds]]
		#
		####################################################################################


	"

        set name_missing_list [list]

	# Read TimeQuest dumped file
	if [catch { set infile [open $input_tq_collection r] } result] {
		eda_pt_msg::post_msg "" CW_CANNOT_OPEN_COL_FILE $input_tq_collection
		qexit -error
	} else {
		# Source the <rev>.col.tcl file.
		source $input_tq_collection
		
		# The collections array name is "col".
		foreach col_id [array names col] {
			# { pin { {2842 REGOUT -1} {2844 REGOUT -1} } n }
			set col_type  [lindex $col($col_id) 0]
			set col_elmts [lindex $col($col_id) 1]
			set col_opts  [lindex $col($col_id) 2]
			set cmd $col_type_to_cmd($col_type)
			set cmd_opts [eda_pt_conversion::translate_cmd_options $col_opts]
			set pt_names ""
			set msg_list ""

			eda_pt_conversion::convert_col_elmts_to_pt_names $col_elmts $col_type pt_names msg_list name_missing_list
			set pt_names [lsort -dictionary $pt_names]

			# Output messages generated from the above conversion process.
			eda_pt_msg::output_msg_list $col_outfile msg_list

			set pt_names_size [string length $pt_names]
			if {[string length $pt_names] > 0} {
				set processed_pt_names [eda_pt_collection::process_p_names_for_collection pt_names]
				if {$col_type == "clk"} {
					puts $col_outfile "set $col_id \"$cmd$cmd_opts \{$processed_pt_names\}\""
				} else {
					puts $col_outfile "set $col_id \[ $cmd$cmd_opts \{$processed_pt_names\}\]"
				}
			} else {
				# Issue warning message as we are not able generate the PT Name Collection
				# ToDo:	We need to store the col_id so that if there is any constraint
				#		refer to this collection, then we need to discard that constraint and acknowledge the user
				eda_pt_msg::post_debug_msg CW_P_COL_IS_EMPTY $col_id
				eda_pt_msg::output_msg $col_outfile CW_P_COL_IS_EMPTY $col_id
			}
			puts $col_outfile "\n\n"
		}

                # Issue warning message at the GUI for those pins without PT Name
                # ToDo: The individual message for each missing pins is arrange in the msg_list_display
                #       To edit the sequence of sub-message, modified the msg_list_display
                array set missing_name_ID {}
                set msg_list_display [list]

                foreach msg_name_not_found_list [lsort $name_missing_list] {
                        if { ![info exists missing_name_ID($msg_name_not_found_list)] } {
                           set missing_name_ID($msg_name_not_found_list) ""
                           lappend msg_list_display [eda_pt_msg::get_msg W_NAME_ID_NOT_FOUND $msg_name_not_found_list]
                        }
               	}

                if { [array size missing_name_ID] > 0 } {
                        post_message -type warning [eda_pt_msg::get_msg W_NAME_NOT_FOUND_MSG [array size missing_name_ID]] -submsgs $msg_list_display
                }

		close $infile
	}

	close $col_outfile
	eda_pt_util::post_msgs "info" \
	"--------------------------------------------------------" \
	"Generated $output_pt_collection" \
	"--------------------------------------------------------"
}


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
proc eda_pt_conversion::convert_col_elmts_to_pt_names { col_elmts col_type pt_names_ref return_msg_list_ref return_msg_list2_ref} {
	#
	# Convert collection elements to PrimeTime names.
	# The format of the col_elmts can be one of the following:
	# 1. { 265 253 257 340 261 }
	# 2. { {151 clk} {151 datain} {151 regout} }
	#
	# The collection types can be one of the following:
	# 1. clk		get_clocks
	# 2. port	get_ports
	# 3. pin	get_pins
	# 4. cell	get_cells
	# 5. net	get_nets
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
	upvar $pt_names_ref pt_names
	upvar $return_msg_list_ref msg_list
	upvar $return_msg_list2_ref name_missing_list

	#variable hier_sep

	foreach elmt $col_elmts {
		set elmts_len [llength $elmt]
		set hdb_name_id [lindex $elmt 0]
		set pt_name ""

		if [string is integer -strict $hdb_name_id] {	;# -strict: an empty string returns 0

			if { [string compare $col_type "pin"] == 0 && $elmts_len == 3 } {
				# Call ::quartus::eda_pt::get_pt_pin_names
				if [catch { append pt_name [get_pt_pin_names -id $hdb_name_id -pin [lindex $elmt 1] -index [lindex $elmt 2]] } result] {
                                        msg_vdebug $result
                                        lappend name_missing_list "$hdb_name_id"
					lappend msg_list "W_NAME_ID_NOT_FOUND $hdb_name_id"
					continue
				}
			} elseif { [string compare $col_type "port"] == 0 } {
				# Call ::quartus::eda_pt::get_pt_port_names
				if [catch { append pt_name [get_pt_port_names -id $hdb_name_id] } result] {
					msg_vdebug $result
                                        lappend name_missing_list "$hdb_name_id"
					lappend msg_list "W_NAME_ID_NOT_FOUND $hdb_name_id"
					continue
				}
			} elseif { [string compare $col_type "cell"] == 0 } {
				# Call ::quartus::eda_pt::get_pt_cell_names
				if [catch { append pt_name [get_pt_cell_names -id $hdb_name_id] } result] {
					msg_vdebug $result
                                        lappend name_missing_list
					lappend msg_list "W_NAME_ID_NOT_FOUND $hdb_name_id"
					continue
				}
			}

			if {[string length $pt_name] > 0} {
				lappend pt_names $pt_name
			}
		} elseif {$hdb_name_id == "*"} {
			# Pure wildcard
			lappend pt_names $hdb_name_id
		}
	}
}


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
proc eda_pt_conversion::translate_cmd_options { col_opts } {
	#
	# Translate command options.
	# 1. n -> nocase
	# 2. h -> hierarchincal
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
	variable col_opt_to_cmd_opt
	set cmd_opts ""

	foreach opt $col_opts {
		if {![info exists col_opt_to_cmd_opt($opt)]} {
			eda_pt_msg::post_msg "" E_UNSUPPORTED_COLLECTION_OPTION $opt
			qexit -error
		}
		append cmd_opts " -" $col_opt_to_cmd_opt($opt)
	}
	return $cmd_opts
}
