set pvcs_revision(main) [regsub -nocase -- {\$revision:\s*(\S+)\s*\$} {$Revision: #1 $} {\1}]

# ******************************************************************************
#
# File:		qsta_sdc_for_hcii_tester.tcl
#
# Usage:	quartus_sta <revision> --generate_sdc_collections
#
# Description: 
#			A script that tests the correctness of files generated by
#			write_sdc -hc.
#			It translates *.hcii_col.tcl to TimeQuest collections.
#
# Authors:	Jing Tong
#
#			Copyright (c)  Altera Corporation 1999 - 2006
#			All rights reserved.
#
# ******************************************************************************

# ------------------------------------------------------------------------------
#
namespace eval sdc_col {
#
# Description:	Code to generate SDC collections from a <rev>.pt_col.tcl file.
#
# ------------------------------------------------------------------------------
	namespace export generate
	
	# --------------------------------------
	#	Namespace variables
	# --------------------------------------
	# Revision name
	variable rev_name			$::quartus(settings)

	# working directory
	variable working_dir

	# File extentions
	variable col_in_file_ext	"pt_col.tcl"
	variable col_out_file_ext	"col.sdc"

	# File paths
	variable col_in_file		"$rev_name.$col_in_file_ext"
	variable col_out_file		"$rev_name.$col_out_file_ext"

	# File IDs
	variable col_out_file_id	""

	# Hierarchy separator
	variable hier_sep			"|"

	# An hash from collection types to the corresponding commands.
	# Note that we cannot create clock collections because it requires
	# clocks must be created first.
	variable col_type_to_cmd;
	array set col_type_to_cmd {
		clk		get_clocks
		port	get_ports
		pin		get_pins
		cell	get_cells
		net		get_nets
	}

	# An hash from collection options to command options.
	variable col_opt_to_cmd_opt;
	array set col_opt_to_cmd_opt {
		n		nocase
		h		hier
	}
}

# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
proc sdc_col::translate_cmd_options { col_opts } {
	#
	# Translate command options.
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
	variable col_opt_to_cmd_opt
	
	set cmd_opts ""

	foreach opt $col_opts {
		if {![info exists col_opt_to_cmd_opt($opt)]} {
			post_message -type error "Found an unsupported collection option: $opt."
			qexit -error
		}

		append cmd_opts " -" $col_opt_to_cmd_opt($opt)
	}

	return $cmd_opts
}

# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
proc sdc_col::get_q_name_by_hdb_id { hdb_id } {
	# Get Quartus HDB_INAME string (short format) by hdb_id.
	#
	# This function doesn't check the validity of passed hdb_id. The caller
	# should handle the possible exeption.
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
	return [get_name_info -info short_full_path $hdb_id]
}

# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
proc sdc_col::convert_col_elmts_to_q_names { col_elmts q_names_ref return_msg_list_ref } {
	# 
	# Convert collection elements to Quartus names.
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
	upvar $q_names_ref qnames
	upvar $return_msg_list_ref msg_list
	
	variable hier_sep

	foreach elmt $col_elmts {
		set component_cnt [llength $elmt]
		set comp_1 [lindex $elmt 0]		;# First component
		set q_name ""
		if [string is double -strict $comp_1] {
			if [catch {set q_name [sdc_col::get_q_name_by_hdb_id $comp_1]}] {
#				if {$::options(verbose)} {
					post_message -type warning "Cannot find corresponding name of HDB ID $comp_1."
#				}
				lappend msg_list "W_Q_NAME_NOT_FOUND $comp_1"
				continue
			}
		} else {
			set q_name $comp_1
		}

		if {$component_cnt == 2} {
			append q_name $hier_sep [lindex $elmt 1]
		}

		lappend qnames $q_name
	}
}

# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
proc sdc_col::format_q_names { q_names } {
	#
	# Format the Quartus names.
	#  - Return the Quartus name if only one name specified.
	#  - Return Quartus names separated by line-break if more than one name specified.
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
	set formatted_q_names ""

	if {[llength $q_names] == 1} {
		set formatted_q_names [lindex $q_names 0]
	} else {
		append formatted_q_names "{ \\ \n"
		
		foreach q_name $q_names {
			append formatted_q_names "\t\t\t\t" $q_name " \\ \n"
		}
		append formatted_q_names "\t\t\t}"
	}
	
	return $formatted_q_names
}

# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
proc sdc_col::prepare_files { } {
	#
	# Prepare output file(s).
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
	variable working_dir
	variable col_out_file
	variable col_out_file_id

	if ![file exists $working_dir] {
		post_message -type error \
			"Cannot find specified directory $working_dir"
		qexit -error
	}
	set col_out_file_id [open $working_dir/$col_out_file w]
}

# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
proc sdc_col::reconstruct_collections { } {
	#
	# Reconsturct SDC collections.
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
	variable working_dir
	variable col_in_file
	variable col_out_file_id
	variable col_type_to_cmd

	if [file exists $working_dir/$col_in_file] {
		# Source the <rev>.col.tcl file.
		source $working_dir/$col_in_file
	} else {
		post_message -type error "File $working/$col_in_file doesn't exists."
		qexit -error
	}

	# The collections array name is "col".
	foreach col_id [array names col] {
		set col_type  [lindex $col($col_id) 0]
		set col_elmts [lindex $col($col_id) 1]
		set col_opts  [lindex $col($col_id) 2]

		if {![info exists col_type_to_cmd($col_type)]} {
			post_message -type error "Found an unsupported collection type: $col_type."
			qexit -error
		}

		set cmd $col_type_to_cmd($col_type)
		set cmd_opts [sdc_col::translate_cmd_options $col_opts]

		set q_names ""
		set msg_list ""
		sdc_col::convert_col_elmts_to_q_names $col_elmts q_names msg_list
		set formatted_q_names [sdc_col::format_q_names $q_names]

		if {$col_type == "clk"} {
			puts $col_out_file_id "set $col_id \"$cmd$cmd_opts $formatted_q_names\""
		} else {
			puts $col_out_file_id "set $col_id \[ $cmd$cmd_opts $formatted_q_names \]"
		}
	}
}

# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
proc sdc_col::generate { option } {
	#
	# Generate Quartus SDC collections.
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
	variable working_dir ""

	switch $option {
		"pt" -
		"primetime" {
			set working_dir [get_global_assignment -name EDA_NETLIST_WRITER_OUTPUT_DIR]
			if {$working_dir == ""} {
				# Use default directory.
				set working_dir "timing/primetime"
			}
		}
		"hcii" {
			set working_dir [get_global_assignment -name HCII_OUTPUT_DIR]
			if {$working_dir == ""} {
				# Use default directory.
				set working_dir "hc_output"
			}
		}
		default {
			post_message -type error \
				"Unsupported argument value \"$option \" for option --generate_sdc_collections. Valid argument values are primetime (or pt) and hcii."
			qexit -error
		}
	}
	
	sdc_col::prepare_files
	sdc_col::reconstruct_collections
}

#########################
#						#
#	Call main function	#
#						#
#########################
#main
