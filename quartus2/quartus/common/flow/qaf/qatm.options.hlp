<IMPORT_DATABASE>
Option to import the project database from version-compatible 
database files in the specified directory.

The following are the supported version-compatible database 
files from which the project database is imported:

Post-synthesis files
<directory>/<revision name>.map.atm
<directory>/<revision name>.map.hdbx

Post-fitting files
<directory>/<revision name>.cmp.atm
<directory>/<revision name>.cmp.hdbx
<directory>/<revision name>.cmp.rcf

Generic files
<directory>/<revision name>.cmp.xml
<directory>/<revision name>.db_info
</IMPORT_DATABASE>

<EXPORT_DATABASE>
Option to export the project database to version-compatible 
database files. These files are placed in the specified 
directory.

The following are the supported version-compatible database 
files to which the project database is exported:

Post-synthesis files
<directory>/<revision name>.map.atm
<directory>/<revision name>.map.hdbx

Post-fitting files
<directory>/<revision name>.cmp.atm
<directory>/<revision name>.cmp.hdbx
<directory>/<revision name>.cmp.rcf


Generic files
<directory>/<revision name>.cmp.xml
<directory>/<revision name>.db_info
</EXPORT_DATABASE>

<POST_MAP>
Limits the --export_database and --import_database options to
only export and import the output of Analysis and Synthesis
(quartus_map) to and from the version-compatible database.

Note: This option must be used with either the --export_database
or the --import_database option.
</POST_MAP>

<WRITE_EQUATION_FILE_ID>

Writes equation file to the specified filename.
If filename is not specified, the filename used is:
<revision name>.<map or fit>.eqn.

The netlist type must be specified using "--netlist_type" option.
The valid netlist types are "map" and "cmp".

Use "map" to specify the post synthesis netlist and use "cmp" for
    the post fitter netlist.

---------
Examples:
---------

##Write the post synthesis equation file (using default filename.)
quartus_cdb <revision name> --write_eqn_file --netlist_type=map

##Write the post fitter equation file (using default filename.)
quartus_cdb <revision name> --write_eqn_file --netlist_type=cmp

##Write post synthesis equation file to the file "my_mapper_results.eqn".
quartus_cdb <revision name> --write_eqn_file=my_mapper_results.eqn 
	--netlist_type=map
</WRITE_EQUATION_FILE_ID>

<NETLIST_TYPE_ID>
Loads the specified atom netlist type. This option is used in 
combination with the "-write_equation_file" option.
Use "map" to specify the post Analysis & Synthesis netlist.
Use "cmp" to specify the post Fitter netlist.
Use "asm" to specify the post Assembler netlist. The
post Assembler netlist is only supported for designs
using the HardCopy device family.
</NETLIST_TYPE_ID>

<HC_ARCHIVE>

Archives HardCopy Handoff Files into the specified output file
name.

The Quartus II Archive File <output file>.qar is generated by this
option. By default, if the output file name is not specified, the
file name <current revision>.qar is  used.

The current revision and its companion revision should be fully
compiled for this option to properly archive all necessary files. 
The companion revision is obtained from the 
COMPANION_REVISION_NAME assignment in the 
Quartus II Settings File (.qsf) for the current revision.

------
Usage:
------

quartus_cdb <project> [-c <current revision>] --hc_archive=[<output file>]

---------
Examples:
---------

   ## The following example illustrates the option usage using
   ## Stratix II and HardCopy II migration scenario

   ## Compile the Stratix II revision
   quartus_sh --flow compile myproject -c myfpga

   ## Create a HardCopy II revision named "myhcii" based on "myfpga"
   quartus_cdb myproject -c myfpga --create_companion=myhcii

   ## Compile the HardCopy II revision
   quartus_sh --flow compile myproject -c myhcii

   ## Verify that the design was migrated corerctly
  	   quartus_cdb myproject -c myhcii --compare=myfpga
  	   quartus_cdb myproject -c myfpga --compare=myhcii

   ## Generates Quartus II Archive File "myfpga.qar"
   quartus_cdb myproject -c myfpga --hc_archive

   ## Generate Quartus II Archive File "custom.qar"
   quartus_cdb myproject -c myfpga --hc_archive=custom
</HC_ARCHIVE>

<HC_MIN_ARCHIVE>
Option to archive the minimum set of files only.

Source files and other informational files are not
included when archiving the HardCopy handoff files using
this option.
</HC_MIN_ARCHIVE>

<HC_REVIEW>
Generates a HardCopy Handoff Report.

The current revision and its companion revision should be fully
compiled for this option to properly review all necessary files. 
The companion revision is obtained from the 
COMPANION_REVISION_NAME assignment in the
Quartus II Settings File (.qsf) for the current revision.

------
Usage:
------

quartus_cdb <project> [-c <current revision>] --hc_review

---------
Examples:
---------
   ## The following example illustrates the option usage using
   ## Stratix II and HardCopy II migration scenario

   ## Compile the Stratix II revision
   quartus_sh --flow compile myproject -c myfpga

   ## Create a HardCopy II revision named "myhcii" based on "myfpga"
   quartus_cdb myproject -c myfpga --create_companion=myhcii

   ## Compile the HardCopy II revision
   quartus_sh --flow compile myproject -c myhcii

   ## Verify that the design was migrated corerctly
   quartus_cdb myproject -c myhcii --compare=myfpga
     	   quartus_cdb myproject -c myfpga --compare=myhcii

   ## Review the HardCopy II design
   quartus_cdb myproject -c myfpga --hc_review
</HC_REVIEW>

<HC_READY>
Generate HardCopy Design Readiness Check report.

The report contains information on required settings for the 
design to be ready for HardCopy devices.	

------
Usage:
------

quartus_cdb <project> [-c <current revision>] --hc_ready

---------
Examples:
---------

        ## The following example illustrates the option usage using
        ## Stratix II and HardCopy II migration scenario

	## Run Analysis & Synthesis  for Stratix II revision 
	quartus_map myproject -c myfpga

 		## Run HardCopy Design Readiness Check for Stratix II revision 
	quartus_cdb myproject -c myfpga --hc_ready

	## Create a HardCopy II revision named "myhcii" based on "myfpga"
	quartus_cdb myproject -c myfpga --create_companion=myhcii

	## Run Analysis & Synthesis for HardCopy II revision 
	quartus_map myproject -c myhcii

	## Run HardCopy Design Readiness Check for HardCopy II revision 
	quartus_cdb myproject -c myhcii --hc_ready

</HC_READY>

<CREATE_COMPANION>
Creates a HardCopy companion revision based on the
current revision.

If <companion revision> is specified, it is used to create the
HardCopy companion revision. Otherwise, the default companion revision
name is used unless the COMPANION_REVISION_NAME assignment is found in
the current revision's Quartus II Settings File (.qsf).

Reverse migration also supported when the originating revision is a
HardCopy device (HardCopy II or newer). The companion created will be targeted to FPGA
revision with a proper companion name if the <companion revision> is
not specified and the COMPANION_REVISION_NAME assignment is not found.

The current revision should be fully compiled for this option to
migrate all pin locations.

------
Usage:
------

quartus_cdb <project> [-c <current revision>] --create_companion=[<companion revision>]

Note that <companion revision> is the new current revision
after executing this option.

---------
Examples:
---------

   ## The following example illustrates the option usage using
   ## Stratix II and HardCopy II migration scenario

   ## Compile the Stratix II revision
   quartus_sh --flow compile myproject -c myfpga

   ## Create a HardCopy II revision named "myhcii" based on "myfpga"
   quartus_cdb myproject -c myfpga --create_companion=myhcii

   ## Compile the HardCopy II revision
   quartus_sh --flow compile myproject -c myhcii

   ## **********************************
   ## Or you can simply do the following
   ## **********************************

   ## Compile the Stratix II revision
   quartus_sh --flow compile myproject

   ## The following command will create the
   ## HardCopy II revision named "myproject_hcii"
   ## unless the COMPANION_REVISION_NAME assignment
   ## is found in myproject.qsf.
   quartus_cdb myproject --create_companion

   ## Compile the HardCopy II revision
   quartus_sh --flow compile myproject -c myproject_hc
</CREATE_COMPANION>

<WRITE_FUSION_FILES_ID>
Generates HardCopy Handoff files to an output directory.

The output directory is "hc_output" under the current project
directory unless the output directory is specified by the
HC_OUTPUT_DIR assignment in the Quartus II Settings File (.qsf).
</WRITE_FUSION_FILES_ID>

<UPDATE_MIF_ID>
Option to update memory content from the Memory Initialization 
File (.mif) or Hexadecimal (Intel-Format) File (.hex) for all 
RAM or CAM atoms.

This option is useful for quickly changing memory contents 
without requiring a full compilation. After using this 
option, run the Assembler (quartus_asm) to generate new 
programming files for the device.
</UPDATE_MIF_ID>

<VQM_ID>
Option to generate a Verilog Quartus Mapping File (.vqm) 
netlist.

You must specify the .vqm file name unless the name
can be taken from the LOGICLOCK_INCREMENTAL_COMPILE_FILE
assignment in the Quartus II Settings File (.qsf).

This option overrides the settings specified in the .qsf. 
</VQM_ID>

<RCF_IS_FOR_VQM_ID>
Option to write the Routing Constraints File (.rcf) for 
the Verilog Quartus Mapping File (.vqm) netlist.
</RCF_IS_FOR_VQM_ID>

<BACK_ANNOTATE_ID>
Option to back-annotate to the current Quartus II Settings 
File (.qsf) according to the specified demotion type. The 
back-annotation process retains the current resource and 
device assignments for future compilations. The demotion 
type is used to select the assignments that you want to 
back-annotate. The demotion type can be specified in one 
of the following forms:

Demotion Type          Descriptions
---------------------  ---------------------
device                 For device assignments
pin_device             For pin device assignments
lc                     For logic cell assignments
routing                For routing assignments 
lab                    For LAB assignments
megalab                For MegaLAB assignments
megalab_row            For MegaLAB row assignments
megalab_column         For MegaLAB column assignments
row                    For row assignments

Note: Not all demotion types are relevant for all device 
families. The demotion type "routing" applies only to the 
Cyclone(TM), Stratix(R), and Stratix GX device families.
</BACK_ANNOTATE_ID>

<MERGE_ID>
Merges all design partitions to prepare a netlist 
for the Fitter based on the current Partition Netlist 
Type assignments.
</MERGE_ID>

<QID_PARTITION_SOURCE_ID>
Overrides the netlist type setting for the specified Design 
Partition for this compililation. The option hmust be used with 
the --merge option.

<value> takes the form of "<partition name>=<netlist type>",
including the double quotes. For example, to use netlist 
type POST_SYNTH for a partition named "alu", use the 
following argument:

--override_partition_netlist_type="alu=POST_SYNTH"

For non-imported partitions, the following netlist type 
values can be used:

   POST_SYNTH
   POST_FIT
   STRICT_POST_FIT
   EMPTY

For imported partitions, the following netlist type values
can be used:

   IMPORT
   IMPORT_BASED_POST_FIT
   EMPTY
   
To override the netlist type for more than one partition, 
use the override_partition_netlist_type option as many times 
as needed.   
</QID_PARTITION_SOURCE_ID>

<QIC_EXPORT_PROJECT>
Exports a design partition into a Quartus II Exported
Partition (.qxp) file. The .qxp file contains the 
compilation results of the specified partition, and can be
imported into one or more design partitions of another
project.

The value <output file> is optional. If unspecified, the
value specified by the INCREMENTAL_COMPILATION_EXPORT_FILE
global assignment is used if present. Otherwise, a default
file name is generated.

Other options you may use to control how the operation is
performed include:

--incremental_compilation_export_partition_name[=<name>]
--incremental_compilation_export_routing[=<on|off>]
--incremental_compilation_export_netlist_type=<POST_SYNTH|POST_FIT>

Each of the above is explained in more detail in their own
help sections.
</QIC_EXPORT_PROJECT>

<INCREMENTAL_COMPILATION_EXPORT_PARTITION_NAME>
This option must be used with the --incremental_compilation_export
option. Use this option to specify the name of the partition to be
exported. If this option is omitted, or if an empty value is provided,
the value specified by the INCREMENTAL_COMPILATION_EXPORT_PARTITION_NAME
global assignment is used if present. Otherwise, the top-level partition
is exported by default.
</INCREMENTAL_COMPILATION_EXPORT_PARTITION_NAME>

<INCREMENTAL_COMPILATION_EXPORT_NETLIST_TYPE>
This option must be used with the --incremental_compilation_export
option. The values POST_FIT and POST_SYNTH are used to direct the
software to export the post-fit and the post-synthesis netlist,
respectively. If this option is omitted, the value specified by the
INCREMENTAL_COMPILATION_EXPORT_NETLIST_TYPE global assignment
is used if present. Otherwise, the top-level partition is exported
by default.
</INCREMENTAL_COMPILATION_EXPORT_NETLIST_TYPE>

<INCREMENTAL_COMPILATION_EXPORT_ROUTING>
This option must be used with the --incremental_compilation_export
option. The value specifies whether routing is to be exported. The
option only has an effect when a post-fit netlist is exported, 
because a post-synthesis netlist does not contain routing information. 
If this option is omitted, the value specified with the
INCREMENTAL_COMPILATION_EXPORT_ROUTING global assignment is used if
present. Otherwise, the default is to export routing unless the
currently specified device family does not support it.
</INCREMENTAL_COMPILATION_EXPORT_ROUTING>

<QIC_IMPORT_PROJECT>
Imports one or more Quartus II Exported Partition (.qxp) 
files into the design partitions of the current project.

The option uses the following partition assignments to
determine the location of the Quartus II Exported Partition
files, and how importation should be performed, on a 
per-partition basis: 
	
PARTITION_IMPORT_FILE
PARTITION_IMPORT_PROMOTE_ASSIGNMENTS
PARTITION_IMPORT_NEW_ASSIGNMENTS
PARTITION_IMPORT_EXISTING_ASSIGNMENTS
PARTITION_IMPORT_EXISTING_LOGICLOCK_REGIONS	
</QIC_IMPORT_PROJECT>

<DEFAULT_READ_ASSIGNMENT>
--------
Overview
--------

Option to read the assignments from the Quartus II Settings 
File (.qsf) and override assignments obtained from the 
database. All options that pass from the command line 
still override any conflicting assignments found in the 
.qsf.

By default, assignments are read from the .qsf unless you 
specify "--read_settings_files=off".

---------------------------
Command-Line Option Details
---------------------------

Command-line options are provided for making many common
global project settings and performing common tasks. You
can use either of two methods to make assignments to an
individual entity. If the project exists, open the project
in the Quartus II GUI, change the assignment, and close the
project. The changed assignment is updated in the .qsf. Any
command-line executables that are run after this update use
the updated assignment. See "Option Precedence" below for
more information. You can also make assignments using the
Quartus II Tcl scripting API. If you want to completely
script the creation of a Quartus II project, you should
choose this method.

-----------------
Option Precedence
-----------------

If you are using the command-line executables, you need to
be aware of the precedence of various project assignments
and how to control the precedence. Assignments for a
particular project exist in the .qsf for the project.
Assignments for a project can also be made by using
command-line options, as described earlier. Project
assignments are reflected in compiler database files that
hold intermediate compilation results and reflect assignments
made in the previous project compilation.

All command-line options override any conflicting assignments
found in the .qsf or the compiler database files. There are
two command-line options to specify whether .qsf or compiler
database files take precedence for any assignments not
specified as command-line options.

Note: Any assignment not specified as a command-line option
or found in the .qsf or compiler database files is set to its
Quartus II software default value.

The file precedence command-line options are
--read_settings_files and --write_settings_files. By default,
the --read_settings_files and --write_settings_files options
are turned on. Turning on the --read_settings_files option
causes a command-line executable to read assignments from
the .qsf instead of from the compiler database files. Turning
on the --write_settings_files option causes a command-line
executable to update the .qsf to reflect any specified options,
as happens when closing a project in the Quartus II GUI.

Table 1 lists the precedence for reading assignments
depending on the value of the --read_settings_files option.


* Table 1. Precedence for Reading Assignments

Option Specified                      Precedence for Reading Assignments
------------------------------------  ----------------------------------
--read_settings_files=on (Default)    1. Command-line options
                                      2. Quartus II Settings File (.qsf)
                                      3. Compiler database (db directory, if it exists)
                                      4. Quartus II software defaults

--read_settings_files=off             1. Quartus II Settings File (.qsf)
                                      2. Compiler database (db directory, if it exists)
                                      3. Quartus II software defaults


Table 2 lists the locations to which assignments are
written, depending on the value of the --write_settings_files
command-line option.


* Table 2. Location for Writing Assignments

Option Specified                      Location for Writing Assignments
------------------------------------  --------------------------------
--write_settings_files=on (Default)   1. Quartus II Settings File (.qsf) and
                                      2. Compiler database

--write_settings_files=off            1. Compiler database


The following example assumes that a project named fir_filter
exists, and that the Analysis & Synthesis step has been
performed (using the quartus_map executable).

quartus_fit fir_filter --fmax=80MHz
quartus_tan fir_filter
quartus_tan fir_filter --fmax=100MHz --tao=timing_result-100.tao --write_settings_files=off

The first command, quartus_fit fir_filter --fmax=80MHz, runs
the Quartus II Fitter and specifies a global fMAX requirement
of 80 MHz.

The second command, quartus_tan fir_filter, runs Quartus II
Timing Analyzer for the results of the previous fit.

The third command reruns Quartus II Timing Analyzer with a
global Fmax requirement of 100 MHz and saves the result in
a file called timing_result-100.tao. By specifying the
--write_settings_files=off option, the command-line executable
does not update the .qsf to reflect the changed Fmax requirement.
The compiler database files reflect the changed Fmax requirement.
If the --write_settings_files=off option is not specified, the
command-line executable updates the .qsf to reflect the 100 MHz
global fMAX requirement.

Use the --read_settings_files=off and --write_settings_files=off
options (where appropriate) to optimize the way that the
Quartus II software reads and updates the .qsf. The following
example shows how to avoid unnecessary .qsf reading and writing.

quartus_map filtref --source=filtref --part=ep1s10f780c5
quartus_fit filtref --fmax=100MHz --read_settings_files=off
quartus_tan filtref --read_settings_files=off --write_settings_files=off
quartus_asm filtref --read_settings_files=off --write_settings_files=off

The quartus_tan and quartus_asm executables do not need to
read or write settings files because they do not change any
settings in the project.
</DEFAULT_READ_ASSIGNMENT>

<DEFAULT_WRITE_ASSIGNMENT>
--------
Overview
--------

Option to write out the settings obtained from command-line 
options to the Quartus II Settings File (.qsf). 

By default, assignments are not written to the .qsf unless you
specify "--write_settings_files=on". However, for other Quartus II
command-line executables, assignments are written to the Quartus II
Settings File (.qsf) unless you specify "--write_settings_files=off".

---------------------------
Command-Line Option Details
---------------------------

Command-line options are provided for making many common
global project settings and performing common tasks. You
can use either of two methods to make assignments to an
individual entity. If the project exists, open the project
in the Quartus II GUI, change the assignment, and close the
project. The changed assignment is updated in the .qsf. Any
command-line executables that are run after this update use
the updated assignment. See "Option Precedence" below for
more information. You can also make assignments using the
Quartus II Tcl scripting API. If you want to completely
script the creation of a Quartus II project, you should
choose this method.

-----------------
Option Precedence
-----------------

If you are using the command-line executables, you need to
be aware of the precedence of various project assignments
and how to control the precedence. Assignments for a
particular project exist in the .qsf for the project.
Assignments for a project can also be made by using
command-line options, as described earlier. Project
assignments are reflected in compiler database files that
hold intermediate compilation results and reflect assignments
made in the previous project compilation.

All command-line options override any conflicting assignments
found in the .qsf or the compiler database files. There are
two command-line options to specify whether .qsf or compiler
database files take precedence for any assignments not
specified as command-line options.

Note: Any assignment not specified as a command-line option
or found in the .qsf or compiler database files is set to its
Quartus II software default value.

The file precedence command-line options are
--read_settings_files and --write_settings_files. By default,
the --read_settings_files and --write_settings_files options
are turned on. Turning on the --read_settings_files option
causes a command-line executable to read assignments from
the .qsf instead of from the compiler database files. Turning
on the --write_settings_files option causes a command-line
executable to update the .qsf to reflect any specified options,
as happens when closing a project in the Quartus II GUI.

Table 1 lists the precedence for reading assignments
depending on the value of the --read_settings_files option.


* Table 1. Precedence for Reading Assignments

Option Specified                      Precedence for Reading Assignments
------------------------------------  ----------------------------------
--read_settings_files=on (Default)    1. Command-line options
                                      2. Quartus II Settings File (.qsf)
                                      3. Compiler database (db directory, if it exists)
                                      4. Quartus II software defaults

--read_settings_files=off             1. Quartus II Settings File (.qsf)
                                      2. Compiler database (db directory, if it exists)
                                      3. Quartus II software defaults


Table 2 lists the locations to which assignments are
written, depending on the value of the --write_settings_files
command-line option.


* Table 2. Location for Writing Assignments

Option Specified                      Location for Writing Assignments
------------------------------------  --------------------------------
--write_settings_files=on (Default)   1. Quartus II Settings File (.qsf) and
                                      2. Compiler database

--write_settings_files=off            1. Compiler database


The following example assumes that a project named fir_filter
exists, and that the Analysis & Synthesis step has been
performed (using the quartus_map executable).

quartus_fit fir_filter --fmax=80MHz
quartus_tan fir_filter
quartus_tan fir_filter --fmax=100MHz --tao=timing_result-100.tao --write_settings_files=off

The first command, quartus_fit fir_filter --fmax=80MHz, runs
the Quartus II Fitter and specifies a global fMAX requirement
of 80 MHz.

The second command, quartus_tan fir_filter, runs Quartus II
Timing Analyzer for the results of the previous fit.

The third command reruns Quartus II Timing Analyzer with a
global Fmax requirement of 100 MHz and saves the result in
a file called timing_result-100.tao. By specifying the
--write_settings_files=off option, the command-line executable
does not update the .qsf to reflect the changed Fmax requirement.
The compiler database files reflect the changed Fmax requirement.
If the --write_settings_files=off option is not specified, the
command-line executable updates the .qsf to reflect the 100 MHz
global fMAX requirement.

Use the --read_settings_files=off and --write_settings_files=off
options (where appropriate) to optimize the way that the
Quartus II software reads and updates the .qsf. The following
example shows how to avoid unnecessary .qsf reading and writing.

quartus_map filtref --source=filtref --part=ep1s10f780c5
quartus_fit filtref --fmax=100MHz --read_settings_files=off
quartus_tan filtref --read_settings_files=off --write_settings_files=off
quartus_asm filtref --read_settings_files=off --write_settings_files=off

The quartus_tan and quartus_asm executables do not need to
read or write settings files because they do not change any
settings in the project.
</DEFAULT_WRITE_ASSIGNMENT>

<GENERATE_BOTTOM_UP_SCRIPTS>
----------
Overview
----------

This tool is designed for use with a top-level project containing 
incremental compilation design partitions. When run, it generates 
scripts and makefiles which allow an easy conversion from top-down 
design methodology (all partitions in one project) to a bottom-up 
design methodology (separate projects for each partition).

One Tcl script is generated for each partition. The Tcl script 
will contain all top-level assignments relevant to the given 
partition, and optionally contains commands to create the lower-level 
project for the partition if it does not exist. The scripts also 
contain optionally generated commands that can help guide the 
lower-level placement so that better results can be achieved when 
exporting to the top-level project. You can customize the content of 
the Tcl scripts by using any of the options described later.

In addition to generating Tcl scripts, you can also generate 
makefiles that can be used to create the lower-level projects with 
the auto-generated Tcl scripts and maintain them as source files 
change. The tool also builds a 'master_makefile' which builds all 
lower-level projects, exports the results to the top-level project 
and performs a top-level compilation. The makefiles are auto-generated 
and are designed for use with GNU make. The makefiles also support 
parallel compilation of the the lower-level projects by using the 
'-j' option of GNU make on systems with multiple processors.

-----------------
Optional Content
-----------------

As mentioned above, you can customize the content of the Tcl files 
with any of the following command line directives.  Each is explained in 
more detail in their own help sections.

--include_makefiles_with_bottom_up_scripts=<on|off>
Default is on.

--include_project_creation_in_bottom_up_scripts=<on|off>
Default is on.

--include_virtual_pins_in_bottom_up_scripts=<on|off>
Default is on.

--include_virtual_input_pin_timing_in_bottom_up_scripts=<on|off>
Default is on.

--include_virtual_output_pin_timing_in_bottom_up_scripts=<on|off>
Default is on.

--include_virtual_pin_locations_in_bottom_up_scripts=<on|off>
Default is on.

--include_logiclock_regions_in_bottom_up_scripts=<on|off>
Default is on.

--include_all_logiclock_regions_in_bottom_up_scripts=<on|off>
Default is on.

--include_global_signal_promotion_in_bottom_up_scripts=<on|off>
Default is off.

--include_pin_locations_in_bottom_up_scripts=<on|off>
Default is on.

--include_timing_assignments_in_bottom_up_scripts=<on|off>
Default is on.

--include_design_partitions_in_bottom_up_scripts=<on|off>
Default is on.

--remove_existing_regions_in_bottom_up_scripts=<on|off>
Default is on.

--disable_auto_global_promotion_in_bottom_up_scripts=<on|off>
Default is off.

--bottom_up_scripts_output_directory=<output_directory>
Default is current project directory.

--bottom_up_scripts_virtual_input_pin_delay=<delay_in_ns>
No default.  Must provide if including virtual input pin timing.

--bottom_up_scripts_virtual_output_pin_delay=<delay_in_ns>
No default.  Must provide if including virtual output pin timing.

</GENERATE_BOTTOM_UP_SCRIPTS>

<INCLUDE_MAKEFILES_WITH_BOTTOM_UP_SCRIPTS>

Option to generate makefiles for lower-level projects in addition
to the Tcl scripts. One makefile is generated for each lower-level
project, for the top-level project and for the overall design (known 
as the master_makefile). The master makefile simply invokes all other 
makefiles.

Makefiles are designed to work with GNU make and support the '-j' 
option which allows parallel compilation of the lower-level projects. 
The master makefile is all that needs to be called by the user to 
ensure the lower-level projects are up to date and that the top-level 
project has imported the latest versions of the lower-level projects. 
You can invoke the master makefile as follows (you must not turn off
--include_project_creation_in_bottom_up_scripts for this to work without 
modification):

gnumake -f master_makefile.mak -j2 
<The '-j2' means there are 2 processors to use.>

Makefiles are placed in the directory of the project they control if 
project creation is enabled and appropriate directories are automatically 
filled in. If you elect not to have the tool create projects for you, 
all makefiles are placed in the specified output directory and the user 
must fill in the directory variables at the top of each makefile so that 
the tool knows where the lower-level projects can be found. In both cases
you must add the source file dependencies for each lower-level project's 
makefile if maintainance of the project after initial compilation is 
desired. By default no dependencies are created (other than one on the 
auto-generated Tcl script for that partition) and so after the first c
ompilation, the rule is be up to date.

By default, makefile generation is enabled. Add the flag
--include_makefiles_with_bottom_up_scripts=off to disable.

</INCLUDE_MAKEFILES_WITH_BOTTOM_UP_SCRIPTS>

<INCLUDE_PROJECT_CREATION_IN_BOTTOM_UP_SCRIPTS>

When this option is enabled, generated Tcl scripts contain commands to 
create the lower-level projects if the projects do not exist. The tool 
creates projects in subdirectories under the output directory, named 
according to name of the corresponding partition.

By default, project creation is enabled. Add the flag 
--include_project_creation_in_bottom_up_scripts=off to disable.

</INCLUDE_PROJECT_CREATION_IN_BOTTOM_UP_SCRIPTS>

<INCLUDE_VIRTUAL_PINS_IN_BOTTOM_UP_SCRIPTS>

When enabled, this means that generated Tcl scripts contain commands to 
mark all lower-level pins that connect to other design entities in the 
top-level (i.e. not directly to IOs) as virtual pins. This helps
prevent overuse of IOs and leads to a more accurate representation
of the lower-level project.

This option is enabled by default. Add the flag 
--include_virtual_pins_in_bottom_up_scripts=off to disable.

</INCLUDE_VIRTUAL_PINS_IN_BOTTOM_UP_SCRIPTS>

<INCLUDE_VIRTUAL_INPUT_PIN_TIMING_IN_BOTTOM_UP_SCRIPTS>
When this option is enabled, generated Tcl scripts contain INPUT_MAX_DELAY 
to constrain all paths to the newly created virtual input pins (see 
--include_virtual_pins_in_bottom_up_scripts). The value for this option
is the inter-partition delay of paths driving the virtual inputs. For more 
information about the meaning of these	assignments, please see the 
Quartus II Help topics relating to INPUT_MAX_DELAY.  

The option is ignored if --include_virtual_pins_in_bottom_up_scripts=off 
is used.

If you use this option, you must also specify the delay (in nanoseconds) 
to be used in the constraints with the 
--bottom_up_scripts_virtual_input_pin_delay option.

This option is enabled by default. Add the flag 
--include_virtual_input_pin_timing_in_bottom_up_scripts=off to disable.
</INCLUDE_VIRTUAL_INPUT_PIN_TIMING_IN_BOTTOM_UP_SCRIPTS>

<INCLUDE_VIRTUAL_OUTPUT_PIN_TIMING_IN_BOTTOM_UP_SCRIPTS>

When this option is enabled, generated Tcl scripts contain 
OUTPUT_MAX_DELAY to constrain all paths to the newly created virtual output 
pins (see --include_virtual_pins_in_bottom_up_scripts). Specify the 
inter-partition delay seen by paths driven by the virtual outputs. 
For more information about the meaning of these	assignments, please see the 
Quartus II Help topics relating to OUTPUT_MAX_DELAY.  

The option is ignored if --include_virtual_pins_in_bottom_up_scripts=off 
is used.	

If you use this option, you must also specify the delay (in nanoseconds) 
to be used in the constraints with the 
--bottom_up_scripts_virtual_output_pin_delay=<delay> command.

This option is enabled by default. Add the flag 
--include_virtual_output_pin_timing_in_bottom_up_scripts=off to disable.

</INCLUDE_VIRTUAL_OUTPUT_PIN_TIMING_IN_BOTTOM_UP_SCRIPTS>

<INCLUDE_VIRTUAL_PIN_LOCATIONS_IN_BOTTOM_UP_SCRIPTS>

When this option is enabled, generated Tcl scripts contain location constraints 
on newly created virtual pins  (see --include_virtual_pins_in_bottom_up_scripts). 
The pins are locked to their top-level source (for input pins) or sink (for 
output pins) location.

The option is ignored if --include_virtual_pins_in_bottom_up_scripts=off 
is used.

This option is enabled by default. Add the flag
--include_virtual_pin_locations_in_bottom_up_scripts=off to disable.

</INCLUDE_VIRTUAL_PIN_LOCATIONS_IN_BOTTOM_UP_SCRIPTS>

<INCLUDE_LOGICLOCK_REGIONS_IN_BOTTOM_UP_SCRIPTS>

When this option is enabled, generated Tcl scripts contain the top-level 
LogicLock regions associated with this partition. This helps ensure the 
lower-level project places its logic where the top-level project expects it.

This option is enabled by default. Add the flag 
--include_logiclock_regions_in_bottom_up_scripts=off to disable.

</INCLUDE_LOGICLOCK_REGIONS_IN_BOTTOM_UP_SCRIPTS>

<INCLUDE_ALL_LOGICLOCK_REGIONS_IN_BOTTOM_UP_SCRIPTS>

When this option is enabled, every generated Tcl script contains all 
of the top-level LogicLock regions. Regions with logic not associated 
with the script's target partition act as placeholders and are empty. 
This command helps describes for the lower-level project the way it 
fits into the final, top-level design.

The option is ignored if --include_logiclock_regions_in_bottom_up_scripts=off 
is used.

This option is enabled by default. Add the flag
--include_all_logiclock_regions_in_bottom_up_scripts=off to disable.

</INCLUDE_ALL_LOGICLOCK_REGIONS_IN_BOTTOM_UP_SCRIPTS>

<INCLUDE_GLOBAL_SIGNAL_PROMOTION_IN_BOTTOM_UP_SCRIPTS>

When this option is enabled, generated Tcl scripts contain commands 
that force any signals promoted to 'global' in the top-level to be 
promoted in the lower-level.

This option is enabled by default. Add the flag
--include_global_signal_promotion_in_bottom_up_scripts=off to disable.

</INCLUDE_GLOBAL_SIGNAL_PROMOTION_IN_BOTTOM_UP_SCRIPTS>

<INCLUDE_PIN_LOCATIONS_IN_BOTTOM_UP_SCRIPTS>

When this option is enabled, generated Tcl scripts contain commands that 
lock any lower-level pins connected directly to IOs in the top-level to the 
IO location they were placed at in the top-level. This helps keep a 
consistent pin placement amongst projects.

This option is enabled by default. Add the flag
--include_pin_locations_in_bottom_up_scripts=off to disable.

</INCLUDE_PIN_LOCATIONS_IN_BOTTOM_UP_SCRIPTS>

<INCLUDE_TIMING_ASSIGNMENTS_IN_BOTTOM_UP_SCRIPTS>

When this option is enabled, generated Tcl scripts contain all relevant 
timing assignments from the top-level.

This option is enabled by default. Add the flag
--include_timing_assignments_in_bottom_up_scripts=off to disable.

</INCLUDE_TIMING_ASSIGNMENTS_IN_BOTTOM_UP_SCRIPTS>

<INCLUDE_DESIGN_PARTITIONS_IN_BOTTOM_UP_SCRIPTS>

When this option is enabled, generated Tcl scripts contain all relevant 
design partition assignments from the top-level.

This option is enabled by default. Add the flag
--include_design_partitions_in_bottom_up_scripts=off to disable.

</INCLUDE_DESIGN_PARTITIONS_IN_BOTTOM_UP_SCRIPTS>

<REMOVE_EXISTING_REGIONS_IN_BOTTOM_UP_SCRIPTS>

When this option is enabled, generated Tcl scripts contain commands 
that remove any LogicLock regions that exist in the project the script 
is being called within.

This option is enabled by default. Add the flag 
--remove_existing_regions_in_bottom_up_scripts=off to disable.

</REMOVE_EXISTING_REGIONS_IN_BOTTOM_UP_SCRIPTS>

<DISABLE_AUTO_GLOBAL_PROMOTION_IN_BOTTOM_UP_SCRIPTS>

When this option is enabled, generated Tcl scripts contain commands that 
disable auto global signal promotion in the lower levels.

This option is enabled by default. Add the flag 
--disable_auto_global_promotion_in_bottom_up_scripts=off to disable.

</DISABLE_AUTO_GLOBAL_PROMOTION_IN_BOTTOM_UP_SCRIPTS>

<BOTTOM_UP_SCRIPTS_OUTPUT_DIRECTORY>

Specifies the output directory for scripts and makefiles.  If none 
is set, the project directory is used by default.

</BOTTOM_UP_SCRIPTS_OUTPUT_DIRECTORY>

<BOTTOM_UP_SCRIPTS_VIRTUAL_INPUT_PIN_DELAY>

Specifies a delay, in nanoseconds, used to constrain all paths from 
any of the newly created virtual input pins in the lower-levels.  
This is to help guide the lower-level placement and produce a better 
quality top-level result.

The value represents the maximum acceptable delay for an inter-partition 
signal to arrive at the project's virtual input pin from another module. 
The value helps guide lower-level placement.

</BOTTOM_UP_SCRIPTS_VIRTUAL_INPUT_PIN_DELAY>

<BOTTOM_UP_SCRIPTS_VIRTUAL_OUTPUT_PIN_DELAY>

Specifies a delay, in nanoseconds, used to constrain all paths
to any newly created virtual output pins in the lower-levels.  
This helps guide the lower-level placement and produces a better 
quality top-level result.

The value represents the maximum acceptable delay for an inter-partition 
signal driven by the virtual output pin to arrive at its destination.
The value helps guide lower-level placement.

</BOTTOM_UP_SCRIPTS_VIRTUAL_OUTPUT_PIN_DELAY>

<MIF_DEPENDENCY>
Run the Memory Initialization File dependency check script.

    If your design has RAM without a Memory Initialization File,
then the Memory Initialization File dependency script creates 
an extra revision called <rev_name>_mif_dependency with the 
ASM option (use checkerboard pattern) turned on to ensure that 
the design has no initialization dependency.

------
Usage:
------

	quartus_cdb <project> -c <current FPGA revision> --mif_dependency=mif_check

	quartus_cdb <project> -c <current FPGA revision> --mif_dependency=cleanup

---------
Examples:
---------

	## Run Analysis & Synthesis  for Stratix II revision
	quartus_map myproject -c myfpga

                ## Run Fitter for Stratix II revision
                quartus_fit myproject -c myfpga

      	        ## Run MIF Dependency Check for Stratix II revision
	quartus_cdb myproject -c myfpga --mif_dependency=mif_check

	## Run MIF Dependency Check cleanup for Stratix II revision
	quartus_cdb myproject -c myfpga --mif_dependency=cleanup

</MIF_DEPENDENCY>

<GENERATE_HC_PLL_DELAY>
Returns the PLL annotated delay.

Ggenerates the PLL annotated delay for both commercial and industrial 
speed grades of HardCopy devices. This option only returns the PLL 
annotated delay and does not update the collection.sdc file.

------
Usage:
------

	quartus_cdb <project> -c <current Hardcopy revision> --generate_hc_pll_delay

    	---------
Examples:
---------

	## Run TimeQuest for HardCopy revision
	quartus_sta myproject -c myproject_hcii

        ## Write the PLL Annotated Delay for either Commercial or Industry Device             
	quartus_cdb myproject -c myproject_hcii --generate_hc_pll_delay

    
</GENERATE_HC_PLL_DELAY>

