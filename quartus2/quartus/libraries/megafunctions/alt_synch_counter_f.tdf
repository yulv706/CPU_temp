----------------------------------------------------------------------------------------------------
-- ALT_SYNCH_COUNTER parameterized Megafunction
--
--  Copyright 1991-2009 Corporation  
--  Your use of Altera Corporation's design tools, logic functions  
--  and other software and tools, and its AMPP partner logic  
--  functions, and any output files from any of the foregoing  
--  (including device programming or simulation files), and any  
--  associated documentation or information are expressly subject  
--  to the terms and conditions of the Altera Program License  
--  Subscription Agreement, Altera MegaCore Function License  
--  Agreement, or other applicable license agreement, including,  
--  without limitation, that your use is for the sole purpose of  
--  programming logic devices manufactured by Altera and sold by  
--  Altera or its authorized distributors.  Please refer to the  
--  applicable agreement for further details. 
--  
--  9.0 Build 184  03/01/2009   
--
-- This module implements the synchronous side of the counter (and some of the asynchronous cases
-- which allow for tricks to increase their speed)
-- This module is meant to only be called from LPM_COUNTER.  Use outside of LPM_COUNTER can lead
-- to incorrect results (since assertions are being bypassed and several cases cannot be handled
-- by this module correctly -> carry chains wont be disabled, eneable will be implemented with
-- carry chains, etc. )

--  Copyright 1991-2009 Corporation  
--  Your use of Altera Corporation's design tools, logic functions  
--  and other software and tools, and its AMPP partner logic  
--  functions, and any output files from any of the foregoing  
--  (including device programming or simulation files), and any  
--  associated documentation or information are expressly subject  
--  to the terms and conditions of the Altera Program License  
--  Subscription Agreement, Altera MegaCore Function License  
--  Agreement, or other applicable license agreement, including,  
--  without limitation, that your use is for the sole purpose of  
--  programming logic devices manufactured by Altera and sold by  
--  Altera or its authorized distributors.  Please refer to the  
--  applicable agreement for further details. 
--  
--  9.0 Build 184  03/01/2009   
-----------------------------------------------------------------------------------------------------

-- declare the lcell's
INCLUDE "flex6k_lcell";

-- lpm's which there is a dependancy on
INCLUDE "lpm_constant";
INCLUDE "lpm_compare";

-- this will be necessary for most cases of asynchronous signals
INCLUDE "alt_asynch_counter_f";

-- need global parameter information
INCLUDE "aglobal90";

PARAMETERS
(
	LPM_WIDTH,
	LPM_DIRECTION			=	"DEFAULT",
	LPM_MODULUS				=	0,
	LPM_SVALUE				=	0,
	LPM_AVALUE				=	0,
	CARRY_CHAIN				=	"IGNORE",
	CASCADE_CHAIN_LENGTH,						-- GLOBAL PARAMETER	--> For Altera internal use only
	CARRY_CHAIN_LENGTH,							-- GLOBAL PARAMETER --> For Altera internal use only
	DEVICE_FAMILY								-- GLOBAL PARAMETER --> For Altera internal use only
);

%**********%
%* MACROS *%
%**********%

-- need to use the large circuit to construct the asynchronous section
-- only do this when the user needs an aload or when cannot use something fancy to implement the aconst or aset
-- with a normal not-gate-pushback
DEFINE NEED_BIG_ASYNCH_CIRCUIT() = ((USED(aconst) # USED(aset)) & ((NEED_ACLR() # NEED_SCLR()) # !REALLY_USING_ASYNCH_PUSHBACK())) # USED(aload);

-- the value of the y-th bit of x  --> zero indexed
DEFINE CONST_VAL(x, y) = y < 31 ? 	( FLOOR(x DIV 2^y) - 2 * FLOOR(x DIV 2^(y + 1))) :
									(y == 31 ? FLOOR(x DIV 2^31) :
												0);

-- could we use a pushback to handle the asynchronous controls?
DEFINE USING_ASYNCH_PUSHBACK() = (USED(aconst) # USED(aset)) & !NEED_SCLR() & !NEED_ACLR();-- & !TRIVIAL_AVALUE();

-- could we use a pushback to handle the synchronous controls?
-- disable this option for now since it casues power up to LPM_SVALUE
DEFINE USING_SYNCH_PUSHBACK() = (1 == 0); --(USED(sconst) # USED(sset)) & !NEED_ACLR() & !NEED_SCLR() & !TRIVIAL_SVALUE();

-- will the asynchronous controls actually be handled with a not-gate-pushback?
DEFINE REALLY_USING_ASYNCH_PUSHBACK() = USING_ASYNCH_PUSHBACK() & USING_PUSHBACK();

-- will the synchronous controls actually be handled with a not-gate-pushback?
DEFINE REALLY_USING_SYNCH_PUSHBACK() = USING_SYNCH_PUSHBACK() & USING_PUSHBACK();

-- will any not-gate-pushback be used at all in this circuit?
DEFINE USING_PUSHBACK() = (USING_ASYNCH_PUSHBACK() $ USING_SYNCH_PUSHBACK()) # (USING_ASYNCH_PUSHBACK() & (AVALUE_ACTUAL() == SVALUE_ACTUAL()));

-- the argument to CONST_VAL --> this will select whether to feed it AVALUE or SVALUE
DEFINE CONST_VAL_ARGUMENT() = REALLY_USING_SYNCH_PUSHBACK() ? SVALUE_ACTUAL() : AVALUE_ACTUAL();

-- will a not-gate-pushback be inserted at the a-th bit of the counter  --> zero indexed
DEFINE INSERT_PUSHBACK(a) = (USING_PUSHBACK() & ((!USED(LPM_AVALUE)% # LPM_AVALUE == 0%) # (CONST_VAL(CONST_VAL_ARGUMENT(), a) == 1)));

-- is a divisible by b?
DEFINE DIVISIBLE_BY(a, b) = FLOOR( a MOD b) == 0;

-- is this a trivial modulus (i.e. we can ignore it)
DEFINE NON_TRIVIAL_MODULUS() = (USED(LPM_MODULUS) & (LPM_MODULUS != 0) & (LPM_MODULUS < (2^LPM_WIDTH)));

-- what is the actual AVALUE that will be implemented
DEFINE AVALUE_ACTUAL() = LPM_AVALUE;

-- what is the actual SVALUE that will be implemented
DEFINE SVALUE_ACTUAL() = LPM_SVALUE;

-- the AVALUE the user entered is trivial and may be safely ignored
DEFINE TRIVIAL_AVALUE() = !USED(LPM_AVALUE);

-- the svalue the user entered is trivial and may be safely ignored
DEFINE TRIVIAL_SVALUE() = !USED(LPM_SVALUE);

-- need to add an extra cell to load the LSB
DEFINE NEED_LOW_LOADER() = (USED(cin) & USED(updown) & USED(cnt_en)) # (USED(cin) & NON_TRIVIAL_MODULUS()) # (USED(cin) & USED(cnt_en) & NEED_LUT_ENA_EMU()) # (USED(cin) & USED(updown) & SIMPLE_ENA_EMU());

-- is the counter the user specified capable of ever counting up?
DEFINE CAPABLE_OF_UP() = USED(updown) # LPM_DIRECTION == "UP" # !USED(LPM_DIRECTION) # LPM_DIRECTION == "DEFAULT";

-- is the counter the user specified capable of ever counting down?
DEFINE CAPABLE_OF_DOWN() = USED(updown) # LPM_DIRECTION == "DOWN";

-- is there a need for an extra cell to handle the cout?
DEFINE NEED_HIGH_COUT() = USED(cout) & NON_TRIVIAL_MODULUS() & CAPABLE_OF_UP();

-- number of cells on the chain that are before the counter cells
DEFINE PRE_COUNT() = -(NEED_LOW_CARRY() + NEED_LOW_LOADER());

-- nubmer of cells on the chain that are after the counter cells
DEFINE POST_COUNT() = NEED_HIGH_COUT() ? 1 : 0;

-- there are more stages after the x-th
DEFINE NEED_MORE_STAGES(x) = x + 1 < LPM_WIDTH + POST_COUNT();

-- recursive helper function which will calculate how many continuous carry hcains have passed before this one
DEFINE CHAIN_SO_FAR(x) = x == 0 ? PRE_COUNT() : (((CHAIN_SO_FAR(x - 1) < CARRY_CHAIN_LENGTH & !NEED_MORE_STAGES(x))
												# (CHAIN_SO_FAR(x - 1) + 1 < CARRY_CHAIN_LENGTH)) 
													? CHAIN_SO_FAR(x - 1) + 1
													: 0);

-- do we need to break the chain here to meet the user specified carry chain limit
DEFINE BREAK_CHAIN_HERE(x) = (x != 0) & ((PRE_COUNT() + x * LCELL_PER_WORKER()) MOD CARRY_CHAIN_LENGTH) < LCELL_PER_WORKER() & NEED_MORE_STAGES(x);

-- recursive function to calculate the number of carry chain breaks in this counter
DEFINE CARRY_BREAKS(x) = x == 0 ? 0 : CARRY_BREAKS(x) + (BREAK_CHAIN_HERE(x) ? 1 : 0);

-- counter is forced to count up
DEFINE DOING_UP_COUNT() = LPM_DIRECTION == "UP" # LPM_DIRECTION == "DEFAULT";

-- counter is locked at counting down
DEFINE DOING_DOWN_COUNT() = LPM_DIRECTION == "DOWN";

-- there will be no user-specified loading done in this counter
DEFINE IGNORE_LOAD() = (!USED(data) # (!USED(aload) & !USED(sload))) & !NEED_MODULUS_MUX();

-- we need a mux to load the modulus on a down count
-- so that on a count to 0 we may jump to the modulus
DEFINE NEED_MODULUS_MUX() = CAPABLE_OF_DOWN() & NON_TRIVIAL_MODULUS();

-- will the aclr register port be used on any of the counter cells?
DEFINE NEED_ACLR() = USED(aclr);

-- will the sclr port of the lcell be used on any of the counter cells?
DEFINE NEED_SCLR() = USED(sclr) # (CAPABLE_OF_UP() & NON_TRIVIAL_MODULUS());

-- will implement sset or sconst through the load port
DEFINE SYNCH_THROUGH_LOAD_PORT() = (USED(sset) # USED(sconst)) & !REALLY_USING_SYNCH_PUSHBACK();

-- will implement asset or aconst through the load port
-- This is currently not supported on APEX hardware but may be in future devices
-- so it is disabled
DEFINE ASYNCH_THROUGH_LOAD_PORT() = USED(aset) & !USED(aset);	-- i.e. permanently disabled

-- will the load port be used at all?
DEFINE USING_LOAD_PORT() = !IGNORE_LOAD() # SYNCH_THROUGH_LOAD_PORT() # ASYNCH_THROUGH_LOAD_PORT();

-- do we need an equality check for an up count and a non-trivial modulus
DEFINE NEED_EQUALITY_CHECK() = CAPABLE_OF_UP() & NON_TRIVIAL_MODULUS();

-- do we need to emulate clk_en in lcell if .ena is not supported by the device
DEFINE NEED_LUT_ENA_EMU() = ((FAMILY_FLEX6000() == 1) & (USED(cnt_en) # USED(clk_en)) & USED(cout));

-- do we need a low carry cell in case one LE cell cannot fit all the required input signal
DEFINE NEED_LOW_CARRY() = NEED_LUT_ENA_EMU() & (USED(updown) & (NEED_LOW_LOADER() # USED(cnt_en) # USED(cin)) );

-- do we need any worker carry to support updown pin when clock_enable emulation is selected
DEFINE NEED_WORKER_CARRY() = NEED_LUT_ENA_EMU() & USED(updown);

-- return the number of lcell require to construct a worker cell
DEFINE LCELL_PER_WORKER() = NEED_WORKER_CARRY() ? 2 : 1;

-- is it doable using simple emulation circuitry rather than the complicated clk_en emulation in LUT?
DEFINE SIMPLE_ENA_EMU() = !NEED_LUT_ENA_EMU() & FAMILY_FLEX6000() == 1 & USED(clk_en);

DEFINE CNT_EN_THRU_LUT() = NEED_LUT_ENA_EMU() & USED(cnt_en);


%*******************************************************%
--------------------------------------------------------
-- LUT MASKS --> complete hand-wire of the counter chain
---------------------------------------------------------
%*******************************************************%
-- BEGIN MASK DECLARATIONS
	%*****%
	% LOW %
	%*****%
	-- low cells w/ quick register feedback (in other words there is no cin to worry about)
	-- this is the fastest case
	-- so if a cin is unneeded do NOT connect it
	-------------------------------------------
	CONSTANT LOW_QUICK_FEEDBACK_NO_PUSHBACK			=		"5A82";
	CONSTANT LOW_QUICK_FEEDBACK_YES_PUSHBACK		=		"5A28";
	CONSTANT LOW_FEEDBACK_MODE						=		"QFBK_COUNTER";

	-- LUT masks for clock enable emulation
	CONSTANT LOW_QUICK_FEEDBACK_UP_ENA_EMU			=		"78A0";
	CONSTANT LOW_QUICK_FEEDBACK_DOWN_ENA_EMU		=		"780A";
	CONSTANT LOW_QUICK_FEEDBACK_ENA_EMU_NO_PUSHBACK = LPM_DIRECTION != "DOWN" ? LOW_QUICK_FEEDBACK_UP_ENA_EMU : LOW_QUICK_FEEDBACK_DOWN_ENA_EMU;
	CONSTANT LOW_QUICK_FEEDBACK_ENA_EMU_YES_PUSHBACK = LPM_DIRECTION != "DOWN" ? LOW_QUICK_FEEDBACK_DOWN_ENA_EMU : LOW_QUICK_FEEDBACK_UP_ENA_EMU;

	CONSTANT LOW_QFBK_UPDOWN_ENA_EMU_NO_PUSHBACK	=		"3CA5";
	CONSTANT LOW_QFBK_UPDOWN_ENA_EMU_YES_PUSHBACK	=		"3C5A";
	CONSTANT LOW_QFBK_SUM_ENA_EMU					=		"78AA";

	CONSTANT LOW_QFBK_DOWN_ENA_EMU					=		"3C0F";
	CONSTANT LOW_QFBK_UP_ENA_EMU					=		"3CF0";
	CONSTANT LOW_QFBK_ENA_EMU_NO_PUSHBACK = LPM_DIRECTION != "DOWN" ? LOW_QFBK_UP_ENA_EMU : LOW_QFBK_DOWN_ENA_EMU;
	CONSTANT LOW_QFBK_ENA_EMU_YES_PUSHBACK = LPM_DIRECTION != "DOWN" ? LOW_QFBK_DOWN_ENA_EMU : LOW_QFBK_UP_ENA_EMU;


	-- now for the carry-in cases
	-----------------------------
	-- this is a feeder for the ugly case of user asking for cin, updown, and cnt_en
	-- we are thus forced to declare an extra cell and suffer its delay since there
	-- are no more inputs left to squeeze these into
	DEFINE LOW_CELL_FEEDER()						=		CNT_EN_THRU_LUT() ? "C0F0" : "C0C0";
	CONSTANT LOW_CELL_FEEDER_MODE					=		"ARITHMETIC";

	-- low cells with a cin, but at least there is no need to add a cell delay
	-- to the chain, since we just barely fit into the cell
	------------
	CONSTANT LOW_UPDOWN_NO_PUSHBACK					=		"5A90";
	CONSTANT LOW_UPDOWN_NO_PUSHBACK_MODE			=		"COUNTER";
	CONSTANT LOW_UPDOWN_YES_PUSHBACK				=		"5A60";
	CONSTANT LOW_UPDOWN_YES_PUSHBACK_MODE			=		"COUNTER";

	CONSTANT LOW_ENABLE_UP_NO_PUSHBACK				=		"6A80";
	CONSTANT LOW_ENABLE_UP_NO_PUSHBACK_MODE			=		"COUNTER";
	CONSTANT LOW_ENABLE_UP_YES_PUSHBACK				=		"6A40";
	CONSTANT LOW_ENABLE_UP_YES_PUSHBACK_MODE		=		"COUNTER";

	CONSTANT LOW_ENABLE_DOWN_NO_PUSHBACK			=		"6A40";
	CONSTANT LOW_ENABLE_DOWN_NO_PUSHBACK_MODE		=		"COUNTER";
	CONSTANT LOW_ENABLE_DOWN_YES_PUSHBACK			=		"6A80";
	CONSTANT LOW_ENABLE_DOWN_YES_PUSHBACK_MODE		=		"COUNTER";

	-- LUT masks for clock enable emulation
	CONSTANT LOW_UP_ENA_EMU							=		"6AA0";
	CONSTANT LOW_DOWN_ENA_EMU						=		"6A50";
	CONSTANT LOW_UP_ENA_EMU_NO_PUSHBACK				=		LOW_UP_ENA_EMU;
	CONSTANT LOW_UP_ENA_EMU_NO_PUSHBACK_MODE		=		"COUNTER";
	CONSTANT LOW_UP_ENA_EMU_YES_PUSHBACK			=		LOW_DOWN_ENA_EMU;
	CONSTANT LOW_UP_ENA_EMU_YES_PUSHBACK_MODE		=		"COUNTER";
	CONSTANT LOW_DOWN_ENA_EMU_NO_PUSHBACK			=		LOW_DOWN_ENA_EMU;
	CONSTANT LOW_DOWN_ENA_EMU_NO_PUSHBACK_MODE		=		"COUNTER";
	CONSTANT LOW_DOWN_ENA_EMU_YES_PUSHBACK			=		LOW_UP_ENA_EMU;
	CONSTANT LOW_DOWN_ENA_EMU_YES_PUSHBACK_MODE		=		"COUNTER";

	CONSTANT LOW_SUM_ENA_EMU						=		"6AF0";
	CONSTANT LOW_SUM_ENA_EMU_MODE					=		"COUNTER";
	CONSTANT LOW_CARRY_UPDOWN_NO_PUSHBACK		=		"0090";
	CONSTANT LOW_CARRY_UPDOWN_NO_PUSHBACK_MODE	=		"ARITHMETIC";
	CONSTANT LOW_CARRY_UPDOWN_YES_PUSHBACK		=		"0060";
	CONSTANT LOW_CARRY_UPDOWN_YES_PUSHBACK_MODE	=		"ARITHMETIC";
	CONSTANT LOW_CARRY_UPDOWN_MODE				=		"ARITHMETIC";

	%***********************%
	% INTERMEDIATE COUNTERS %
	%***********************%
	CONSTANT WORKER_NO_PUSHBACK						=		"5A90";
	CONSTANT WORKER_NO_PUSHBACK_MODE				=		"COUNTER";
	CONSTANT WORKER_YES_PUSHBACK					=		"5A60";
	CONSTANT WORKER_YES_PUSHBACK_MODE				=		"COUNTER";

	-- LUT masks for clock enable emulation
	CONSTANT WORKER_UP_ENA_EMU						=		"6AA0";
	CONSTANT WORKER_DOWN_ENA_EMU					=		"6A50";
	CONSTANT WORKER_ENA_EMU_NO_PUSHBACK = LPM_DIRECTION != "DOWN" ? WORKER_UP_ENA_EMU : WORKER_DOWN_ENA_EMU;
	CONSTANT WORKER_ENA_EMU_NO_PUSHBACK_MODE		=		"COUNTER";
	CONSTANT WORKER_ENA_EMU_YES_PUSHBACK = LPM_DIRECTION != "DOWN" ? WORKER_DOWN_ENA_EMU : WORKER_UP_ENA_EMU;
	CONSTANT WORKER_ENA_EMU_YES_PUSHBACK_MODE		=		"COUNTER";

	CONSTANT WORKER_SUM_ENA_EMU						=		"6AF0";
	CONSTANT WORKER_SUM_ENA_EMU_MODE				=		"COUNTER";
	CONSTANT WORKER_CARRY_UPDOWN_NO_PUSHBACK		=		"0090";
	CONSTANT WORKER_CARRY_UPDOWN_NO_PUSHBACK_MODE	=		"ARITHMETIC";
	CONSTANT WORKER_CARRY_UPDOWN_YES_PUSHBACK		=		"0060";
	CONSTANT WORKER_CARRY_UPDOWN_YES_PUSHBACK_MODE	=		"ARITHMETIC";
	CONSTANT WORKER_CARRY_UPDOWN_MODE				=		"ARITHMETIC";

	%***************%
	% CHAIN BREAKER %
	%***************%
	CONSTANT CHAIN_BREAKER							=		"F000";
	CONSTANT CHAIN_BREAKER_MODE						=		"ARITHMETIC";

	%****************************%
	% INTERMEDIATE CHAIN STARTER %
	%****************************%
	-- use quick feedback as a trick to get an extra control line
	-- this allows for the chain break to use 1 cell delay as opposed to 2
	CONSTANT CHAIN_STARTER_NO_PUSHBACK				=		"5A82";
	CONSTANT CHAIN_STARTER_NO_PUSHBACK_MODE			=		"QFBK_COUNTER";
	CONSTANT CHAIN_STARTER_YES_PUSHBACK				=		"5A28";
	CONSTANT CHAIN_STARTER_YES_PUSHBACK_MODE		=		"QFBK_COUNTER";

	-- LUT masks for clock enable emulation
	CONSTANT CHAIN_STARTER_UP_ENA_EMU				=		"78A0";
	CONSTANT CHAIN_STARTER_DOWN_ENA_EMU				=		"780A";
	CONSTANT CHAIN_STARTER_ENA_EMU_NO_PUSHBACK = LPM_DIRECTION != "DOWN" ? CHAIN_STARTER_UP_ENA_EMU : CHAIN_STARTER_DOWN_ENA_EMU;
	CONSTANT CHAIN_STARTER_ENA_EMU_NO_PUSHBACK_MODE = "QFBK_COUNTER";
	CONSTANT CHAIN_STARTER_ENA_EMU_YES_PUSHBACK = LPM_DIRECTION != "DOWN" ? CHAIN_STARTER_DOWN_ENA_EMU : CHAIN_STARTER_UP_ENA_EMU;
	CONSTANT CHAIN_STARTER_ENA_EMU_YES_PUSHBACK_MODE = "QFBK_COUNTER";

	CONSTANT CHAIN_STARTER_SUM_ENA_EMU				=		"78AA";
	CONSTANT CHAIN_STARTER_SUM_ENA_EMU_MODE			=		"QFBK_COUNTER";
	CONSTANT CHAIN_STARTER_CARRY_UPDOWN_NO_PUSHBACK		=		"0090";
	CONSTANT CHAIN_STARTER_CARRY_UPDOWN_YES_PUSHBACK		=		"0060";
	CONSTANT CHAIN_STARTER_CARRY_UPDOWN_MODE				=		"ARITHMETIC";


	%**************%
	%* COUT CELL  *%
	%**************%
	-- this is the cell that will receive the cout and send it out
	CONSTANT COUT_CELL								=		"F8F8";
	CONSTANT COUT_CELL_MODE							=		"ARITHMETIC";
	-- special case where cout is not sent to the 'cout' of the port
	-- we can thus use an optimazation to reduce the propogation delay
	CONSTANT SPEEDY_COUT							=		"BA00";
	CONSTANT SPEEDY_COUT_MODE						=		"NORMAL";
% END OF MASK DECLARATIONS %

SUBDESIGN alt_synch_counter_f (
	data[LPM_WIDTH - 1..0]	 	: INPUT = GND;
	clock						: INPUT;
	clk_en						: INPUT = VCC;
	cnt_en						: INPUT = VCC;
	updown						: INPUT = VCC;
	cin							: INPUT;		-- no default value

	-- synchronous input control signals
	sload						: INPUT = GND;
	sclr						: INPUT = GND;
	sset						: INPUT = GND;
	sconst						: INPUT = GND;

	-- asynchronous input control signals
	aload						: INPUT = GND;
	aset						: INPUT = GND;
	aconst						: INPUT = GND;
	aclr						: INPUT = GND;

	-- outputs
	q[LPM_WIDTH - 1..0] 		: OUTPUT;
	cout						: OUTPUT;

)

VARIABLE
	-- ====================================================
	--		APEX20K/20KE and FLEX6000 style family cases
	-- ====================================================

	-- this will be the fastest case
	IF !NEED_BIG_ASYNCH_CIRCUIT() GENERATE
		local_cout	:	NODE;
		-- declare the LSB circuitry
		IF NEED_LOW_LOADER() GENERATE
			IF FAMILY_FLEX6000() == 1 GENERATE
				low_feeder	:	flex6k_lcell
							WITH	(LUT_MASK		=	LOW_CELL_FEEDER(),
									 OPERATION_MODE	=	LOW_CELL_FEEDER_MODE
									);
				IF NEED_LUT_ENA_EMU() GENERATE
					-- check whether the updown port is used
					IF NEED_LOW_CARRY() GENERATE
						lsb :	flex6k_lcell
									WITH	(LUT_MASK		=	WORKER_SUM_ENA_EMU,
											 OPERATION_MODE	=	WORKER_SUM_ENA_EMU_MODE
											);
						low_carry :	flex6k_lcell
									WITH	(LUT_MASK		=	INSERT_PUSHBACK(0) ? LOW_CARRY_UPDOWN_YES_PUSHBACK : LOW_CARRY_UPDOWN_NO_PUSHBACK,
											 OPERATION_MODE	=	INSERT_PUSHBACK(0) ? LOW_CARRY_UPDOWN_YES_PUSHBACK_MODE : LOW_CARRY_UPDOWN_NO_PUSHBACK_MODE
											);
					ELSE GENERATE
						lsb :	flex6k_lcell
									WITH	(LUT_MASK		=	INSERT_PUSHBACK(0) ? WORKER_ENA_EMU_YES_PUSHBACK : WORKER_ENA_EMU_NO_PUSHBACK,
											 OPERATION_MODE	=	INSERT_PUSHBACK(0) ? WORKER_ENA_EMU_YES_PUSHBACK_MODE : WORKER_ENA_EMU_NO_PUSHBACK_MODE
											);
					END GENERATE;
				ELSE GENERATE
					lsb	:	flex6k_lcell WITH	(
								LUT_MASK		=		INSERT_PUSHBACK(0) ? WORKER_YES_PUSHBACK : WORKER_NO_PUSHBACK,
								OPERATION_MODE	=		INSERT_PUSHBACK(0) ? WORKER_YES_PUSHBACK_MODE : WORKER_NO_PUSHBACK_MODE
								);
				END GENERATE;
			END GENERATE;
		ELSE GENERATE
			IF USED(cin) GENERATE					-- using a cin but there is no need to add a cell delay
				IF !USED(updown) GENERATE			-- gain a cell input by not using the updown port
					IF LPM_DIRECTION != "DOWN" GENERATE

						IF FAMILY_FLEX6000() == 1 GENERATE
							IF NEED_LUT_ENA_EMU()  GENERATE
								lsb : flex6k_lcell
									WITH	(LUT_MASK		=	INSERT_PUSHBACK(0) ? LOW_UP_ENA_EMU_YES_PUSHBACK : LOW_UP_ENA_EMU_NO_PUSHBACK,
											 OPERATION_MODE	=	INSERT_PUSHBACK(0) ? LOW_UP_ENA_EMU_YES_PUSHBACK_MODE : LOW_UP_ENA_EMU_NO_PUSHBACK_MODE
											);
							ELSE GENERATE
								lsb : flex6k_lcell
										WITH	(LUT_MASK		=	INSERT_PUSHBACK(0) ? LOW_ENABLE_UP_YES_PUSHBACK : LOW_ENABLE_UP_NO_PUSHBACK,
												 OPERATION_MODE	=	INSERT_PUSHBACK(0) ? LOW_ENABLE_UP_YES_PUSHBACK_MODE : LOW_ENABLE_UP_NO_PUSHBACK_MODE
												);
							END GENERATE;
						END GENERATE;
					ELSE % Counting down % GENERATE
						IF FAMILY_FLEX6000() == 1 GENERATE
							IF NEED_LUT_ENA_EMU()  GENERATE
								lsb : flex6k_lcell
									WITH	(LUT_MASK		=	INSERT_PUSHBACK(0) ? LOW_DOWN_ENA_EMU_YES_PUSHBACK : LOW_DOWN_ENA_EMU_NO_PUSHBACK, 
											 OPERATION_MODE	=	INSERT_PUSHBACK(0) ? LOW_DOWN_ENA_EMU_YES_PUSHBACK_MODE : LOW_DOWN_ENA_EMU_NO_PUSHBACK_MODE
											);
							ELSE GENERATE
								lsb : flex6k_lcell
										WITH	(LUT_MASK		=	INSERT_PUSHBACK(0) ? LOW_ENABLE_DOWN_YES_PUSHBACK : LOW_ENABLE_DOWN_NO_PUSHBACK,
												 OPERATION_MODE	=	INSERT_PUSHBACK(0) ? LOW_ENABLE_DOWN_YES_PUSHBACK_MODE : LOW_ENABLE_DOWN_NO_PUSHBACK_MODE
												);
							END GENERATE;
						END GENERATE;
					END GENERATE;
				ELSE % USED(updown) --> not USED(cnt_en) % GENERATE
					IF FAMILY_FLEX6000() == 1 GENERATE
						-- check whether clock enable emulation is required
						IF NEED_LOW_CARRY() GENERATE
							lsb : flex6k_lcell
								WITH	(LUT_MASK		=	LOW_SUM_ENA_EMU,
										 OPERATION_MODE	=	LOW_SUM_ENA_EMU_MODE
										);
							low_carry : flex6k_lcell
								WITH	(LUT_MASK		=	INSERT_PUSHBACK(0) ? LOW_CARRY_UPDOWN_YES_PUSHBACK : LOW_CARRY_UPDOWN_NO_PUSHBACK,
										 OPERATION_MODE	=	INSERT_PUSHBACK(0) ? LOW_CARRY_UPDOWN_YES_PUSHBACK_MODE : LOW_CARRY_UPDOWN_NO_PUSHBACK_MODE
										);
						ELSE %assume clk_en emulation is not required% GENERATE
							lsb : flex6k_lcell
									WITH	(LUT_MASK		=	!INSERT_PUSHBACK(0) ? LOW_UPDOWN_NO_PUSHBACK : LOW_UPDOWN_YES_PUSHBACK,
											 OPERATION_MODE	=	!INSERT_PUSHBACK(0) ? LOW_UPDOWN_NO_PUSHBACK_MODE : LOW_UPDOWN_YES_PUSHBACK_MODE
											);
						END GENERATE;
					END GENERATE;
				END GENERATE;
			ELSE % !USED(cin) % GENERATE
				-- can use qfbk mode counter
				IF FAMILY_FLEX6000() == 1 GENERATE
					IF NEED_LUT_ENA_EMU() GENERATE
						-- IF USED(updown) & USED(cnt_en)
						IF NEED_LOW_CARRY() GENERATE
							lsb : flex6k_lcell
								WITH	(LUT_MASK		=	LOW_QFBK_SUM_ENA_EMU,
										 OPERATION_MODE	=	LOW_FEEDBACK_MODE
										);
							low_carry : flex6k_lcell
								WITH	(LUT_MASK		=	INSERT_PUSHBACK(0) ? LOW_CARRY_UPDOWN_YES_PUSHBACK : LOW_CARRY_UPDOWN_NO_PUSHBACK,
										 OPERATION_MODE	=	INSERT_PUSHBACK(0) ? LOW_CARRY_UPDOWN_YES_PUSHBACK_MODE : LOW_CARRY_UPDOWN_NO_PUSHBACK_MODE
										);
						ELSE GENERATE
							IF USED(cnt_en) GENERATE
								lsb : flex6k_lcell
									WITH	(LUT_MASK		=	INSERT_PUSHBACK(0) ? LOW_QUICK_FEEDBACK_ENA_EMU_YES_PUSHBACK : LOW_QUICK_FEEDBACK_ENA_EMU_NO_PUSHBACK,
											 OPERATION_MODE	=	LOW_FEEDBACK_MODE
											);
							ELSE GENERATE
								IF USED(updown) GENERATE
									lsb : flex6k_lcell
										WITH	(LUT_MASK		=	INSERT_PUSHBACK(0) ? LOW_QFBK_UPDOWN_ENA_EMU_YES_PUSHBACK : LOW_QFBK_UPDOWN_ENA_EMU_NO_PUSHBACK,
												 OPERATION_MODE	=	LOW_FEEDBACK_MODE
												);
								ELSE GENERATE
									lsb : flex6k_lcell
										WITH	(LUT_MASK		=	INSERT_PUSHBACK(0) ? LOW_QFBK_ENA_EMU_YES_PUSHBACK : LOW_QFBK_ENA_EMU_NO_PUSHBACK,
												 OPERATION_MODE	=	LOW_FEEDBACK_MODE
												);
								END GENERATE;
							END GENERATE;
						END GENERATE;
					ELSE GENERATE
						lsb	:	flex6k_lcell
							WITH	(
									LUT_MASK		=	INSERT_PUSHBACK(0) ? LOW_QUICK_FEEDBACK_YES_PUSHBACK : LOW_QUICK_FEEDBACK_NO_PUSHBACK,
									OPERATION_MODE	=	LOW_FEEDBACK_MODE
									);

					END GENERATE;
				END GENERATE;
			END GENERATE;
		END GENERATE;

		-- the value to place on the dedicated load pin
		-- asynchronous paths
		IF ASYNCH_THROUGH_LOAD_PORT() GENERATE
			aset_path[LPM_WIDTH - 1..0] 				: NODE;
		END GENERATE;
		aload_path[LPM_WIDTH - 1..0]					: NODE;
		-- synchronous paths
		IF SYNCH_THROUGH_LOAD_PORT() GENERATE
			sset_path[LPM_WIDTH - 1..0]					: NODE;
		END GENERATE;
		sload_path[LPM_WIDTH - 1..0]					: NODE;

		IF ASYNCH_THROUGH_LOAD_PORT() GENERATE
			aval_value[LPM_WIDTH - 1..0] : NODE;
		END GENERATE;

		IF SYNCH_THROUGH_LOAD_PORT() GENERATE
			sval_value[LPM_WIDTH - 1..0] : NODE;
		END GENERATE;

		IF LPM_WIDTH > 1 % which it probably will be % GENERATE
			the_carries[LPM_WIDTH..1] : NODE;		-- these will be used to hold the carries
			pre_out[LPM_WIDTH - 1..1]  : NODE;		-- these will be used to hold the preliminary outputs
		END GENERATE;
		
		IF NEED_EQUALITY_CHECK() # (NEED_HIGH_COUT() # (CAPABLE_OF_DOWN() & NON_TRIVIAL_MODULUS())) GENERATE
			time_to_clear	:	NODE;
		END GENERATE;
		
		aclr_actual		:	NODE;
		sclr_actual		:	NODE;
		sload_actual	:	NODE;
		updown_actual	:	NODE;
		cnt_en_ena_emu	:	NODE;
		clk_en_ena_emu	:	NODE;

		-- internal routings before the actual sload and sclr.
		pre_sload : NODE;
		pre_sclr : NODE;

		IF NON_TRIVIAL_MODULUS() & CAPABLE_OF_DOWN()  & USED(cout) GENERATE
			not_borrow	:	NODE;
		END GENERATE;

		IF NON_TRIVIAL_MODULUS() GENERATE
			modulus_bus[LPM_WIDTH - 1..0] : NODE;
		END GENERATE;

		dedicated_load[LPM_WIDTH - 1..0] 				: NODE;

		IF NEED_HIGH_COUT() # (USED(cout) & CAPABLE_OF_UP() & NON_TRIVIAL_MODULUS())
			# (CAPABLE_OF_DOWN() & NON_TRIVIAL_MODULUS()) GENERATE

			IF FAMILY_APEX20K() == 1 GENERATE
				the_cout	: apex20k_lcell	WITH	(
													LUT_MASK		=	USED(cout)? 	COUT_CELL
																				  :		SPEEDY_COUT,
													OPERATION_MODE	=	USED(cout)?		COUT_CELL_MODE
																				  :		SPEEDY_COUT_MODE
													);
			ELSE GENERATE
			IF FAMILY_FLEX6000() == 1 GENERATE -- no change for FLEX6000's cout mask
				the_cout	: flex6k_lcell WITH	(
													LUT_MASK		=	USED(cout)? 	COUT_CELL
																				  :		SPEEDY_COUT,
													OPERATION_MODE	=	USED(cout)?		COUT_CELL_MODE
																				  :		SPEEDY_COUT_MODE
													);
			ELSE GENERATE
				the_cout	: apex20ke_lcell WITH	(
													LUT_MASK		=	USED(cout)?		COUT_CELL
																				  :		SPEEDY_COUT,
													OPERATION_MODE	=	USED(cout)?		COUT_CELL_MODE
																				  :		SPEEDY_COUT_MODE
													);
			END GENERATE; END GENERATE;
		END GENERATE;

		-- Create internal nodes to link-up the carry chain between the worker and its carry cell.
		IF NEED_WORKER_CARRY() GENERATE
			sum_cout [LPM_WIDTH-1..0] : NODE;
		END GENERATE;

	ELSE GENERATE
		asynch_counter : alt_asynch_counter_f WITH	(
														LPM_WIDTH = LPM_WIDTH,
														LPM_DIRECTION = LPM_DIRECTION,
														LPM_MODULUS = LPM_MODULUS,
														LPM_AVALUE = USED(LPM_AVALUE) ? LPM_AVALUE : "UNUSED",
														LPM_SVALUE = USED(LPM_SVALUE) ? LPM_SVALUE : "UNUSED"
													);
	END GENERATE;

BEGIN
	%**************************************%
	%*	Beginning of the code block		  *%
	%**************************************%
	IF !NEED_BIG_ASYNCH_CIRCUIT() GENERATE
	-- hopefully this is the path that will be taken
	-- since it is the fastest case
		IF NEED_LOW_LOADER() GENERATE
			local_cout = low_feeder.combout;
		ELSE GENERATE
			local_cout = VCC;	-- always enabled
		END GENERATE;

		%******************************%
		%* modulus bus initialization *%
		%******************************%
		IF NON_TRIVIAL_MODULUS() GENERATE
			modulus_bus[] = lpm_constant()	WITH
											(
											LPM_WIDTH = LPM_WIDTH,
											LPM_CVALUE = LPM_MODULUS - 1
											)
											RETURNS (
													.result[]
													);
		END GENERATE;

		%*******************************************%
		%* value for equality check to modulus - 1 *%
		%*******************************************%
		IF NEED_EQUALITY_CHECK() GENERATE
			time_to_clear = local_cout & lpm_compare (	.dataa[] = q[],
											.datab[] = modulus_bus[])
										WITH (
																	LPM_WIDTH = LPM_WIDTH,
																	ONE_INPUT_IS_CONSTANT = "YES"
																)
																RETURNS
																(
																	.aeb
																);
		ELSE GENERATE
			IF NEED_HIGH_COUT() # (CAPABLE_OF_DOWN() & NON_TRIVIAL_MODULUS()) GENERATE
				time_to_clear = GND;
			END GENERATE;
		END GENERATE;

		%*************************************%
		%* Dedicated load circuitry			 *%
		%*************************************%

		-- set up the constant values if they are needed
		IF SYNCH_THROUGH_LOAD_PORT() GENERATE
			IF !TRIVIAL_SVALUE() GENERATE
				sval_value[] = lpm_constant() 	WITH	(
															LPM_WIDTH = LPM_WIDTH,
															LPM_CVALUE = LPM_SVALUE
														)
												RETURNS	(
															.result[]
														);
			ELSE GENERATE
				sval_value[] = VCC;
			END GENERATE;
		END GENERATE;

		IF ASYNCH_THROUGH_LOAD_PORT() GENERATE
			aval_value[] = lpm_constant()	WITH	(
														LPM_WIDTH = LPM_WIDTH,
														LPM_CVALUE = AVALUE_ACTUAL()
													)
												RETURNS	(
														.result[]
														);
		END GENERATE;

		-- set up path multiplexers and let sythesis chop away all the unneeded signals
		IF NON_TRIVIAL_MODULUS() & CAPABLE_OF_DOWN() GENERATE
			sload_path[] = (sload & data[]) # (!sload & modulus_bus[]);
		ELSE GENERATE
			sload_path[] = data[];
		END GENERATE;

		IF SYNCH_THROUGH_LOAD_PORT() GENERATE
			sset_path[] = ((sset # sconst) & sval_value[]) # ((sset !# sconst) & sload_path[]);
			aload_path[] = (aload & data[]) # (!aload & sset_path[]);
		ELSE GENERATE
			aload_path[] = sload_path[];
		END GENERATE;

		IF ASYNCH_THROUGH_LOAD_PORT() GENERATE
			aset_path[] = ((aset # aconst) & aval_value[]) # ((aset !# aconst) & aload_path[]);

			FOR i IN 0 TO LPM_WIDTH - 1 GENERATE
				IF INSERT_PUSHBACK(i) GENERATE
					dedicated_load[i] = !aconst_path[i];
				ELSE GENERATE
					dedicated_load[i] = aconst_path[i];
				END GENERATE;
			END GENERATE;
		ELSE GENERATE
			FOR i IN 0 TO LPM_WIDTH - 1 GENERATE
				IF INSERT_PUSHBACK(i) GENERATE
					dedicated_load[i] = !aload_path[i];
				ELSE GENERATE
					dedicated_load[i] = aload_path[i];
				END GENERATE;
			END GENERATE;
		END GENERATE;

		%********************%
		%* Control Signals	*%
		%********************%
		-- set up the aclr
		IF REALLY_USING_ASYNCH_PUSHBACK() GENERATE
			aclr_actual = aclr # aset # aconst;
		ELSE GENERATE
			aclr_actual = aclr;
		END GENERATE;

		-- Check whether clock enable emulation is possible through a simpler circuitry.
		-- If it is possible, it could be lcells saver.
		IF SIMPLE_ENA_EMU() GENERATE
			cnt_en_ena_emu = clk_en & cnt_en;
		ELSE GENERATE
			IF CNT_EN_THRU_LUT() GENERATE
				cnt_en_ena_emu = VCC;
			ELSE GENERATE
				cnt_en_ena_emu = cnt_en;
			END GENERATE;
		END GENERATE;

		IF CNT_EN_THRU_LUT() GENERATE
			clk_en_ena_emu = clk_en & cnt_en;
		ELSE GENERATE
			clk_en_ena_emu = clk_en; 
		END GENERATE;

		-- updown control signal
		IF USED(updown) GENERATE
			updown_actual = updown;
		ELSE GENERATE
			IF USED(LPM_DIRECTION) GENERATE
				IF LPM_DIRECTION == "DOWN" GENERATE
					updown_actual = GND;
				ELSE GENERATE
					updown_actual = VCC;
				END GENERATE;
			ELSE GENERATE
				updown_actual = VCC;
			END GENERATE;
		END GENERATE;

		-- set up the sclr
		IF NEED_EQUALITY_CHECK() GENERATE
			IF REALLY_USING_SYNCH_PUSHBACK() GENERATE
				-- most of this logic will be knocked off by the synthesizer... except in the unlikely event that someone is
				-- actually using all of these signals
				pre_sclr	= (sclr # sconst # sset # (!(sload # sset # sconst) & local_cout & time_to_clear & updown_actual & cnt_en))
								;-- & !(aclr # aset # aconst # aload);
			ELSE GENERATE
				pre_sclr = (sclr # (!(sload # sset # sconst) & updown_actual & time_to_clear & local_cout & cnt_en))
								;-- & !(aclr # aset # aconst # aload);
			END GENERATE;
		ELSE GENERATE
			IF REALLY_USING_SYNCH_PUSHBACK() GENERATE
				pre_sclr = (sclr # sset # sconst);-- & !(aclr # aload # aset # aconst);
			ELSE GENERATE
				pre_sclr = sclr;-- & !aclr & !aset & !aconst & !aload;
			END GENERATE;
		END GENERATE;

		-- set up the sload
		IF NON_TRIVIAL_MODULUS() & CAPABLE_OF_DOWN() GENERATE
			IF USED(cout) GENERATE
				-- again, most of this logic will be knocked off by the synthesizer
				IF REALLY_USING_SYNCH_PUSHBACK() GENERATE
					pre_sload = (sload # (cnt_en & !updown_actual & not_borrow)) & 
									!sclr & !sconst & !sset & !aclr & !aset & !aconst & !aload;
				ELSE GENERATE
					pre_sload = (sload # sset # sconst # (local_cout & cnt_en & !updown_actual & not_borrow)) 
								   & !sclr & !aclr & !aset & !aconst & !aload;
				END GENERATE;
			ELSE GENERATE
				-- everything is faster and simpler without the cout
				pre_sload = (sload # sset # sconst # (the_cout.combout & !updown_actual & cnt_en & local_cout)) &
								!sclr & !aclr & !aset & !aconst & !aload;
			END GENERATE;
		ELSE GENERATE
			IF REALLY_USING_SYNCH_PUSHBACK() GENERATE
				pre_sload = sload & !sclr & !sset & !sconst & !aclr & !aconst & !aset;
			ELSE GENERATE
				pre_sload = (sload # sconst # sset) & !aclr & !aset & !aconst & !aload;
			END GENERATE;
		END GENERATE;

		IF FAMILY_FLEX6000() == 1 & USED(clk_en) GENERATE
			-- forbid synchronous control signals from affecting LCELLs when clk_en is de-asserted.
			sclr_actual = pre_sclr & clk_en;
			sload_actual = pre_sload & clk_en;
		ELSE GENERATE
			sclr_actual = pre_sclr;
			sload_actual = pre_sload;
		END GENERATE;

		%******************************%
		%* Counter Chain Construction *%
		%******************************%
		-- cycle through all the stages and make the proper connections
		FOR i IN 0 TO LPM_WIDTH - 1 GENERATE
			-- handle the LSB in a special way
			IF i == 0 GENERATE
				lsb.clk = clock;
				lsb.aclr = aclr_actual;
				lsb.sclr = sclr_actual;
				lsb.sload = sload_actual;
				IF NEED_LUT_ENA_EMU() GENERATE
					lsb.datab = clk_en_ena_emu;
				ELSE GENERATE
					IF FAMILY_FLEX6000() != 1 GENERATE
						lsb.ena = clk_en_ena_emu;
					END GENERATE;
				END GENERATE;

				IF USED(cin) GENERATE
					IF NEED_LOW_LOADER() GENERATE
						-- set up the feeder
						low_feeder.cin = cin;
						low_feeder.datab = cnt_en_ena_emu;

						lsb.cin = low_feeder.cout;
						IF NEED_LUT_ENA_EMU() GENERATE
							IF NEED_LOW_CARRY() GENERATE
								low_carry.datab = updown_actual;
								low_carry.cin = lsb.cout;
								low_carry.dataa = lsb.regout;
							END GENERATE;
						ELSE GENERATE
							lsb.datab = updown_actual;
						END GENERATE;
					ELSE GENERATE
						lsb.cin = cin;
						IF !USED(updown) GENERATE
							IF !NEED_LUT_ENA_EMU() GENERATE
								lsb.datab = cnt_en_ena_emu;
							END GENERATE;
						ELSE % assume it is updown being used % GENERATE
							IF NEED_LOW_CARRY() GENERATE
								low_carry.datab = updown_actual;
								low_carry.dataa = lsb.regout;
								low_carry.cin = lsb.cout;
							ELSE % assume !NEED_LUT_ENA_EMU()% GENERATE
								lsb.datab = updown_actual;
							END GENERATE;
						END GENERATE;
					END GENERATE;
					
					-- hook up the feedback
					lsb.dataa = lsb.regout;

				ELSE % using quick feedback mode %GENERATE
					IF NEED_LUT_ENA_EMU() GENERATE

						-- check if updown and cnt_en are being used.
						IF NEED_LOW_CARRY() GENERATE
							low_carry.dataa = lsb.regout;
							low_carry.datab = updown_actual;
							low_carry.cin = lsb.cout;
							IF CNT_EN_THRU_LUT() GENERATE
								lsb.dataa = VCC;
							ELSE GENERATE
								lsb.dataa = cnt_en;
							END GENERATE;
						ELSE GENERATE
							IF USED(cnt_en) GENERATE
								IF CNT_EN_THRU_LUT() GENERATE
									lsb.dataa = VCC;
								ELSE GENERATE
									lsb.dataa = cnt_en;
								END GENERATE;
							ELSE GENERATE
								IF USED(updown) GENERATE
									lsb.dataa = updown_actual;
								END GENERATE;
							END GENERATE;
						END GENERATE;
					ELSE GENERATE
						lsb.datab = updown_actual;
						lsb.dataa = cnt_en_ena_emu;
					END GENERATE;	

				END GENERATE;
				
				-- set the output
				IF INSERT_PUSHBACK(0) GENERATE
					q[0] = !lsb.regout;
				ELSE GENERATE
					q[0] = lsb.regout;
				END GENERATE;

				-- set the dedicated load input to the lcell
				lsb.datac = dedicated_load[0];

				IF NEED_MORE_STAGES(0) GENERATE
					IF NEED_LOW_CARRY() GENERATE
						the_carries[1] = low_carry.cout;
					ELSE GENERATE
						the_carries[1] = lsb.cout;
					END GENERATE;
				END GENERATE;
			ELSE % not the lsb % GENERATE
				-- declare a cell and set up its inputs and outputs
				IF !BREAK_CHAIN_HERE(i) GENERATE
				-- there will be no chain breaker at this stage
					IF FAMILY_FLEX6000() == 1 GENERATE
						IF NEED_LUT_ENA_EMU() GENERATE
							IF NEED_WORKER_CARRY() GENERATE
								(pre_out[i], sum_cout[i]) = flex6k_lcell 	(
													.dataa	=	pre_out[i],			-- register feedback
													.datab	=	clk_en_ena_emu,
													.datac	=	dedicated_load[i],
													.cin	=	the_carries[i],
													.clk	=	clock,
													.aclr	=	aclr_actual,
													.sclr	=	sclr_actual,
													.sload	=	sload_actual
													)
													WITH
													(
													LUT_MASK	=	WORKER_SUM_ENA_EMU,
													OPERATION_MODE	=	WORKER_SUM_ENA_EMU_MODE
													)
													RETURNS
													(
													.regout,
													.cout
													);
								(the_carries[i + 1]) = flex6k_lcell 	(
													.dataa	=	pre_out[i],			-- register feedback
													.datab	=	updown_actual,
													.cin	=	sum_cout[i]
													)
													WITH
													(
													LUT_MASK	=	INSERT_PUSHBACK(i)	? WORKER_CARRY_UPDOWN_YES_PUSHBACK : WORKER_CARRY_UPDOWN_NO_PUSHBACK,
													OPERATION_MODE	=	WORKER_CARRY_UPDOWN_MODE
													)
													RETURNS
													(.cout);
							ELSE GENERATE
								(pre_out[i], the_carries[i + 1]) = flex6k_lcell 	(
													.dataa	=	pre_out[i],			-- register feedback
													.datab	=	clk_en_ena_emu,
													.datac	=	dedicated_load[i],
													.cin	=	the_carries[i],
													.clk	=	clock,
													.aclr	=	aclr_actual,
													.sclr	=	sclr_actual,
													.sload	=	sload_actual
													)
													WITH
													(
													LUT_MASK	=	INSERT_PUSHBACK(i)	? WORKER_ENA_EMU_YES_PUSHBACK : WORKER_ENA_EMU_NO_PUSHBACK,
													OPERATION_MODE	=	INSERT_PUSHBACK(i)  ? WORKER_YES_PUSHBACK_MODE : WORKER_NO_PUSHBACK_MODE
													)
													RETURNS
													(
													.regout,
													.cout
													);
							END GENERATE;
						ELSE GENERATE %no clk_en emulation%
								(pre_out[i], the_carries[i + 1]) = flex6k_lcell 	(
													.dataa	=	pre_out[i],			-- register feedback
													.datab	=	updown_actual,
													.datac	=	dedicated_load[i],
													.cin	=	the_carries[i],
													.clk	=	clock,
													.aclr	=	aclr_actual,
													.sclr	=	sclr_actual,
													.sload	=	sload_actual
													)
													WITH
													(
													LUT_MASK	=	INSERT_PUSHBACK(i)	? WORKER_YES_PUSHBACK : WORKER_NO_PUSHBACK,
													OPERATION_MODE	=	INSERT_PUSHBACK(i)  ? WORKER_YES_PUSHBACK_MODE : WORKER_NO_PUSHBACK_MODE
													)
													RETURNS
													(
													.regout,
													.cout
													);
						END GENERATE;
					END GENERATE;
				ELSE GENERATE
				-- Need to insert a chain break to meet user's compiler settings
				-- This entails having the previous cout go to a chain breaker cell
				-- with the output feeding a chain starter from the normal chip
				-- routing.  For example, dataa is receiving the cin from the
				-- normal routing.
					IF FAMILY_FLEX6000() == 1 GENERATE
						IF NEED_LUT_ENA_EMU() GENERATE
							IF NEED_WORKER_CARRY() GENERATE
								(pre_out[i], sum_cout[i]) = flex6k_lcell 	(
													.datab	=	clk_en_ena_emu,
													.datac	=	dedicated_load[i],
													.dataa	=	flex6k_lcell	(.cin = the_carries[i])
														WITH
														(
														LUT_MASK		= CHAIN_BREAKER,
														OPERATION_MODE	= CHAIN_BREAKER_MODE
														)
														RETURNS
														(
														.combout
														),
													.clk	=	clock,
													.aclr	=	aclr_actual,
													.sclr	=	sclr_actual,
													.sload	=	sload_actual
													)
													WITH
													(
													LUT_MASK	=	CHAIN_STARTER_SUM_ENA_EMU,
													OPERATION_MODE	=	CHAIN_STARTER_SUM_ENA_EMU_MODE
													)
													RETURNS
													(
													.regout,
													.cout
													);
									(the_carries[i + 1]) = flex6k_lcell 	(
														.datab	=	updown_actual,
														.dataa	=	pre_out[i],
														.cin	= 	sum_cout[i]
														)
														WITH
														(
														LUT_MASK	=	INSERT_PUSHBACK(i) ? CHAIN_STARTER_CARRY_UPDOWN_YES_PUSHBACK : CHAIN_STARTER_CARRY_UPDOWN_NO_PUSHBACK,
														OPERATION_MODE	=	CHAIN_STARTER_CARRY_UPDOWN_MODE
														)
														RETURNS
														(.cout);
							ELSE %!used(updown)% GENERATE
								(pre_out[i], the_carries[i + 1]) = flex6k_lcell 	(
													.datab	=	clk_en_ena_emu,
													.datac	=	dedicated_load[i],
													.dataa	=	flex6k_lcell	(.cin = the_carries[i])
														WITH
														(
														LUT_MASK		= CHAIN_BREAKER,
														OPERATION_MODE	= CHAIN_BREAKER_MODE
														)
														RETURNS
														(
														.combout
														),
													.clk	=	clock,
													.aclr	=	aclr_actual,
													.sclr	=	sclr_actual,
													.sload	=	sload_actual
													)
													WITH
													(
													LUT_MASK	=	INSERT_PUSHBACK(i)	? CHAIN_STARTER_ENA_EMU_YES_PUSHBACK : CHAIN_STARTER_ENA_EMU_NO_PUSHBACK,
													OPERATION_MODE	=	INSERT_PUSHBACK(i)	? CHAIN_STARTER_YES_PUSHBACK_MODE :	CHAIN_STARTER_NO_PUSHBACK_MODE
													)
													RETURNS
													(
													.regout,
													.cout
													);
							END GENERATE;
						ELSE GENERATE %no clk_en emulation%
								(pre_out[i], the_carries[i + 1]) = flex6k_lcell 	(
													.datab	=	updown_actual,
													.datac	=	dedicated_load[i],
													.dataa	=	flex6k_lcell	(.cin = the_carries[i])
														WITH
														(
														LUT_MASK		= CHAIN_BREAKER,
														OPERATION_MODE	= CHAIN_BREAKER_MODE
														)
														RETURNS
														(
														.combout
														),
													.clk	=	clock,
													.aclr	=	aclr_actual,
													.sclr	=	sclr_actual,
													.sload	=	sload_actual
													)
													WITH
													(
													LUT_MASK	=	INSERT_PUSHBACK(i)	? CHAIN_STARTER_YES_PUSHBACK : CHAIN_STARTER_NO_PUSHBACK,
													OPERATION_MODE	=	INSERT_PUSHBACK(i)	? CHAIN_STARTER_YES_PUSHBACK_MODE : CHAIN_STARTER_NO_PUSHBACK_MODE
													)
													RETURNS
													(
													.regout,
													.cout
													);

						END GENERATE;
					END GENERATE;
				END GENERATE;
			END GENERATE;   									% END of conditional for i == 0 %

			-- invert an output iff using the pushback
			IF INSERT_PUSHBACK(i) & (i != 0) GENERATE
				q[i] = !pre_out[i];
			ELSE GENERATE
				IF i != 0 GENERATE
					q[i] = pre_out[i];
				END GENERATE;
			END GENERATE;
		END GENERATE;											% END of FOR Loop %

		-- circuitry for returning a cout to the user
		IF NEED_HIGH_COUT() # (USED(cout) & NON_TRIVIAL_MODULUS() & CAPABLE_OF_DOWN()) 
			# (NON_TRIVIAL_MODULUS() & CAPABLE_OF_DOWN()) GENERATE
			IF USED(cout) GENERATE
				IF LPM_WIDTH > 1 GENERATE
					the_cout.cin = the_carries[LPM_WIDTH];
				ELSE GENERATE
					IF NEED_LOW_CARRY() GENERATE
						the_cout.cin = low_carry.cout;
					ELSE GENERATE
						the_cout.cin = lsb.cout;
					END GENERATE;
				END GENERATE;

				the_cout.dataa = updown_actual;

				IF NON_TRIVIAL_MODULUS() & CAPABLE_OF_DOWN() GENERATE
					not_borrow = the_cout.combout;
				END GENERATE;

				the_cout.datab = time_to_clear ;
				cout = the_cout.cout;

			ELSE GENERATE
				-- hook up the cell
				IF !REALLY_USING_SYNCH_PUSHBACK() GENERATE
					the_cout.dataa = sload # sset # sconst;
					the_cout.datad = !sclr & !aclr & !aset & !aconst & !aload;
				ELSE GENERATE
					the_cout.dataa = sload;
					the_cout.datad = !sclr & !sset & !sconst & !aclr & !aset & !aconst & !aload;
				END GENERATE;
				the_cout.datab = updown_actual;
				
				-- hook up the cin
				IF LPM_WIDTH > 1 GENERATE
					the_cout.cin = the_carries[LPM_WIDTH];
				ELSE GENERATE
					IF NEED_LOW_CARRY() GENERATE
						the_cout.cin = low_carry.cout;
					ELSE GENERATE
						the_cout.cin = lsb.cout;
					END GENERATE;
				END GENERATE;
			END GENERATE;
		ELSE GENERATE
			IF LPM_WIDTH > 1 GENERATE
				cout = the_carries[LPM_WIDTH];
			ELSE GENERATE
				IF NEED_LOW_CARRY() GENERATE
					cout = low_carry.cout;
				ELSE GENERATE
					cout = lsb.cout;
				END GENERATE;
			END GENERATE;
		END GENERATE;
	ELSE GENERATE
	-- need to connect the large counter
		IF USED(data) GENERATE
			asynch_counter.data[] = data[];
		END GENERATE;

		IF USED(clock) GENERATE
			asynch_counter.clock = clock;
		END GENERATE;

		IF USED(clk_en) GENERATE
			asynch_counter.clk_en = clk_en;
		END GENERATE;

		IF USED(cnt_en) GENERATE
			asynch_counter.cnt_en = cnt_en;
		END GENERATE;

		IF USED(updown) GENERATE
			asynch_counter.updown = updown;
		END GENERATE;

		IF USED(cin) GENERATE
			asynch_counter.cin = cin;
		END GENERATE;

		IF USED(aclr) GENERATE
			asynch_counter.aclr = aclr;
		END GENERATE;

		IF USED(aset) GENERATE
			asynch_counter.aset = aset;
		END GENERATE;

		IF USED(aconst) GENERATE
			asynch_counter.aconst = aconst;
		END GENERATE;

		IF USED(aload) GENERATE
			asynch_counter.aload = aload;
		END GENERATE;

		IF USED(sclr) GENERATE
			asynch_counter.sclr = sclr;
		END GENERATE;

		IF USED(sset) GENERATE
			asynch_counter.sset = sset;
		END GENERATE;

		IF USED(sconst) GENERATE
			asynch_counter.sconst = sconst;
		END GENERATE;

		IF USED(sload) GENERATE
			asynch_counter.sload = sload;
		END GENERATE;
		
		IF USED(cout) GENERATE
			cout = asynch_counter.cout;
		END GENERATE;
		
		q[] = asynch_counter.q[];
	END GENERATE;
	IF !USED(cout) GENERATE
		cout = GND;
	END GENERATE;
	IF !USED(q) GENERATE
		q[] = GND;
	END GENERATE;
END;
