-----------------------------------------------------------------------------------------
-- altqpram.tdf
--
-- Version 1.0
--
--  Copyright 1991-2009 Corporation  
--  Your use of Altera Corporation's design tools, logic functions  
--  and other software and tools, and its AMPP partner logic  
--  functions, and any output files from any of the foregoing  
--  (including device programming or simulation files), and any  
--  associated documentation or information are expressly subject  
--  to the terms and conditions of the Altera Program License  
--  Subscription Agreement, Altera MegaCore Function License  
--  Agreement, or other applicable license agreement, including,  
--  without limitation, that your use is for the sole purpose of  
--  programming logic devices manufactured by Altera and sold by  
--  Altera or its authorized distributors.  Please refer to the  
--  applicable agreement for further details. 
--  
--  9.0 Build 184  03/01/2009   
--
------------------------------------------------------------------------------------------

INCLUDE "mercury_ram_block";
INCLUDE "apexii_ram_block";
INCLUDE "lpm_decode";
INCLUDE "lpm_mux";
INCLUDE "aglobal90";
INCLUDE "a_rdenreg";
INCLUDE "altsyncram";

CONSTANT BITS_PER_ESB = 4096;
CONSTANT USE_DEEP = 0;
CONSTANT MAX_ADD_NO_DEEP = 12;
CONSTANT MAX_ADD_USE_DEEP = 16;
CONSTANT MAX_ADD = USE_DEEP == 0 ? MAX_ADD_NO_DEEP : MAX_ADD_USE_DEEP;
CONSTANT MAX_DEPTH_NO_BANK = 2^MAX_ADD;
CONSTANT MAX_ADD_NO_BANK = MAX_ADD;

CONSTANT CLOCK_AZ = "PORTACLOCK0";
CONSTANT CLOCK_Ao = "PORTACLOCK1";
CONSTANT CLOCK_BZ = "PORTBCLOCK0";
CONSTANT CLOCK_BO = "PORTBCLOCK1";
CONSTANT CLEAR_AZ = "PORTACLEAR0";
CONSTANT CLEAR_AO = "PORTACLEAR1";
CONSTANT CLEAR_BZ = "PORTBCLEAR0";
CONSTANT CLEAR_BO = "PORTBCLEAR1";

PARAMETERS
(
	-- mode selection parameter
	OPERATION_MODE = "QUAD_PORT",

	----------------------------
	-- port A read parameters --
	----------------------------
	WIDTH_READ_A = 1,					
	WIDTHAD_READ_A = 1,			
	NUMWORDS_READ_A = 1,		
	-- registering parameters
	RDCONTROL_REG_A = "OUTCLOCK_A",		
	RDADDRESS_REG_A = "OUTCLOCK_A",							
	OUTDATA_REG_A = "UNREGISTERED",			
	-- clearing parameters
	RDCONTROL_ACLR_A = "OUTACLR_A",	
	RDADDRESS_ACLR_A = "OUTACLR_A",						
	OUTDATA_ACLR_A = "OUTACLR_A",	

	-----------------------------
	-- port A write parameters --
	-----------------------------
	WIDTH_WRITE_A = 1,
	WIDTHAD_WRITE_A = 1,
	NUMWORDS_WRITE_A = 1,
	-- registering parameters
	INDATA_REG_A = "INCLOCK_A",
	WRCONTROL_WRADDRESS_REG_A = "INCLOCK_A",
	-- clearing parameters
	WRCONTROL_ACLR_A = "INACLR_A",			
	WRADDRESS_ACLR_A = "INACLR_A",
	INDATA_ACLR_A = "INACLR_A",

	----------------------------
	-- port B write parameter --
	----------------------------
	WIDTH_WRITE_B = 1,
	WIDTHAD_WRITE_B = 1,
	NUMWORDS_WRITE_B = 1,
	-- registering parameters
	INDATA_REG_B = "INCLOCK_B",
	WRCONTROL_WRADDRESS_REG_B = "INCLOCK_B",
	-- clearing parameters
	INDATA_ACLR_B = "INACLR_B",
	WRCONTROL_ACLR_B = "INACLR_B",		
	WRADDRESS_ACLR_B = "INACLR_B",								
											
	----------------------------
	-- Port B read parameters --
	----------------------------
	WIDTH_READ_B = 1,
	WIDTHAD_READ_B = 1,
	NUMWORDS_READ_B = 1,
	-- registering parameters
	RDCONTROL_REG_B = "OUTCLOCK_B",	
	RDADDRESS_REG_B = "OUTCLOCK_B",	
	OUTDATA_REG_B = "UNREGISTERED",
	-- clearing parameters
	OUTDATA_ACLR_B = "OUTACLR_B",	
	RDADDRESS_ACLR_B = "OUTACLR_B",
	RDCONTROL_ACLR_B = "OUTACLR_B",
	
	-- General operation parameters
	INIT_FILE = "UNUSED",			
	MAXIMUM_DEPTH = BITS_PER_ESB,
--	CASCADE_CHAIN,									
	SUPPRESS_MEMORY_CONVERSION_WARNINGS = "OFF",
	DEVICE_FAMILY											
);

---------
-- Macros
---------
-- predicate
DEFINE CLOCK_UNREG(x) = (x == "NONE") # (x == "UNUSED");
DEFINE QUAD_PORT_MODE() = OPERATION_MODE == "QUAD_PORT";			-- Quad Port Mode
DEFINE BIDIR_DUAL_MODE() = OPERATION_MODE == "BIDIR_DUAL_PORT";		-- Bidirectional Dual Port
DEFINE DUAL_PORT_MODE() = OPERATION_MODE == "DUAL_PORT";			-- Flex/Apex style Dual Port
DEFINE SINGLE_PORT_MODE() = OPERATION_MODE == "SINGLE_PORT";		-- Flex/Apex style Single Port
DEFINE ROM_MODE() = OPERATION_MODE == "ROM";						-- Flex/Apex style Rom

CONSTANT MIN_DATA_WIDTH = 1;
CONSTANT MAX_DATA_WIDTH = (BIDIR_DUAL_MODE() & (FAMILY_APEXII() == 1)) ? 8 : 16;

DEFINE WIDTH_READ_A_INT() = (SINGLE_PORT_MODE() !# BIDIR_DUAL_MODE()) ? WIDTH_READ_A : WIDTH_WRITE_A;
DEFINE WIDTHAD_READ_A_INT() = (SINGLE_PORT_MODE() !# BIDIR_DUAL_MODE()) ? WIDTHAD_READ_A : WIDTHAD_WRITE_A;
DEFINE NUMWORDS_READ_A_INT() = (SINGLE_PORT_MODE() !# BIDIR_DUAL_MODE()) ?
									(USED(NUMWORDS_READ_A) ? NUMWORDS_READ_A : 2^WIDTHAD_READ_A_INT()) : NUMWORDS_WRITE_A_INT();

DEFINE WIDTH_WRITE_A_INT() = !ROM_MODE() ? WIDTH_WRITE_A : WIDTH_READ_A_INT();
DEFINE WIDTHAD_WRITE_A_INT() = !ROM_MODE() ? WIDTHAD_WRITE_A : WIDTHAD_READ_A_INT();
DEFINE NUMWORDS_WRITE_A_INT() = !ROM_MODE() ? (USED(NUMWORDS_WRITE_A) ? NUMWORDS_WRITE_A : 2^WIDTHAD_WRITE_A_INT()) :
									NUMWORDS_READ_A_INT();

DEFINE WIDTH_READ_B_INT() = QUAD_PORT_MODE() ? WIDTH_READ_B : BIDIR_DUAL_MODE() ? WIDTH_WRITE_B : WIDTH_READ_A_INT();
DEFINE WIDTHAD_READ_B_INT() = QUAD_PORT_MODE() ? WIDTHAD_READ_B : BIDIR_DUAL_MODE() ? WIDTHAD_WRITE_B : WIDTHAD_READ_A_INT();
DEFINE NUMWORDS_READ_B_INT() = QUAD_PORT_MODE() ? (USED(NUMWORDS_READ_B) ? NUMWORDS_READ_B : 2^WIDTHAD_READ_B_INT()) :
								BIDIR_DUAL_MODE() ? NUMWORDS_WRITE_B_INT() : NUMWORDS_READ_A_INT();

DEFINE WIDTH_WRITE_B_INT() = (QUAD_PORT_MODE() # BIDIR_DUAL_MODE()) ? WIDTH_WRITE_B : WIDTH_READ_A_INT();
DEFINE WIDTHAD_WRITE_B_INT() = (QUAD_PORT_MODE() # BIDIR_DUAL_MODE()) ? WIDTHAD_WRITE_B : WIDTHAD_READ_B_INT();
DEFINE NUMWORDS_WRITE_B_INT() = (QUAD_PORT_MODE() # BIDIR_DUAL_MODE()) ?
									(USED(NUMWORDS_WRITE_B) ? NUMWORDS_WRITE_B : 2^WIDTHAD_WRITE_B_INT()) : NUMWORDS_READ_B_INT();
CONSTANT WIDTH_READ_A_ACTUAL = WIDTH_READ_A_INT();
CONSTANT NUMWORDS_READ_A_ACTUAL = NUMWORDS_READ_A_INT();
CONSTANT WIDTHAD_READ_A_ACTUAL = WIDTHAD_READ_A_INT();
CONSTANT WIDTH_READ_B_ACTUAL = WIDTH_READ_B_INT();
CONSTANT NUMWORDS_READ_B_ACTUAL = NUMWORDS_READ_B_INT();
CONSTANT WIDTHAD_READ_B_ACTUAL = WIDTHAD_READ_B_INT();
CONSTANT WIDTH_WRITE_A_ACTUAL = WIDTH_WRITE_A_INT();
CONSTANT WIDTHAD_WRITE_A_ACTUAL = WIDTHAD_WRITE_A_INT();
CONSTANT NUMWORDS_WRITE_A_ACTUAL = NUMWORDS_WRITE_A_INT();
CONSTANT WIDTH_WRITE_B_ACTUAL = WIDTH_WRITE_B_INT();
CONSTANT WIDTHAD_WRITE_B_ACTUAL = WIDTHAD_WRITE_B_INT();
CONSTANT NUMWORDS_WRITE_B_ACTUAL = NUMWORDS_WRITE_B_INT();
-- general macro
-- determines whether or not to dump the parameter values
DEFINE DUMP_PARAMETERS() = (0 == 1);
DEFINE MIN(a, b) = (a < b) ? a : b;
DEFINE MAX(a, b) = (a > b) ? a : b;

-- isolate strings for clocks
CONSTANT INCLOCK_AS = "INCLOCK_A";
CONSTANT INCLOCK_BS = "INCLOCK_B";
CONSTANT OUTCLOCK_AS = "OUTCLOCK_A";
CONSTANT OUTCLOCK_BS = "OUTCLOCK_B";

-- determine the need for a clock
DEFINE USED_WRITE_A_PORT() =	USED(wren_a) # USED(data_a) # USED(wraddress_a);
DEFINE USED_WRITE_B_PORT() =	USED(wren_b) # USED(data_b) # USED(wraddress_b);
DEFINE USED_READ_A_PORT() =		USED(rden_a) # USED(q_a) # USED(rdaddress_a);
DEFINE USED_READ_B_PORT() =		USED(rden_b) # USED(q_b) # USED(rdaddress_b);

DEFINE WRITE_A_USES_INCLOCK_A() = (INDATA_REG_A == "INCLOCK_A") # (WRCONTROL_WRADDRESS_REG_A == "INCLOCK_A");
DEFINE WRITE_B_USES_INCLOCK_B() = (INDATA_REG_B == "INCLOCK_B") # (WRCONTROL_WRADDRESS_REG_B == "INCLOCK_B");
DEFINE READ_A_USES_INCLOCK_A() = (RDCONTROL_REG_A == "INCLOCK_A") # (RDADDRESS_REG_A == "INCLOCK_A") #
									(OUTDATA_REG_A == "INCLOCK_A");
DEFINE READ_B_USES_INCLOCK_B() = (RDCONTROL_REG_B == "INCLOCK_B") # (RDADDRESS_REG_B == "INCLOCK_B") #
									(OUTDATA_REG_B == "INCLOCK_B");
DEFINE READ_A_USES_OUTCLOCK_A() = (RDCONTROL_REG_A == "OUTCLOCK_A") # (RDADDRESS_REG_A == "OUTCLOCK_A") #
									(OUTDATA_REG_A == "OUTCLOCK_A");
DEFINE READ_B_USES_OUTCLOCK_B() = (RDCONTROL_REG_B == "OUTCLOCK_B") # (RDADDRESS_REG_B == "OUTCLOCK_B") #
									(OUTDATA_REG_B == "OUTCLOCK_B");
DEFINE NEED_INCLOCK_A() =(USED_WRITE_A_PORT() & WRITE_A_USES_INCLOCK_A()) # (USED_READ_A_PORT() & READ_A_USES_INCLOCK_A());
DEFINE NEED_INCLOCK_B() = (USED_WRITE_B_PORT() & WRITE_B_USES_INCLOCK_B()) # (USED_READ_B_PORT() & READ_B_USES_INCLOCK_B());
DEFINE NEED_OUTCLOCK_A() = (USED_READ_A_PORT() & READ_A_USES_OUTCLOCK_A());
DEFINE NEED_OUTCLOCK_B() = (USED_READ_B_PORT() & READ_B_USES_OUTCLOCK_B());

-- macros for detecting valid data width differences
CONSTANT MIN_WIDTH_ENTERED = MIN( WIDTH_READ_A_ACTUAL, MIN( WIDTH_WRITE_A_ACTUAL, MIN( WIDTH_READ_B_ACTUAL, WIDTH_WRITE_B_ACTUAL)));
CONSTANT MAX_WIDTH_ENTERED = MAX( WIDTH_READ_A_ACTUAL, MAX( WIDTH_WRITE_A_ACTUAL, MAX( WIDTH_READ_B_ACTUAL, WIDTH_WRITE_B_ACTUAL)));
CONSTANT MAX_DEPTH_ENTERED = MAX( NUMWORDS_READ_A_ACTUAL, MAX( NUMWORDS_WRITE_A_ACTUAL,
									MAX( NUMWORDS_READ_B_ACTUAL, NUMWORDS_WRITE_B_ACTUAL)));
CONSTANT MIN_DEPTH_ENTERED = MIN( NUMWORDS_READ_A_ACTUAL, MIN( NUMWORDS_WRITE_A_ACTUAL,
									MIN( NUMWORDS_READ_B_ACTUAL, NUMWORDS_WRITE_B_ACTUAL)));

DEFINE MODE_CAN_USE_HALF_ESB() = QUAD_PORT_MODE() !# BIDIR_DUAL_MODE();
DEFINE WIDTH_DIVISIBLE(total_width, esb_depth) =
		(!MODE_CAN_USE_HALF_ESB() &
			(CEIL(total_width MOD FLOOR(BITS_PER_ESB DIV esb_depth)) == 0) &
			(FLOOR(BITS_PER_ESB DIV esb_depth) <= MIXED_MAX_WIDTH)) # 
		(MODE_CAN_USE_HALF_ESB() &
			(CEIL(total_width MOD FLOOR(BITS_PER_ESB DIV esb_depth)) == 0) #
			(((esb_depth != BITS_PER_ESB) & (esb_depth != 128)) &
			(CEIL(total_width MOD (2 * FLOOR(BITS_PER_ESB DIV esb_depth))) == 0) &
			((2 * FLOOR(BITS_PER_ESB DIV esb_depth)) <= MIXED_MAX_WIDTH)));
DEFINE GEN_MIXED() = GEN_MIXED_STEP(MAX_DEPTH_ENTERED, MIN_WIDTH_ENTERED, (USED(MAXIMUM_DEPTH) & MAXIMUM_DEPTH != 0	?  MAXIMUM_DEPTH 
																								: BITS_PER_ESB),
																								ABSOLUTE_MIN_DEPTH);

-- user may have entered a value for maximum depth which makes interleave impossible
-- if so, then must ignore the request and go higher depth
DEFINE GEN_MIXED_STEP(depth, width, user_max_depth, this_depth) = 
	((this_depth == user_max_depth) & WIDTH_DIVISIBLE(width, this_depth))	?	this_depth
	:	(this_depth >= BITS_PER_ESB ? BITS_PER_ESB :
		((this_depth >= depth) & WIDTH_DIVISIBLE(width, this_depth)) ? this_depth :
		GEN_MIXED_STEP(depth, width, user_max_depth, this_depth * 2));

DEFINE GEN_NO_MIXED() = GEN_NO_MIXED_H(MAX_DEPTH_ENTERED, USED(MAXIMUM_DEPTH)  & MAXIMUM_DEPTH != 0 ? MAXIMUM_DEPTH	:
																											BITS_PER_ESB,
											ABSOLUTE_MIN_DEPTH);
CONSTANT ABSOLUTE_MIN_DEPTH = (BIDIR_DUAL_MODE() !& (FAMILY_APEXII() == 1)) ? 256 : 512;

DEFINE GEN_NO_MIXED_H(depth, user_max, this_depth) =
	(this_depth == BITS_PER_ESB) ? BITS_PER_ESB :
	(this_depth == user_max) ? user_max :
	(this_depth >= depth) ? this_depth :
	GEN_NO_MIXED_H(depth, user_max, this_depth * 2);

-- making sure bit counts total correctly
DEFINE BITS_USED(WIDTH, DEPTH) = WIDTH * DEPTH;
CONSTANT BITS_USED_WRITE_PORT_A = BITS_USED(WIDTH_WRITE_A_ACTUAL, NUMWORDS_WRITE_A_ACTUAL);
CONSTANT BITS_USED_WRITE_PORT_B = BITS_USED(WIDTH_WRITE_B_ACTUAL, NUMWORDS_WRITE_B_ACTUAL);
CONSTANT BITS_USED_READ_PORT_A = BITS_USED(WIDTH_READ_A_ACTUAL, NUMWORDS_READ_A_ACTUAL);
CONSTANT BITS_USED_READ_PORT_B = BITS_USED(WIDTH_READ_B_ACTUAL, NUMWORDS_READ_B_ACTUAL);
DEFINE DEEP_LEGAL(x) = (USE_DEEP == 1) & ((x == 8192) # (x == 16384) # (x == 32768) # (x == 65536));
DEFINE LEGAL_MAXIMUM_DEPTH(x) = (x == 256) # (x == 512) # (x == 1024) # (x == 2048) # (x == 4096) # DEEP_LEGAL(x);


-- predicates
DEFINE THIS_IS_MIN_DEPTH(A) = MIN_DEPTH_ENTERED == A;
DEFINE LEGAL_POWER_RATIO(x) = (x == 1) # (x == 2) # (x == 4) # (x == 8) # ((BIDIR_DUAL_MODE() !& (FAMILY_APEXII() == 1)) & (x == 16));
-- all ratios must be integer multiples of each other and be powers of 2 and <= 16 in order to guarantee address interleave
DEFINE RATIOS_ARE_VALID(a, b) = !USING_MIXED_MODE() #
				((MIN(a, b) != 0) & LEGAL_POWER_RATIO(FLOOR(MAX(a, b) DIV MIN(a, b))));
DEFINE USING_MIXED_MODE() = MIN_WIDTH_ENTERED != MAX_WIDTH_ENTERED;

CONSTANT MIXED_MAX_WIDTH = (MAX_ADD == MAX_ADD_USE_DEEP) ? 1 : FLOOR(MAX_DATA_WIDTH DIV FLOOR(MAX_WIDTH_ENTERED DIV MIN_WIDTH_ENTERED));


-- predicates for port usage... if any input is used to a port it is assumed to be used
DEFINE WRITE_A_USED() =	USED(wren_a) # USED(data_a) # USED(wraddress_a) # USED(inclock_a) # USED(inclocken_a) #
						USED(inaclr_a);
DEFINE WRITE_B_USED() =	USED(wren_b) # USED(data_b) # USED(wraddress_b) # USED(inclock_b) # USED(inclocken_b) #
						USED(inaclr_b);
DEFINE READ_A_USED() = USED(rden_a) # USED(rdaddress_a) # USED(outclock_a) # USED(outclocken_a) # USED(outaclr_a);
DEFINE READ_B_USED() = USED(rden_b) # USED(rdaddress_b) # USED(outclock_b) # USED(outclocken_b) # USED(outaclr_b);

-- determine whether the mode is registered or unregistered
DEFINE WRCONTROL_A_REGISTERED() = WRCONTROL_WRADDRESS_REG_A != "UNREGISTERED";
DEFINE WRCONTROL_B_REGISTERED() = WRCONTROL_WRADDRESS_REG_B != "UNREGISTERED";
DEFINE INPUT_A_REGISTERED() = INDATA_REG_A != "UNREGISTERED";
DEFINE INPUT_B_REGISTERED() = INDATA_REG_B != "UNREGISTERED";
DEFINE SHARED_ADDRESS_MODE() = BIDIR_DUAL_MODE() # SINGLE_PORT_MODE();
DEFINE MODE_HAS_RDEN() = QUAD_PORT_MODE() # DUAL_PORT_MODE();
DEFINE MODE_USES_B_PORT() = QUAD_PORT_MODE() # BIDIR_DUAL_MODE();

DEFINE RDCONTROL_A_REGISTERED() = ((!SHARED_ADDRESS_MODE() & RDCONTROL_REG_A != "UNREGISTERED") #
								   (SHARED_ADDRESS_MODE() & WRCONTROL_A_REGISTERED())) & USED(rden_a);
DEFINE RDCONTROL_B_REGISTERED() = ((!SHARED_ADDRESS_MODE() & RDCONTROL_REG_B != "UNREGISTERED") #
									(SHARED_ADDRESS_MODE() & WRCONTROL_B_REGISTERED())) & USED(rden_b);
DEFINE RDADDRESS_A_REGISTERED() = (!SHARED_ADDRESS_MODE() & RDADDRESS_REG_A != "UNREGISTERED") #
									(SHARED_ADDRESS_MODE() & WRCONTROL_A_REGISTERED());
DEFINE RDADDRESS_B_REGISTERED() = (!SHARED_ADDRESS_MODE() & RDADDRESS_REG_B != "UNREGISTERED") #
									(SHARED_ADDRESS_MODE() & WRCONTROL_B_REGISTERED());
DEFINE OUTPUT_A_REGISTERED() = OUTDATA_REG_A != "UNREGISTERED";
DEFINE OUTPUT_B_REGISTERED() = OUTDATA_REG_B != "UNREGISTERED";


CONSTANT RDADDRESS_A_PARAM = RDADDRESS_REG_A;
CONSTANT RDADDRESS_B_PARAM = RDADDRESS_REG_B;
CONSTANT RDCONTROL_A_PARAM = RDCONTROL_REG_A;
CONSTANT RDCONTROL_B_PARAM = RDCONTROL_REG_B;

DEFINE NEED_EXTERNAL_ADDRESS_DECODE() = EXTERNAL_ADDRESS_BITS != 0;
CONSTANT GEN_DEPTH = ((FAMILY_APEXII() == 1) & USING_MIXED_MODE()) ? 
						(MAXIMUM_DEPTH != 0 ? MAXIMUM_DEPTH  : BITS_PER_ESB):	-- the x1 condition for mixed modes
						USING_MIXED_MODE() ? 
							GEN_MIXED() : 
							GEN_NO_MIXED();

CONSTANT ESB_SPECIFIC_DEPTH = GEN_DEPTH;
CONSTANT PRE_ESB_SPECIFIC_WIDTH = FLOOR(BITS_PER_ESB DIV GEN_DEPTH);
CONSTANT ESB_SPECIFIC_WIDTH = 	((FAMILY_APEXII() == 1) & USING_MIXED_MODE()) ?
									1 :	-- x1 condition
									FLOOR(PRE_ESB_SPECIFIC_WIDTH DIV (2^(FLOOR((PRE_ESB_SPECIFIC_WIDTH * FLOOR(MAX_WIDTH_ENTERED DIV MIN_WIDTH_ENTERED)) DIV (2*MAX_DATA_WIDTH)))));
DEFINE PORT_ESB_SPECIFIC_DEPTH(depth) = FLOOR(ESB_SPECIFIC_DEPTH DIV FLOOR(MAX_DEPTH_ENTERED DIV depth));
DEFINE PORT_ESB_SPECIFIC_WIDTH(width) = ESB_SPECIFIC_WIDTH * FLOOR(width DIV MIN_WIDTH_ENTERED);
CONSTANT WRITE_A_ESB_SPECIFIC_DEPTH = PORT_ESB_SPECIFIC_DEPTH(NUMWORDS_WRITE_A_ACTUAL);
CONSTANT WRITE_A_ESB_SPECIFIC_WIDTH = PORT_ESB_SPECIFIC_WIDTH(WIDTH_WRITE_A_ACTUAL);
CONSTANT READ_A_ESB_SPECIFIC_DEPTH = PORT_ESB_SPECIFIC_DEPTH(NUMWORDS_READ_A_ACTUAL);
CONSTANT READ_A_ESB_SPECIFIC_WIDTH = PORT_ESB_SPECIFIC_WIDTH(WIDTH_READ_A_ACTUAL);
CONSTANT WRITE_B_ESB_SPECIFIC_DEPTH = PORT_ESB_SPECIFIC_DEPTH(NUMWORDS_WRITE_B_ACTUAL);
CONSTANT WRITE_B_ESB_SPECIFIC_WIDTH = PORT_ESB_SPECIFIC_WIDTH(WIDTH_WRITE_B_ACTUAL);
CONSTANT READ_B_ESB_SPECIFIC_DEPTH = PORT_ESB_SPECIFIC_DEPTH(NUMWORDS_READ_B_ACTUAL);
CONSTANT READ_B_ESB_SPECIFIC_WIDTH = PORT_ESB_SPECIFIC_WIDTH(WIDTH_READ_B_ACTUAL);
CONSTANT LEAST_ESB_SPECIFIC_WIDTH = MIN(	WRITE_A_ESB_SPECIFIC_WIDTH, MIN( WRITE_B_ESB_SPECIFIC_WIDTH,
											MIN( READ_A_ESB_SPECIFIC_WIDTH, READ_B_ESB_SPECIFIC_WIDTH)));
-- total ESB row and column in matrix
CONSTANT ESB_ROWS = CEIL(MAX_DEPTH_ENTERED DIV ESB_SPECIFIC_DEPTH);
CONSTANT ESB_COLS = CEIL(MIN_WIDTH_ENTERED DIV ESB_SPECIFIC_WIDTH);
CONSTANT EXTERNAL_DECODES = ESB_ROWS;
CONSTANT EXTERNAL_ADDRESS_BITS = ESB_ROWS == 1 ? 0 : CEIL(LOG2(EXTERNAL_DECODES));

CONSTANT WRITE_A_ADDRESS_MOD = FLOOR(NUMWORDS_WRITE_A_ACTUAL MOD WRITE_A_ESB_SPECIFIC_DEPTH);
CONSTANT WRITE_B_ADDRESS_MOD = FLOOR(NUMWORDS_WRITE_B_ACTUAL MOD WRITE_B_ESB_SPECIFIC_DEPTH);
CONSTANT READ_A_ADDRESS_MOD = FLOOR(NUMWORDS_READ_A_ACTUAL MOD READ_A_ESB_SPECIFIC_DEPTH);
CONSTANT READ_B_ADDRESS_MOD = FLOOR(NUMWORDS_READ_B_ACTUAL MOD READ_B_ESB_SPECIFIC_DEPTH);

DEFINE MIXED_BITS_CALC(main_width, esb_spec_width, x) =
	-- only allocate the bare number of bits which are needed
	(main_width <= esb_spec_width)		?		main_width
										:		((x != 0) # (CEIL(main_width MOD esb_spec_width) == 0))
												?	esb_spec_width
												:	FLOOR(main_width MOD esb_spec_width);

DEFINE MIXED_BITS_WA(x) = USING_MIXED_MODE()	?	WRITE_A_ESB_SPECIFIC_WIDTH
												:	MIXED_BITS_CALC(WIDTH_WRITE_A_ACTUAL, WRITE_A_ESB_SPECIFIC_WIDTH, x);
DEFINE MIXED_BITS_WB(x) = USING_MIXED_MODE()	?	WRITE_B_ESB_SPECIFIC_WIDTH
												:	MIXED_BITS_CALC(WIDTH_WRITE_B_ACTUAL, WRITE_B_ESB_SPECIFIC_WIDTH, x);
DEFINE MIXED_BITS_RA(x) = USING_MIXED_MODE()	?	READ_A_ESB_SPECIFIC_WIDTH
												:	MIXED_BITS_CALC(WIDTH_READ_A_ACTUAL, READ_A_ESB_SPECIFIC_WIDTH, x);
DEFINE MIXED_BITS_RB(x) = USING_MIXED_MODE()	?	READ_B_ESB_SPECIFIC_WIDTH
												:	MIXED_BITS_CALC(WIDTH_READ_B_ACTUAL, READ_B_ESB_SPECIFIC_WIDTH, x);

-- for addresss calculations to the WYSIWYG's
-- starting addresses
DEFINE START_ADDRESS_WRITE_A(row_number) = (row_number) * WRITE_A_ESB_SPECIFIC_DEPTH;
DEFINE START_ADDRESS_WRITE_B(row_number) = (row_number) * WRITE_B_ESB_SPECIFIC_DEPTH;
DEFINE START_ADDRESS_READ_A(row_number) = (row_number) * READ_A_ESB_SPECIFIC_DEPTH;
DEFINE START_ADDRESS_READ_B(row_number) = (row_number) * READ_B_ESB_SPECIFIC_DEPTH;

-- ending addresses
DEFINE END_ADDRESS_WRITE_A(row_number) = ((row_number == ESB_ROWS - 1) & (WRITE_A_ADDRESS_MOD != 0))
														?	START_ADDRESS_WRITE_A(row_number) + WRITE_A_ADDRESS_MOD - 1
														:	START_ADDRESS_WRITE_A(row_number) + WRITE_A_ESB_SPECIFIC_DEPTH - 1;
DEFINE END_ADDRESS_WRITE_B(row_number) = ((row_number == ESB_ROWS - 1) & (WRITE_B_ADDRESS_MOD != 0))
														?	START_ADDRESS_WRITE_B(row_number) + WRITE_B_ADDRESS_MOD - 1
														:	START_ADDRESS_WRITE_B(row_number) + WRITE_B_ESB_SPECIFIC_DEPTH - 1;
DEFINE END_ADDRESS_READ_A(row_number) = ((row_number == ESB_ROWS - 1) & (READ_A_ADDRESS_MOD != 0))
														?	START_ADDRESS_READ_A(row_number) + READ_A_ADDRESS_MOD - 1
														:	START_ADDRESS_READ_A(row_number) + READ_A_ESB_SPECIFIC_DEPTH - 1;
DEFINE END_ADDRESS_READ_B(row_number) = ((row_number == ESB_ROWS - 1) & (READ_A_ADDRESS_MOD != 0))
														?	START_ADDRESS_READ_B(row_number) + READ_B_ADDRESS_MOD - 1
														:	START_ADDRESS_READ_B(row_number) + READ_B_ESB_SPECIFIC_DEPTH - 1;

DEFINE USED_RDEN_A() = USED(rden_a);
DEFINE USED_RDEN_B() = USED(rden_b);
DEFINE LATCH_RD_ADDRESS_A() = NEED_EXTERNAL_ADDRESS_DECODE() & USED_RDEN_A();
DEFINE LATCH_RD_ADDRESS_B() = NEED_EXTERNAL_ADDRESS_DECODE() & USED_RDEN_B();
DEFINE REG_ADDRESS_DFF_A() = NEED_EXTERNAL_ADDRESS_DECODE() & RDADDRESS_A_REGISTERED();
DEFINE REG_ADDRESS_DFF_B() = NEED_EXTERNAL_ADDRESS_DECODE() & RDADDRESS_B_REGISTERED();
DEFINE EXTRA_ADDRESS_DFF_A() = NEED_EXTERNAL_ADDRESS_DECODE() & OUTPUT_A_REGISTERED();
DEFINE EXTRA_ADDRESS_DFF_B() = NEED_EXTERNAL_ADDRESS_DECODE() & OUTPUT_B_REGISTERED();

-- parameter values to pass down to WYSIWYG
-- general parameters
CONSTANT INTERNAL_FILE = USED(INIT_FILE) ? INIT_FILE : "UNUSED";
CONSTANT LOGICAL_RAM_NAME = "ALTQUADPORT_RAM_INSTANTIATION";
-- ram interleaving parameters for mixed mode operations
CONSTANT DATA_INTERLEAVE_OFFSET_IN_BITS = USING_MIXED_MODE() ? MIN_WIDTH_ENTERED : "UNUSED";
CONSTANT DATA_INTERLEAVE_WIDTH_IN_BITS = USING_MIXED_MODE() ? LEAST_ESB_SPECIFIC_WIDTH : "UNUSED";

-- port A
CONSTANT PORT_A_OPERATION_MODE = "UNUSED";
CONSTANT PORT_A_LOGICAL_RAM_NAME = "UNUSED";
CONSTANT PORT_A_INIT_FILE = "UNUSED";
CONSTANT PORT_A_WRITE_DEEP_RAM_MODE = "UNUSED";
CONSTANT PORT_A_WRITE_LOGICAL_RAM_DEPTH = NUMWORDS_WRITE_A_ACTUAL;
CONSTANT PORT_A_WRITE_LOGICAL_RAM_WIDTH = WIDTH_WRITE_A_ACTUAL;
DEFINE PORT_A_WRITE_ADDRESS_WIDTH(y) = MAX(1, CEIL(LOG2(END_ADDRESS_WRITE_A(y) - START_ADDRESS_WRITE_A(y) + 1)));
CONSTANT PORT_A_READ_DEEP_RAM_MODE = "UNUSED";
CONSTANT PORT_A_READ_LOGICAL_RAM_DEPTH = NUMWORDS_READ_A_ACTUAL;
CONSTANT PORT_A_READ_LOGICAL_RAM_WIDTH = WIDTH_READ_A_ACTUAL;

DEFINE PORT_A_READ_ADDRESS_WIDTH(y) = MAX(1, CEIL(LOG2(END_ADDRESS_READ_A(y) - START_ADDRESS_READ_A(y) + 1)));
DEFINE CLEAR_STRING_ADJUST(x) = (((x == "PORTACLEAR0") & USED(inaclr_a)) #
								((x == "PORTACLEAR1") & USED(outaclr_a)) #
								((x == "PORTBCLEAR0") & USED(inaclr_b)) #
								((x == "PORTBCLEAR1") & USED(outaclr_b))) ? x : "UNUSED";
								
DEFINE PORT_A_DATA_IN_CLOCK_INT() = INDATA_REG_A == "INCLOCK_A" ? "PORTACLOCK0" : "NONE";
DEFINE PORT_A_DATA_IN_CLEAR_INT() = PORT_A_DATA_IN_CLOCK() == "NONE" ? "UNUSED" : INDATA_ACLR_A == "INACLR_A" ? "PORTACLEAR0" : "UNUSED";
DEFINE PORT_A_DATA_IN_CLEAR() = CLEAR_STRING_ADJUST(PORT_A_DATA_IN_CLEAR_INT());
DEFINE PORT_A_WRITE_LOGIC_CLOCK_INT() = WRCONTROL_WRADDRESS_REG_A == "INCLOCK_A" ? "PORTACLOCK0" : "NONE";
DEFINE PORT_A_WRITE_ADDRESS_CLEAR_INT() = PORT_A_WRITE_LOGIC_CLOCK() == "NONE" ? "UNUSED" : WRADDRESS_ACLR_A == "INACLR_A" ? "PORTACLEAR0" : "UNUSED";
DEFINE PORT_A_WRITE_ADDRESS_CLEAR() = CLEAR_STRING_ADJUST(PORT_A_WRITE_ADDRESS_CLEAR_INT());
DEFINE PORT_A_WRITE_ENABLE_CLEAR_INT() = PORT_A_WRITE_LOGIC_CLOCK() == "NONE" ? "UNUSED" : WRCONTROL_ACLR_A == "INACLR_A" ? "PORTACLEAR0" : "UNUSED";
DEFINE PORT_A_WRITE_ENABLE_CLEAR() = CLEAR_STRING_ADJUST(PORT_A_WRITE_ENABLE_CLEAR_INT());
DEFINE PORT_A_READ_ENABLE_CLOCK_INT() = RDCONTROL_REG_A == "INCLOCK_A" ? "PORTACLOCK0" : RDCONTROL_REG_A == "OUTCLOCK_A" ?
									"PORTACLOCK1" : "NONE";
DEFINE PORT_A_READ_ENABLE_CLEAR() = CLEAR_STRING_ADJUST(PORT_A_READ_ENABLE_CLEAR_INT());
DEFINE PORT_A_READ_ENABLE_CLEAR_INT() = ((PORT_A_READ_ENABLE_CLOCK() == "NONE") # !USED(rden_a)) ? "UNUSED" : RDCONTROL_ACLR_A == "INACLR_A" ? "PORTACLEAR0" : RDCONTROL_ACLR_A == "OUTACLR_A" ?
									"PORTACLEAR1" : "UNUSED";
DEFINE PORT_A_READ_ADDRESS_CLOCK_INT() = RDADDRESS_REG_A == "INCLOCK_A" ? "PORTACLOCK0" : RDADDRESS_REG_A == "OUTCLOCK_A" ?
									"PORTACLOCK1" : "NONE";
DEFINE PORT_A_READ_ADDRESS_CLEAR_INT() = (PORT_A_READ_ADDRESS_CLOCK() == "NONE") ? "UNUSED" : RDADDRESS_ACLR_A == "INACLR_A" ? "PORTACLEAR0" : RDADDRESS_ACLR_A == "OUTACLR_A" ?
									"PORTACLEAR1" : "UNUSED";
DEFINE PORT_A_READ_ADDRESS_CLEAR() = CLEAR_STRING_ADJUST(PORT_A_READ_ADDRESS_CLEAR_INT());
DEFINE PORT_A_DATA_OUT_CLOCK_INT() = OUTDATA_REG_A == "INCLOCK_A" ? "PORTACLOCK0" : OUTDATA_REG_A == "OUTCLOCK_A" ?
									"PORTACLOCK1" : "NONE";
DEFINE PORT_A_DATA_OUT_CLEAR_INT() = PORT_A_DATA_OUT_CLOCK() == "NONE" ? "UNUSED" : OUTDATA_ACLR_A == "INACLR_A" ? "PORTACLEAR0" : OUTDATA_ACLR_A == "OUTACLR_A" ?
									"PORTACLEAR1" : "UNUSED";
DEFINE PORT_A_DATA_OUT_CLEAR() = CLEAR_STRING_ADJUST(PORT_A_DATA_OUT_CLEAR_INT());
DEFINE PORT_A_DATA_IN_CLOCK() = !ROM_MODE() ? PORT_A_DATA_IN_CLOCK_INT() : "NONE";
DEFINE PORT_A_WRITE_LOGIC_CLOCK() = !ROM_MODE() ? PORT_A_WRITE_LOGIC_CLOCK_INT() : "NONE";
DEFINE PORT_A_READ_ENABLE_CLOCK() = (!SINGLE_PORT_MODE() & !BIDIR_DUAL_MODE() & !ROM_MODE()) ? (USED(rden_a) ? PORT_A_READ_ENABLE_CLOCK_INT() : "NONE") : "NONE";
DEFINE PORT_A_READ_ADDRESS_CLOCK() = (!SINGLE_PORT_MODE() & !BIDIR_DUAL_MODE()) ? PORT_A_READ_ADDRESS_CLOCK_INT() : "NONE";
DEFINE PORT_A_DATA_OUT_CLOCK() = PORT_A_DATA_OUT_CLOCK_INT();
DEFINE PORT_A_WRITE_FIRST_ADDRESS(y) = START_ADDRESS_WRITE_A(y);
DEFINE PORT_A_WRITE_LAST_ADDRESS(y) = END_ADDRESS_WRITE_A(y);
-- helper fuinctions for the parameter
	DEFINE NMIXED_PORT_A_WRITE_FIRST_BIT_NUMBER(x) = (WIDTH_WRITE_A_ACTUAL >= (WRITE_A_ESB_SPECIFIC_WIDTH * (ESB_COLS - x))) ?
																WIDTH_WRITE_A_ACTUAL - (WRITE_A_ESB_SPECIFIC_WIDTH * (ESB_COLS - x)) :
																0;
	DEFINE MIXED_PORT_A_WRITE_FIRST_BIT_NUMBER(x) = x * LEAST_ESB_SPECIFIC_WIDTH;
DEFINE PORT_A_WRITE_FIRST_BIT_NUMBER(x) = USING_MIXED_MODE()	?	MIXED_PORT_A_WRITE_FIRST_BIT_NUMBER(x)
																:	NMIXED_PORT_A_WRITE_FIRST_BIT_NUMBER(x);
DEFINE PORT_A_WRITE_DATA_WIDTH(x) = MIXED_BITS_WA(x);
DEFINE PORT_A_READ_FIRST_ADDRESS(y) = START_ADDRESS_READ_A(y);
DEFINE PORT_A_READ_LAST_ADDRESS(y) = END_ADDRESS_READ_A(y);
	DEFINE NMIXED_PORT_A_READ_FIRST_BIT_NUMBER(x) = (WIDTH_READ_A_ACTUAL >= (READ_A_ESB_SPECIFIC_WIDTH * (ESB_COLS - x))) ?
																WIDTH_READ_A_ACTUAL - (READ_A_ESB_SPECIFIC_WIDTH * (ESB_COLS - x)) :
																0;
	DEFINE MIXED_PORT_A_READ_FIRST_BIT_NUMBER(x) = x * LEAST_ESB_SPECIFIC_WIDTH;
DEFINE PORT_A_READ_FIRST_BIT_NUMBER(x) = USING_MIXED_MODE()	?	MIXED_PORT_A_READ_FIRST_BIT_NUMBER(x)
															:	NMIXED_PORT_A_READ_FIRST_BIT_NUMBER(x);
DEFINE PORT_A_READ_DATA_WIDTH(x) = MIXED_BITS_RA(x);
-- port B
CONSTANT PORT_B_OPERATION_MODE = "UNUSED";
CONSTANT PORT_B_LOGICAL_RAM_NAME = "UNUSED";
CONSTANT PORT_B_INIT_FILE = "UNUSED";
CONSTANT PORT_B_WRITE_DEEP_RAM_MODE = "UNUSED";
CONSTANT PORT_B_WRITE_LOGICAL_RAM_DEPTH = NUMWORDS_WRITE_B_ACTUAL;
CONSTANT PORT_B_WRITE_LOGICAL_RAM_WIDTH = WIDTH_WRITE_B_ACTUAL;
DEFINE PORT_B_WRITE_ADDRESS_WIDTH(y) = MAX(1, CEIL(LOG2(END_ADDRESS_WRITE_B(y) - START_ADDRESS_WRITE_B(y) + 1)));
CONSTANT PORT_B_READ_DEEP_RAM_MODE = "UNUSED";
CONSTANT PORT_B_READ_LOGICAL_RAM_DEPTH = NUMWORDS_READ_B_ACTUAL;
CONSTANT PORT_B_READ_LOGICAL_RAM_WIDTH = WIDTH_READ_B_ACTUAL;
DEFINE PORT_B_READ_ADDRESS_WIDTH(y) = MAX(1, CEIL(LOG2(END_ADDRESS_READ_B(y) - START_ADDRESS_READ_B(y) + 1)));

DEFINE PORT_B_DATA_IN_CLOCK_INT() = INDATA_REG_B == "INCLOCK_B" ? "PORTBCLOCK0" : "NONE";
DEFINE PORT_B_DATA_IN_CLEAR_INT() = PORT_B_DATA_IN_CLOCK() == "NONE" ? "UNUSED" : INDATA_ACLR_B == "INACLR_B" ? "PORTBCLEAR0" : "UNUSED";
DEFINE PORT_B_DATA_IN_CLEAR() = CLEAR_STRING_ADJUST(PORT_B_DATA_IN_CLEAR_INT());
DEFINE PORT_B_WRITE_LOGIC_CLOCK_INT() = WRCONTROL_WRADDRESS_REG_B == "INCLOCK_B" ? "PORTBCLOCK0" : "NONE";
DEFINE PORT_B_WRITE_ADDRESS_CLEAR_INT() = PORT_B_WRITE_LOGIC_CLOCK() == "NONE" ? "UNUSED" : WRADDRESS_ACLR_B == "INACLR_B" ? "PORTBCLEAR0"
										: "UNUSED";
DEFINE PORT_B_WRITE_ADDRESS_CLEAR() = CLEAR_STRING_ADJUST(PORT_B_WRITE_ADDRESS_CLEAR_INT());
DEFINE PORT_B_WRITE_ENABLE_CLEAR_INT() = PORT_B_WRITE_LOGIC_CLOCK() == "NONE" ? "UNUSED" : WRCONTROL_ACLR_B == "INACLR_B" ? "PORTBCLEAR0"
										: "UNUSED";
DEFINE PORT_B_WRITE_ENABLE_CLEAR() = CLEAR_STRING_ADJUST(PORT_B_WRITE_ENABLE_CLEAR_INT());
DEFINE PORT_B_READ_ENABLE_CLOCK_INT() = RDCONTROL_REG_B == "INCLOCK_B" ? "PORTBCLOCK0" : RDCONTROL_REG_B == "OUTCLOCK_B" ? "PORTBCLOCK1" :
										"NONE";
DEFINE PORT_B_READ_ENABLE_CLEAR_INT() = ((PORT_B_READ_ENABLE_CLOCK() == "NONE") # !USED(rden_b)) ? "UNUSED" : RDCONTROL_ACLR_B == "INACLR_B" ? "PORTBCLEAR0" : 
										RDCONTROL_ACLR_B == "OUTACLR_B" ? "PORTBCLEAR1" : "UNUSED";
DEFINE PORT_B_READ_ENABLE_CLEAR() = CLEAR_STRING_ADJUST(PORT_B_READ_ENABLE_CLEAR_INT());
DEFINE PORT_B_READ_ADDRESS_CLOCK_INT() = RDADDRESS_REG_B == "INCLOCK_B" ? "PORTBCLOCK0" : RDADDRESS_REG_B == "OUTCLOCK_B" ? "PORTBCLOCK1"
										: "NONE";
DEFINE PORT_B_READ_ADDRESS_CLEAR_INT() = PORT_B_READ_ADDRESS_CLOCK() == "NONE" ? "UNUSED" : RDADDRESS_ACLR_B == "INACLR_B" ? "PORTBCLEAR0"
										: RDADDRESS_ACLR_B == "OUTACLR_B" ? "PORTBCLEAR1" : "UNUSED";
DEFINE PORT_B_READ_ADDRESS_CLEAR() = CLEAR_STRING_ADJUST(PORT_B_READ_ADDRESS_CLEAR_INT());
DEFINE PORT_B_DATA_OUT_CLOCK_INT() = OUTDATA_REG_B == "INCLOCK_B" ? "PORTBCLOCK0" : OUTDATA_REG_B == "OUTCLOCK_B" ? "PORTBCLOCK1" :
									"NONE";
DEFINE PORT_B_DATA_OUT_CLEAR() = CLEAR_STRING_ADJUST(PORT_B_DATA_OUT_CLEAR_INT());
DEFINE PORT_B_DATA_OUT_CLEAR_INT() = PORT_B_DATA_OUT_CLOCK() == "NONE" ? "UNUSED" : OUTDATA_ACLR_B == "INACLR_B" ? "PORTBCLEAR0" :
										OUTDATA_ACLR_B == "OUTACLR_B" ? "PORTBCLEAR1" : "UNUSED";
DEFINE PORT_B_DATA_IN_CLOCK() = (QUAD_PORT_MODE() # BIDIR_DUAL_MODE()) ? PORT_B_DATA_IN_CLOCK_INT() : "NONE";
DEFINE PORT_B_WRITE_LOGIC_CLOCK() = (QUAD_PORT_MODE() # BIDIR_DUAL_MODE()) ? PORT_B_WRITE_LOGIC_CLOCK_INT() : "NONE";
DEFINE PORT_B_READ_ENABLE_CLOCK() = QUAD_PORT_MODE() ? (USED(rden_b) ? PORT_B_READ_ENABLE_CLOCK_INT() : "NONE") : "NONE";
DEFINE PORT_B_READ_ADDRESS_CLOCK() = QUAD_PORT_MODE() ? PORT_B_READ_ADDRESS_CLOCK_INT() : "NONE";
DEFINE PORT_B_DATA_OUT_CLOCK() = (QUAD_PORT_MODE() # BIDIR_DUAL_MODE()) ? PORT_B_DATA_OUT_CLOCK_INT() : "NONE";

DEFINE PORT_B_WRITE_FIRST_ADDRESS(y) = START_ADDRESS_WRITE_B(y);
DEFINE PORT_B_WRITE_LAST_ADDRESS(y) = END_ADDRESS_WRITE_B(y);
	DEFINE NMIXED_PORT_B_WRITE_FIRST_BIT_NUMBER(x) = (WIDTH_WRITE_B_ACTUAL >= (WRITE_B_ESB_SPECIFIC_WIDTH * (ESB_COLS - x))) ?
																WIDTH_WRITE_B_ACTUAL - (WRITE_B_ESB_SPECIFIC_WIDTH * (ESB_COLS - x)) :
																0;
	DEFINE MIXED_PORT_B_WRITE_FIRST_BIT_NUMBER(x) = x * LEAST_ESB_SPECIFIC_WIDTH;
DEFINE PORT_B_WRITE_FIRST_BIT_NUMBER(x) = USING_MIXED_MODE()	?	MIXED_PORT_B_WRITE_FIRST_BIT_NUMBER(x)
																:	NMIXED_PORT_B_WRITE_FIRST_BIT_NUMBER(x);
DEFINE PORT_B_WRITE_DATA_WIDTH(x) = MIXED_BITS_WB(x);
DEFINE PORT_B_READ_FIRST_ADDRESS(y) = START_ADDRESS_READ_B(y);
DEFINE PORT_B_READ_LAST_ADDRESS(y) = END_ADDRESS_READ_B(y);
	DEFINE NMIXED_PORT_B_READ_FIRST_BIT_NUMBER(x) = (WIDTH_READ_B_ACTUAL >= (READ_B_ESB_SPECIFIC_WIDTH * (ESB_COLS - x))) ?
																WIDTH_READ_B_ACTUAL - (READ_B_ESB_SPECIFIC_WIDTH * (ESB_COLS - x)) :
																0;
	DEFINE MIXED_PORT_B_READ_FIRST_BIT_NUMBER(x) = x * LEAST_ESB_SPECIFIC_WIDTH;
DEFINE PORT_B_READ_FIRST_BIT_NUMBER(x) = USING_MIXED_MODE()	?	MIXED_PORT_B_READ_FIRST_BIT_NUMBER(x)
															:	NMIXED_PORT_B_READ_FIRST_BIT_NUMBER(x);
DEFINE PORT_B_READ_DATA_WIDTH(x) = MIXED_BITS_RB(x);
	DEFINE NMIXED_PORT_A_WRITE_LAST_BIT(x) = WIDTH_WRITE_A_ACTUAL - (WRITE_A_ESB_SPECIFIC_WIDTH * (ESB_COLS - x - 1)) - 1;
	DEFINE MIXED_PORT_A_WRITE_LAST_BIT(x) = (WIDTH_WRITE_A_ACTUAL - 1) - (LEAST_ESB_SPECIFIC_WIDTH * (ESB_COLS - x - 1));
DEFINE PORT_A_WRITE_LAST_BIT_NUMBER(x) = USING_MIXED_MODE()	?	MIXED_PORT_A_WRITE_LAST_BIT(x)
															:	NMIXED_PORT_A_WRITE_LAST_BIT(x);
	DEFINE NMIXED_PORT_B_WRITE_LAST_BIT(x) = WIDTH_WRITE_B_ACTUAL - (WRITE_B_ESB_SPECIFIC_WIDTH * (ESB_COLS - x - 1)) - 1;
	DEFINE MIXED_PORT_B_WRITE_LAST_BIT(x) = (WIDTH_WRITE_B_ACTUAL - 1) - (LEAST_ESB_SPECIFIC_WIDTH * (ESB_COLS - x - 1));
DEFINE PORT_B_WRITE_LAST_BIT_NUMBER(x) = USING_MIXED_MODE()	?	MIXED_PORT_B_WRITE_LAST_BIT(x)
															:	NMIXED_PORT_B_WRITE_LAST_BIT(x);
	DEFINE NMIXED_PORT_A_READ_LAST_BIT(x) = WIDTH_READ_A_ACTUAL - (READ_A_ESB_SPECIFIC_WIDTH * (ESB_COLS - x - 1)) - 1;
	DEFINE MIXED_PORT_A_READ_LAST_BIT(x) = (WIDTH_READ_A_ACTUAL - 1) - (LEAST_ESB_SPECIFIC_WIDTH * (ESB_COLS - x - 1));
DEFINE PORT_A_READ_LAST_BIT_NUMBER(x) =	USING_MIXED_MODE()	?	MIXED_PORT_A_READ_LAST_BIT(x)
															:	NMIXED_PORT_A_READ_LAST_BIT(x);
	DEFINE NMIXED_PORT_B_READ_LAST_BIT(x) = WIDTH_READ_B_ACTUAL - (READ_B_ESB_SPECIFIC_WIDTH * (ESB_COLS - x - 1)) - 1;
	DEFINE MIXED_PORT_B_READ_LAST_BIT(x) = (WIDTH_READ_B_ACTUAL - 1) - (LEAST_ESB_SPECIFIC_WIDTH * (ESB_COLS - x - 1));
DEFINE PORT_B_READ_LAST_BIT_NUMBER(x) =	USING_MIXED_MODE()	?	MIXED_PORT_B_READ_LAST_BIT(x)
															:	NMIXED_PORT_B_READ_LAST_BIT(x);

DEFINE MODE_USES_PORT_B() = QUAD_PORT_MODE() # BIDIR_DUAL_MODE();
CONSTANT MAX_ESB_DEPTH = FLOOR(BITS_PER_ESB DIV MIN_DATA_WIDTH);
CONSTANT MIN_ESB_DEPTH = FLOOR(BITS_PER_ESB DIV MAX_DATA_WIDTH);

CONSTANT MIN_WIDTH_STRING = ((WIDTH_WRITE_A_ACTUAL == MIN_WIDTH_ENTERED) ? "WIDTH_WRITE_A" :
								((WIDTH_WRITE_B_ACTUAL == MIN_WIDTH_ENTERED) ? "WIDTH_WRITE_B" :
									((WIDTH_READ_A_ACTUAL == MIN_WIDTH_ENTERED) ? "WIDTH_READ_A" :
										"WIDTH_READ_B")));

-- external DFF will be needed to handle the read address / read enable for special cases
CONSTANT WRITE_A_DISCONTINUITIES = FLOOR(WRITE_A_ESB_SPECIFIC_WIDTH DIV LEAST_ESB_SPECIFIC_WIDTH);
CONSTANT WRITE_B_DISCONTINUITIES = FLOOR(WRITE_B_ESB_SPECIFIC_WIDTH DIV LEAST_ESB_SPECIFIC_WIDTH);
CONSTANT READ_A_DISCONTINUITIES = FLOOR(READ_A_ESB_SPECIFIC_WIDTH DIV LEAST_ESB_SPECIFIC_WIDTH);
CONSTANT READ_B_DISCONTINUITIES = FLOOR(READ_B_ESB_SPECIFIC_WIDTH DIV LEAST_ESB_SPECIFIC_WIDTH);

DEFINE CONSTRUCT_WRITE_A_DECODE() = NEED_EXTERNAL_ADDRESS_DECODE() & USED_WRITE_A_PORT();
DEFINE CONSTRUCT_WRITE_B_DECODE() = NEED_EXTERNAL_ADDRESS_DECODE() & USED_WRITE_B_PORT();
DEFINE CONSTRUCT_READ_A_MUX() = NEED_EXTERNAL_ADDRESS_DECODE() & USED_READ_A_PORT();
DEFINE CONSTRUCT_READ_B_MUX() = NEED_EXTERNAL_ADDRESS_DECODE() & USED_READ_B_PORT();

DEFINE CONTROL_A_FROM_INCLOCK_A() = (!SHARED_ADDRESS_MODE() & RDCONTROL_REG_A == "INCLOCK_A") #
												(SHARED_ADDRESS_MODE() & WRCONTROL_WRADDRESS_REG_A == "INCLOCK_A");
DEFINE ADDRESS_A_FROM_INCLOCK_A() = (!SHARED_ADDRESS_MODE() & RDADDRESS_REG_A == "INCLOCK_A") #
												(SHARED_ADDRESS_MODE() & WRCONTROL_WRADDRESS_REG_A == "INCLOCK_A");
DEFINE CONTROL_B_FROM_INCLOCK_B() = (!SHARED_ADDRESS_MODE() & RDCONTROL_REG_B == "INCLOCK_B") #
												(SHARED_ADDRESS_MODE() & WRCONTROL_WRADDRESS_REG_B == "INCLOCK_B");
DEFINE ADDRESS_B_FROM_INCLOCK_B() = (!SHARED_ADDRESS_MODE() & RDADDRESS_REG_B == "INCLOCK_B") #
												(SHARED_ADDRESS_MODE() & WRCONTROL_WRADDRESS_REG_B == "INCLOCK_B");

-- Need to add a cell delay to prevent a glitch from the address latch
DEFINE ADD_CELL_DELAY_TO_READ_A() = ((PORT_A_READ_ENABLE_CLOCK() == PORT_A_READ_ADDRESS_CLOCK()) &
									(PORT_A_READ_ENABLE_CLOCK() != "NONE"));
DEFINE ADD_CELL_DELAY_TO_READ_B() = ((PORT_B_READ_ENABLE_CLOCK() == PORT_B_READ_ADDRESS_CLOCK()) &
									(PORT_B_READ_ENABLE_CLOCK() != "NONE"));

-- STRATIX linkup  #defines
DEFINE INCLOCK_A_USED() = USED(inclock_a) ? 1 : 0;
DEFINE INCLOCK_B_USED() = USED(inclock_b) ? 1 : 0;
DEFINE OUTCLOCK_A_USED() = USED(outclock_a) ? 1 : 0;
DEFINE OUTCLOCK_B_USED() = USED(outclock_b) ? 1 : 0;
DEFINE NUMBER_OF_CLOCKS_USED() = INCLOCK_A_USED() + INCLOCK_B_USED() + OUTCLOCK_A_USED() +OUTCLOCK_B_USED();
DEFINE INACLR_A_USED() = USED(inaclr_a) ? 1 : 0;
DEFINE INACLR_B_USED() = USED(inaclr_b) ? 1 : 0;
DEFINE OUTACLR_A_USED() = USED(outaclr_a) ? 1 : 0;
DEFINE OUTACLR_B_USED() = USED(outaclr_b) ? 1 : 0;
DEFINE NUMBER_OF_CLEARS_USED() = INACLR_A_USED() + INACLR_B_USED() + OUTACLR_A_USED() +OUTACLR_B_USED();
DEFINE ROM_INPUT_REGISTERED() = RDADDRESS_REG_A != "UNREGISTERED"; 
DEFINE SPRAM_INPUT_REGISTERED() = WRCONTROL_WRADDRESS_REG_A != "UNREGISTERED" & INDATA_REG_A != "UNREGISTERED";
DEFINE DPRAM_INPUT_REGISTERED() = SPRAM_INPUT_REGISTERED() & RDADDRESS_REG_A != "UNREGISTERED" & (USED(rden_a) ? RDCONTROL_REG_A != "UNREGISTERED" : 1);
DEFINE BDPRAM_INPUT_REGISTERED() = SPRAM_INPUT_REGISTERED() & INDATA_REG_B != "UNREGISTERED" & WRCONTROL_WRADDRESS_REG_B != "UNREGISTERED";
DEFINE ROM_MODE_CHECK() = ROM_INPUT_REGISTERED() & (RDADDRESS_REG_A == "INCLOCK_A" ? USED(inclock_a) : USED(outclock_a));
DEFINE SP_MODE_CHECK() = SPRAM_INPUT_REGISTERED() & USED(inclock_a);
DEFINE DP_MODE_CHECK() = DPRAM_INPUT_REGISTERED() & USED(inclock_a);
DEFINE BDP_MODE_CHECK() = !USED(rden_a) & BDPRAM_INPUT_REGISTERED() & USED(inclock_a) & USED(inclock_b);
DEFINE OPERATION_MODE_CHECK() = (OPERATION_MODE == "ROM" ? ROM_MODE_CHECK() : (OPERATION_MODE == "SINGLE_PORT" ? SP_MODE_CHECK() : (OPERATION_MODE == "DUAL_PORT" ? DP_MODE_CHECK() : (OPERATION_MODE == "BIDIR_DUAL_PORT" ? BDP_MODE_CHECK() : 0))));
DEFINE STRATIX_RAM_POSSIBLE() = NUMBER_OF_CLOCKS_USED() <= 2 & NUMBER_OF_CLEARS_USED() <= 2 & OPERATION_MODE_CHECK();
DEFINE STRATIX_RAM_NOT_IMPOSSIBLE() = USED(inclock_a) # USED(outclock_a) # USED(inclock_b) # USED(outclock_b);

DEFINE STRATIX_ROM_CLOCK0_1()			=	USED(RDADDRESS_REG_A) ? (RDADDRESS_REG_A == "UNREGISTERED" ? (USED(inclock_a) ? "INCLOCK_A" : "OUTCLOCK_A") : RDADDRESS_REG_A) : (USED(inclock_a) ? "INCLOCK_A" : "OUTCLOCK_A");
DEFINE STRATIX_ROM_CLOCK0()				=	STRATIX_ROM_SPECIAL_CASE() ? OUTDATA_REG_A : STRATIX_ROM_CLOCK0_1();
DEFINE STRATIX_ROM_CLEAR0()				=	USED(RDADDRESS_ACLR_A) ? (RDADDRESS_ACLR_A == "NONE" ? (USED(OUTDATA_ACLR_A) ? OUTDATA_ACLR_A : "NONE")	: RDADDRESS_ACLR_A) : (USED(OUTDATA_ACLR_A) ? OUTDATA_ACLR_A : "NONE");
DEFINE STRATIX_ROM_CLOCK1_1()     		=	USED(OUTDATA_REG_A) ? (OUTDATA_REG_A == STRATIX_ROM_CLOCK0() ? "NONE" : OUTDATA_REG_A) : "NONE";
DEFINE STRATIX_ROM_CLOCK1()				=	STRATIX_ROM_SPECIAL_CASE() ? "NONE" : STRATIX_ROM_CLOCK1_1();
DEFINE STRATIX_ROM_CLEAR1()				=	USED(OUTDATA_ACLR_A) ? (OUTDATA_ACLR_A == STRATIX_ROM_CLEAR0() ? "NONE" : OUTDATA_ACLR_A) : "NONE";
DEFINE STRATIX_ROM_OUTDATA_REG_A()		=	STRATIX_ROM_SPECIAL_CASE() ? "UNREGISTERED" : (USED(OUTDATA_REG_A) ? (OUTDATA_REG_A == "UNREGISTERED" ?  "UNREGISTERED" : (OUTDATA_REG_A == STRATIX_ROM_CLOCK0() ? "CLOCK0" : "CLOCK1")) : "UNREGISTERED");
DEFINE STRATIX_ROM_OUTDATA_ACLR_A()		=	USED(OUTDATA_ACLR_A) ? (OUTDATA_ACLR_A == "NONE" ? "NONE" : (OUTDATA_ACLR_A == STRATIX_ROM_CLEAR0() ? "CLEAR0" : (OUTDATA_ACLR_A == STRATIX_ROM_CLEAR1() ? "CLEAR1" : "NONE"))) : "NONE";
DEFINE STRATIX_ROM_RDADDRESS_ACLR_A()	=	USED(RDADDRESS_ACLR_A) ? (RDADDRESS_ACLR_A == "NONE" ? "NONE" : "CLEAR0") : "NONE";  	
DEFINE STRATIX_ROM_NEED_CLEAR0()		=	(STRATIX_ROM_OUTDATA_ACLR_A() == "CLEAR0" & STRATIX_SP_OUTDATA_REG_A() != "UNREGISTERED") # (STRATIX_ROM_RDADDRESS_ACLR_A() == "CLEAR0");
DEFINE STRATIX_ROM_NEED_CLEAR1()		=	(STRATIX_ROM_OUTDATA_ACLR_A() == "CLEAR1" & STRATIX_SP_OUTDATA_REG_A() != "UNREGISTERED");
DEFINE STRATIX_ROM_NEED_CLOCK1()		=	(STRATIX_ROM_OUTDATA_REG_A() == "CLOCK1");

DEFINE FINAL_A_CLOCK()				=	USED(inclock_a) ? "INCLOCK_A" : "OUTCLOCK_A";
DEFINE STRATIX_SP_CLOCK0()				=	USED(WRCONTROL_WRADDRESS_REG_A) ? (WRCONTROL_WRADDRESS_REG_A == "UNREGISTERED" ? FINAL_A_CLOCK() : WRCONTROL_WRADDRESS_REG_A) : (USED(INDATA_REG_A) ? (INDATA_REG_A == "UNREGISTERED" ? FINAL_A_CLOCK() : INDATA_REG_A) : (FINAL_A_CLOCK()));
DEFINE STRATIX_SP_CLOCK1()				=	USED(OUTDATA_REG_A)	? (OUTDATA_REG_A == "UNREGISTERED" ? "NONE" : (OUTDATA_REG_A == STRATIX_SP_CLOCK0() ? "NONE" : OUTDATA_REG_A)) : "NONE";
DEFINE STRATIX_SP_OUTDATA_REG_A()		=	(USED(OUTDATA_REG_A) ? (OUTDATA_REG_A == "UNREGISTERED" ? "UNREGISTERED" : (OUTDATA_REG_A == STRATIX_SP_CLOCK0() ? "CLOCK0" : "CLOCK1")) : "UNREGISTERED");
DEFINE STRATIX_SP_CLEAR0()				=	USED(WRADDRESS_ACLR_A) ? ((WRADDRESS_ACLR_A == "NONE") ? STRATIX_SP_CLEAR0_1() : WRADDRESS_ACLR_A) : STRATIX_SP_CLEAR0_1();
DEFINE STRATIX_SP_CLEAR0_1()			=	USED(WRCONTROL_ACLR_A) ? ((WRCONTROL_ACLR_A == "NONE") ? STRATIX_SP_CLEAR0_2() : WRCONTROL_ACLR_A) : STRATIX_SP_CLEAR0_2();
DEFINE STRATIX_SP_CLEAR0_2()			=	USED(INDATA_ACLR_A) ? ((INDATA_ACLR_A == "NONE") ? (USED(OUTDATA_ACLR_A) ? OUTDATA_ACLR_A : "NONE") : INDATA_ACLR_A) : STRATIX_SP_CLEAR0_3();
DEFINE STRATIX_SP_CLEAR0_3()			=	USED(OUTDATA_ACLR_A) ? OUTDATA_ACLR_A : "NONE";
DEFINE STRATIX_SP_CLEAR1()				=	USED(OUTDATA_ACLR_A) ? (OUTDATA_ACLR_A == STRATIX_SP_CLEAR0() ? "NONE" : OUTDATA_ACLR_A) :"NONE";
DEFINE STRATIX_SP_WRADDRESS_ACLR_A()	=	USED(WRADDRESS_ACLR_A) ? (WRADDRESS_ACLR_A == "NONE" ? "NONE" : "CLEAR0" ) : "NONE";
DEFINE STRATIX_SP_INDATA_ACLR_A()		=	USED(INDATA_ACLR_A) ? (INDATA_ACLR_A == "NONE" ? "NONE" : "CLEAR0" ) : "NONE";
DEFINE STRATIX_SP_WRCONTROL_ACLR_A()	=	USED(WRCONTROL_ACLR_A) ? (WRCONTROL_ACLR_A == "NONE" ? "NONE" : "CLEAR0" ) : "NONE";
DEFINE STRATIX_SP_OUTDATA_ACLR_A()		=	USED(OUTDATA_ACLR_A) ? (OUTDATA_ACLR_A == "NONE" ? "NONE" : (OUTDATA_ACLR_A == STRATIX_SP_CLEAR0() ? "CLEAR0" : "CLEAR1")) : "NONE";
DEFINE STRATIX_SP_NEED_CLEAR1()			=	(STRATIX_SP_OUTDATA_ACLR_A() == "CLEAR1" & STRATIX_SP_OUTDATA_REG_A() != "UNREGISTERED");
DEFINE STRATIX_SP_NEED_CLEAR0()			=	(STRATIX_SP_WRADDRESS_ACLR_A() == "CLEAR0") # (STRATIX_SP_WRCONTROL_ACLR_A() == "CLEAR0") # (STRATIX_SP_INDATA_ACLR_A() == "CLEAR0") # (STRATIX_SP_OUTDATA_ACLR_A() == "CLEAR0" & STRATIX_SP_OUTDATA_REG_A() != "UNREGISTERED");
DEFINE STRATIX_SP_NEED_CLOCK1()			=	(STRATIX_SP_OUTDATA_REG_A() == "CLOCK1");


DEFINE STRATIX_DP_CLEAR0()				=	STRATIX_SP_CLEAR0() != "NONE" ? STRATIX_SP_CLEAR0() : (USED(RDADDRESS_ACLR_A) ? (RDADDRESS_ACLR_A == "NONE" ? STRATIX_DP_CLEAR0_1() : RDADDRESS_ACLR_A ): STRATIX_DP_CLEAR0_1());
DEFINE STRATIX_DP_CLEAR0_1()			=	USED(RDCONTROL_ACLR_A) ? (RDCONTROL_ACLR_A == "NONE" ? "NONE" : RDCONTROL_ACLR_A ) :"NONE";
DEFINE STRATIX_DP_CLEAR1()				=	STRATIX_SP_CLEAR1() != "NONE" ? STRATIX_SP_CLEAR1() : (USED(RDADDRESS_ACLR_A) ? (RDADDRESS_ACLR_A == "NONE" ? STRATIX_DP_CLEAR1_1() : (RDADDRESS_ACLR_A == STRATIX_DP_CLEAR0() ? STRATIX_DP_CLEAR1_1() : RDADDRESS_ACLR_A)) : STRATIX_DP_CLEAR1_1());
DEFINE STRATIX_DP_CLEAR1_1()			=	USED(RDCONTROL_ACLR_A) ? (RDCONTROL_ACLR_A == "NONE" ? "NONE" : (RDCONTROL_ACLR_A == STRATIX_DP_CLEAR0() ? "NONE" : RDCONTROL_ACLR_A)): "NONE";
DEFINE STRATIX_DP_RDADDRESS_REG_A()		=	STRATIX_DP_SPECIAL_CASE() ? STRATIX_SP_OUTDATA_REG_A() : (USED(RDADDRESS_REG_A) ? (RDADDRESS_REG_A == "UNREGISTERED" ? "CLOCK0" : (RDADDRESS_REG_A == STRATIX_SP_CLOCK0() ? "CLOCK0" : "CLOCK1")) : "CLOCK0");
DEFINE STRATIX_DP_RDADDRESS_ACLR_A()	=	USED(RDADDRESS_ACLR_A) ? (RDADDRESS_ACLR_A == "NONE" ? "NONE" : (RDADDRESS_ACLR_A == STRATIX_DP_CLEAR0() ? "CLEAR0" : (STRATIX_DP_CLEAR1() == RDADDRESS_ACLR_A ? "CLEAR1" : "NONE")) ) : "NONE";
DEFINE STRATIX_DP_RDCONTROL_ACLR_A()	=	USED(RDCONTROL_ACLR_A) ? (RDCONTROL_ACLR_A == "NONE" ? "NONE" : (RDCONTROL_ACLR_A == STRATIX_DP_CLEAR0() ? "CLEAR0" : (STRATIX_DP_CLEAR1() == RDCONTROL_ACLR_A ? "CLEAR1" : "NONE")) ) : "NONE";
DEFINE STRATIX_DP_NEED_CLEAR0()			=	STRATIX_SP_NEED_CLEAR0() # (STRATIX_DP_RDCONTROL_ACLR_A() == "CLEAR0") # (STRATIX_DP_RDADDRESS_ACLR_A() == "CLEAR0");
DEFINE STRATIX_DP_NEED_CLEAR1()			=	STRATIX_SP_NEED_CLEAR1() # (STRATIX_DP_RDCONTROL_ACLR_A() == "CLEAR1") # (STRATIX_DP_RDADDRESS_ACLR_A() == "CLEAR1");
DEFINE STRATIX_DP_CLOCK1()				=	STRATIX_SP_CLOCK1() != "NONE" ? STRATIX_SP_CLOCK1() : (STRATIX_DP_RDADDRESS_REG_A() == "CLOCK1" ? RDADDRESS_REG_A : "NONE");
DEFINE STRATIX_DP_NEED_CLOCK1()			=	(STRATIX_DP_RDADDRESS_REG_A() == "CLOCK1") # STRATIX_SP_NEED_CLOCK1(); 
DEFINE STRATIX_DP_OUTDATA_REG_A()		=	STRATIX_DP_SPECIAL_CASE() ? "UNREGISTERED" : STRATIX_SP_OUTDATA_REG_A();

DEFINE STRATIX_BDP_CLOCK0()				=	USED(WRCONTROL_WRADDRESS_REG_A) ? (WRCONTROL_WRADDRESS_REG_A == "UNREGISTERED" ? STRATIX_BDP_CLOCK0_1() : WRCONTROL_WRADDRESS_REG_A ) : STRATIX_BDP_CLOCK0_1();
DEFINE STRATIX_BDP_CLOCK0_1()			=	USED(INDATA_REG_A) ? (INDATA_REG_A == "UNREGISTERED" ? STRATIX_BDP_CLOCK0_2() : INDATA_REG_A ) : STRATIX_BDP_CLOCK0_2();
DEFINE STRATIX_BDP_CLOCK0_2()			=	USED(OUTDATA_REG_A) ? (OUTDATA_REG_A == "UNREGISTERED" ? STRATIX_BDP_CLOCK0_3() : OUTDATA_REG_A ) : STRATIX_BDP_CLOCK0_3();
DEFINE STRATIX_BDP_CLOCK0_3()			=	USED(WRCONTROL_WRADDRESS_REG_B) ? (WRCONTROL_WRADDRESS_REG_B == "UNREGISTERED" ? STRATIX_BDP_CLOCK0_4() : WRCONTROL_WRADDRESS_REG_B ) : STRATIX_BDP_CLOCK0_4();
DEFINE STRATIX_BDP_CLOCK0_4()			=	USED(INDATA_REG_B) ? (INDATA_REG_B == "UNREGISTERED" ? STRATIX_BDP_CLOCK0_5() : INDATA_REG_B ) : STRATIX_BDP_CLOCK0_5();
DEFINE STRATIX_BDP_CLOCK0_5()			=	USED(OUTDATA_REG_B) ? (OUTDATA_REG_B == "UNREGISTERED" ? STRATIX_BDP_CLOCK0_6() : OUTDATA_REG_B ) : STRATIX_BDP_CLOCK0_6();
DEFINE STRATIX_BDP_CLOCK0_6()			=	USED(inclock_a) ? "INCLOCK_A" : (USED(outclock_a) ? "OUTCLOCK_A" : (USED(inclock_b) ? "INCLOCK_B" : (USED(outclock_b) ? "OUTCLOCK_B" : "NONE")));

DEFINE STRATIX_BDP_CLOCK1()				=	USED(OUTDATA_REG_A) ? ((OUTDATA_REG_A == "UNREGISTERED" # OUTDATA_REG_A == STRATIX_BDP_CLOCK0()) ? STRATIX_BDP_CLOCK1_1() : OUTDATA_REG_A ) : STRATIX_BDP_CLOCK1_1();
DEFINE STRATIX_BDP_CLOCK1_1()			=	USED(WRCONTROL_WRADDRESS_REG_B) ? ((WRCONTROL_WRADDRESS_REG_B == "UNREGISTERED" # WRCONTROL_WRADDRESS_REG_B == STRATIX_BDP_CLOCK0()) ? STRATIX_BDP_CLOCK1_2() : WRCONTROL_WRADDRESS_REG_B ) : STRATIX_BDP_CLOCK1_2();
DEFINE STRATIX_BDP_CLOCK1_2()			=	USED(INDATA_REG_B) ? ((INDATA_REG_B == "UNREGISTERED" # INDATA_REG_B == STRATIX_BDP_CLOCK0()) ? STRATIX_BDP_CLOCK1_3() : INDATA_REG_B ) : STRATIX_BDP_CLOCK1_3();
DEFINE STRATIX_BDP_CLOCK1_3()			=	USED(OUTDATA_REG_B) ? ((OUTDATA_REG_B == "UNREGISTERED" # OUTDATA_REG_B == STRATIX_BDP_CLOCK0()) ? "NONE" : OUTDATA_REG_B ) : "NONE";

DEFINE STRATIX_BDP_CLEAR0()				=	USED(WRADDRESS_ACLR_A) ? (WRADDRESS_ACLR_A == "NONE" ? STRATIX_BDP_CLEAR0_1() : WRADDRESS_ACLR_A ) : STRATIX_BDP_CLEAR0_1();
DEFINE STRATIX_BDP_CLEAR0_1()			=	USED(WRCONTROL_ACLR_A) ? (WRCONTROL_ACLR_A == "NONE" ? STRATIX_BDP_CLEAR0_2() : WRCONTROL_ACLR_A ) : STRATIX_BDP_CLEAR0_2();
DEFINE STRATIX_BDP_CLEAR0_2()			=	USED(INDATA_ACLR_A) ? (INDATA_ACLR_A == "NONE" ? STRATIX_BDP_CLEAR0_3() : INDATA_ACLR_A ) : STRATIX_BDP_CLEAR0_3();
DEFINE STRATIX_BDP_CLEAR0_3()			=	USED(OUTDATA_ACLR_A) ? (OUTDATA_ACLR_A == "NONE" ? STRATIX_BDP_CLEAR0_4() : OUTDATA_ACLR_A ) : STRATIX_BDP_CLEAR0_4();
DEFINE STRATIX_BDP_CLEAR0_4()			=	USED(WRADDRESS_ACLR_B) ? (WRADDRESS_ACLR_B == "NONE" ? STRATIX_BDP_CLEAR0_5() : WRADDRESS_ACLR_B ) : STRATIX_BDP_CLEAR0_5();
DEFINE STRATIX_BDP_CLEAR0_5()			=	USED(WRCONTROL_ACLR_B) ? (WRCONTROL_ACLR_B == "NONE" ? STRATIX_BDP_CLEAR0_6() : WRCONTROL_ACLR_B ) : STRATIX_BDP_CLEAR0_6();
DEFINE STRATIX_BDP_CLEAR0_6()			=	USED(INDATA_ACLR_B) ? (INDATA_ACLR_B == "NONE" ? STRATIX_BDP_CLEAR0_7() : INDATA_ACLR_B ) : STRATIX_BDP_CLEAR0_7();
DEFINE STRATIX_BDP_CLEAR0_7()			=	USED(OUTDATA_ACLR_B) ? (OUTDATA_ACLR_B == "NONE" ? "NONE" : OUTDATA_ACLR_B ) : "NONE";

DEFINE STRATIX_BDP_CLEAR1()				=	USED(OUTDATA_ACLR_A) ? ((OUTDATA_ACLR_A == "NONE" # OUTDATA_ACLR_A == STRATIX_BDP_CLEAR0()) ? STRATIX_BDP_CLEAR1_1() : OUTDATA_ACLR_A ) : STRATIX_BDP_CLEAR1_1();
DEFINE STRATIX_BDP_CLEAR1_1()			=	USED(WRADDRESS_ACLR_B) ? ((WRADDRESS_ACLR_B == "NONE" # WRADDRESS_ACLR_B == STRATIX_BDP_CLEAR0()) ? STRATIX_BDP_CLEAR1_2() : WRADDRESS_ACLR_B ) : STRATIX_BDP_CLEAR1_2();
DEFINE STRATIX_BDP_CLEAR1_2()			=	USED(WRCONTROL_ACLR_B) ? ((WRCONTROL_ACLR_B == "NONE" # WRCONTROL_ACLR_B == STRATIX_BDP_CLEAR0()) ? STRATIX_BDP_CLEAR1_3() : WRCONTROL_ACLR_B ) : STRATIX_BDP_CLEAR1_3();
DEFINE STRATIX_BDP_CLEAR1_3()			=	USED(INDATA_ACLR_B) ? ((INDATA_ACLR_B == "NONE" # INDATA_ACLR_B == STRATIX_BDP_CLEAR0()) ? STRATIX_BDP_CLEAR1_4() : INDATA_ACLR_B ) : STRATIX_BDP_CLEAR1_4();
DEFINE STRATIX_BDP_CLEAR1_4()			=	USED(OUTDATA_ACLR_B) ? ((OUTDATA_ACLR_B == "NONE" # OUTDATA_ACLR_B == STRATIX_BDP_CLEAR0()) ? "NONE" : OUTDATA_ACLR_B ) : "NONE";

DEFINE STRATIX_BDP_WRADDRESS_REG_B()	=	USED(WRCONTROL_WRADDRESS_REG_B) ? (WRCONTROL_WRADDRESS_REG_B == "UNREGISTERED" ? STRATIX_BDP_INDATA_REG_B() : (WRCONTROL_WRADDRESS_REG_B == STRATIX_BDP_CLOCK0() ? "CLOCK0" : (STRATIX_BDP_CLOCK1() == "NONE" ? "CLOCK0" : "CLOCK1"))) : STRATIX_BDP_INDATA_REG_B();
DEFINE STRATIX_BDP_INDATA_REG_B()		=	USED(INDATA_REG_B) ? (INDATA_REG_B == "UNREGISTERED" ? "CLOCK0" : (INDATA_REG_B == STRATIX_BDP_CLOCK1() ? "CLOCK1" : "CLOCK0") ) : "CLOCK0";
DEFINE STRATIX_BDP_OUTDATA_REG_A()		=	USED(OUTDATA_REG_A) ? (OUTDATA_REG_A == "UNREGISTERED" ? "UNREGISTERED" : (OUTDATA_REG_A == STRATIX_BDP_CLOCK0() ? "CLOCK0" : "CLOCK1" )) : "UNREGISTERED";
DEFINE STRATIX_BDP_OUTDATA_REG_B()		=	USED(OUTDATA_REG_B) ? (OUTDATA_REG_B == "UNREGISTERED" ? "UNREGISTERED" : (OUTDATA_REG_B == STRATIX_BDP_CLOCK0() ? "CLOCK0" : "CLOCK1" )) : "UNREGISTERED";

DEFINE STRATIX_BDP_INDATA_ACLR_A()		=	USED(INDATA_ACLR_A) ? (INDATA_ACLR_A == "NONE" ? "NONE" : (INDATA_ACLR_A == STRATIX_BDP_CLEAR0() ? "CLEAR0" : "NONE" )): "NONE";
DEFINE STRATIX_BDP_WRADDRESS_ACLR_A()	=	USED(WRADDRESS_ACLR_A) ? (WRADDRESS_ACLR_A == "NONE" ? "NONE" : (WRADDRESS_ACLR_A == STRATIX_BDP_CLEAR0() ? "CLEAR0" : "NONE" )): "NONE";
DEFINE STRATIX_BDP_WRCONTROL_ACLR_A()	=	USED(WRCONTROL_ACLR_A) ? (WRCONTROL_ACLR_A == "NONE" ? "NONE" : (WRCONTROL_ACLR_A == STRATIX_BDP_CLEAR0() ? "CLEAR0" : "NONE" )): "NONE";
DEFINE STRATIX_BDP_OUTDATA_ACLR_A()		=	USED(OUTDATA_ACLR_A) ? (OUTDATA_ACLR_A == "NONE" ? "NONE" : (OUTDATA_ACLR_A == STRATIX_BDP_CLEAR0() ? "CLEAR0" : (OUTDATA_ACLR_A == STRATIX_BDP_CLEAR1() ? "CLEAR1" : "NONE" ))): "NONE";
DEFINE STRATIX_BDP_OUTDATA_ACLR_B()		=	USED(OUTDATA_ACLR_B) ? (OUTDATA_ACLR_B == "NONE" ? "NONE" : (OUTDATA_ACLR_B == STRATIX_BDP_CLEAR0() ? "CLEAR0" : (OUTDATA_ACLR_B == STRATIX_BDP_CLEAR1() ? "CLEAR1" : "NONE" ))): "NONE";
DEFINE STRATIX_BDP_INDATA_ACLR_B()		=	USED(INDATA_ACLR_B) ? (INDATA_ACLR_B == "NONE" ? "NONE" : (INDATA_ACLR_B == STRATIX_BDP_CLEAR0() ? "CLEAR0" : (INDATA_ACLR_B == STRATIX_BDP_CLEAR1() ? "CLEAR1" : "NONE" ))): "NONE";
DEFINE STRATIX_BDP_WRCONTROL_ACLR_B()	=	USED(WRCONTROL_ACLR_B) ? (WRCONTROL_ACLR_B == "NONE" ? "NONE" : (WRCONTROL_ACLR_B == STRATIX_BDP_CLEAR0() ? "CLEAR0" : (WRCONTROL_ACLR_B == STRATIX_BDP_CLEAR1() ? "CLEAR1" : "NONE" ))): "NONE";
DEFINE STRATIX_BDP_WRADDRESS_ACLR_B()	=	USED(WRADDRESS_ACLR_B) ? (WRADDRESS_ACLR_B == "NONE" ? "NONE" : (WRADDRESS_ACLR_B == STRATIX_BDP_CLEAR0() ? "CLEAR0" : (WRADDRESS_ACLR_B == STRATIX_BDP_CLEAR1() ? "CLEAR1" : "NONE" ))): "NONE";

DEFINE STRATIX_BDP_NEED_CLEAR0()		=	(STRATIX_BDP_INDATA_ACLR_A() == "CLEAR0") # (STRATIX_BDP_WRADDRESS_ACLR_A() == "CLEAR0") # (STRATIX_BDP_WRCONTROL_ACLR_A() == "CLEAR0") # (STRATIX_BDP_OUTDATA_ACLR_A() == "CLEAR0" & STRATIX_BDP_OUTDATA_REG_A() != "UNREGISTERED") # (STRATIX_BDP_INDATA_ACLR_B() == "CLEAR0") # (STRATIX_BDP_WRADDRESS_ACLR_B() == "CLEAR0") # (STRATIX_BDP_WRCONTROL_ACLR_B() == "CLEAR0") # (STRATIX_BDP_OUTDATA_ACLR_B() == "CLEAR0" & STRATIX_BDP_OUTDATA_REG_B() != "UNREGISTERED"); 
DEFINE STRATIX_BDP_NEED_CLEAR1()		=	(STRATIX_BDP_INDATA_ACLR_B() == "CLEAR1") # (STRATIX_BDP_WRADDRESS_ACLR_B() == "CLEAR1") # (STRATIX_BDP_WRCONTROL_ACLR_B() == "CLEAR1") # (STRATIX_BDP_OUTDATA_ACLR_B() == "CLEAR1" & STRATIX_BDP_OUTDATA_REG_B() != "UNREGISTERED") # (STRATIX_BDP_OUTDATA_ACLR_A() == "CLEAR1" & STRATIX_BDP_OUTDATA_REG_A() != "UNREGISTERED"); 
DEFINE STRATIX_BDP_NEED_CLOCK1()		=	(STRATIX_BDP_WRADDRESS_REG_B() == "CLOCK1") # (STRATIX_BDP_OUTDATA_REG_A() == "CLOCK1") # (STRATIX_BDP_OUTDATA_REG_B() == "CLOCK1");

DEFINE STRATIX_ROM_SPECIAL_CASE()		=	(ROM_MODE() & !USED(inaclr_a) & !USED(outaclr_a) & (RDADDRESS_REG_A == "UNREGISTERED") & (OUTDATA_REG_A != "UNREGISTERED"));
DEFINE STRATIX_DP_SPECIAL_CASE()		=	(DUAL_PORT_MODE() & !USED(rden_a) & !USED(inaclr_a) & !USED(outaclr_a) & (RDADDRESS_REG_A == "UNREGISTERED") & (OUTDATA_REG_A != "UNREGISTERED") & (WRCONTROL_WRADDRESS_REG_A != "UNREGISTERED") & (INDATA_REG_A != "UNREGISTERED"));
DEFINE STRATIX_SPECIAL_CASE()		=	STRATIX_ROM_SPECIAL_CASE() # STRATIX_DP_SPECIAL_CASE();

DEFINE STRATIX_VALID_CASE()			= 	-(!STRATIX_RAM_POSSIBLE()) & -(!STRATIX_SPECIAL_CASE());

SUBDESIGN altqpram
(
	wren_a										: INPUT = GND;
	wren_b										: INPUT = GND;
	data_a[WIDTH_WRITE_A_ACTUAL - 1..0]			: INPUT = VCC;
	data_b[WIDTH_WRITE_B_ACTUAL - 1..0]			: INPUT = VCC;
	wraddress_a[WIDTHAD_WRITE_A_ACTUAL - 1..0]	: INPUT = VCC;
	wraddress_b[WIDTHAD_WRITE_B_ACTUAL - 1..0]	: INPUT = VCC;
	inclock_a									: INPUT = VCC;
	inclock_b									: INPUT = VCC;
	inclocken_a									: INPUT = VCC;
	inclocken_b									: INPUT = VCC;
	rden_a										: INPUT = VCC;
	rden_b										: INPUT = VCC;
	rdaddress_a[WIDTHAD_READ_A_ACTUAL - 1..0]	: INPUT = VCC;
	rdaddress_b[WIDTHAD_READ_B_ACTUAL - 1..0]	: INPUT = VCC;
	outclock_a									: INPUT = VCC;
	outclock_b									: INPUT = VCC;
	outclocken_a								: INPUT = VCC;
	outclocken_b								: INPUT = VCC;
	inaclr_a									: INPUT = GND;
	inaclr_b									: INPUT = GND;
	outaclr_a									: INPUT = GND;
	outaclr_b									: INPUT = GND;

	q_a[WIDTH_READ_A_ACTUAL - 1..0]				: OUTPUT;
	q_b[WIDTH_READ_B_ACTUAL - 1..0]				: OUTPUT;
)
VARIABLE
	IF FAMILY_STRATIX() GENERATE
		IF STRATIX_RAM_POSSIBLE() # STRATIX_SPECIAL_CASE() GENERATE
			IF ROM_MODE() GENERATE
				ram_block : altsyncram WITH (
								OPERATION_MODE = "ROM",
								OUTDATA_REG_A = STRATIX_ROM_OUTDATA_REG_A(),
								OUTDATA_ACLR_A = STRATIX_ROM_OUTDATA_ACLR_A(),
								ADDRESS_ACLR_A = STRATIX_ROM_RDADDRESS_ACLR_A(),
								WIDTH_A = WIDTH_READ_A,
								WIDTHAD_A = WIDTHAD_READ_A,
								NUMWORDS_A = NUMWORDS_READ_A,
								MAXIMUM_DEPTH = USED(MAXIMUM_DEPTH) & MAXIMUM_DEPTH != 0 ? MAXIMUM_DEPTH : "UNUSED",
								INIT_FILE = USED(INIT_FILE) ? INIT_FILE : "UNUSED",
								ENABLE_POF = "ON"
								);	
			END GENERATE;
			IF SINGLE_PORT_MODE() GENERATE
				ram_block : altsyncram WITH (
							OPERATION_MODE = "SINGLE_PORT",
							INIT_FILE = USED(INIT_FILE) ? INIT_FILE : "UNUSED",
							WIDTH_A = WIDTH_WRITE_A,
							WIDTHAD_A = WIDTHAD_WRITE_A,
							NUMWORDS_A = NUMWORDS_WRITE_A,
							OUTDATA_REG_A = STRATIX_SP_OUTDATA_REG_A(),
							OUTDATA_ACLR_A = STRATIX_SP_OUTDATA_ACLR_A(),
							INDATA_ACLR_A = STRATIX_SP_INDATA_ACLR_A(),
							ADDRESS_ACLR_A = STRATIX_SP_WRADDRESS_ACLR_A(),
							WRCONTROL_ACLR_A = STRATIX_SP_WRCONTROL_ACLR_A(),
							MAXIMUM_DEPTH = USED(MAXIMUM_DEPTH) & MAXIMUM_DEPTH != 0 ? MAXIMUM_DEPTH : "UNUSED",
							ENABLE_POF = "ON",
							WIDTH_BYTEENA_A = 1,
							WIDTH_BYTEENA_B = 1														
							);	
			END GENERATE;
			IF DUAL_PORT_MODE() GENERATE
				ram_block : altsyncram WITH (
							WIDTH_A = WIDTH_WRITE_A,
							WIDTHAD_A = WIDTHAD_WRITE_A,
							WIDTH_B = WIDTH_READ_A,
							WIDTHAD_B = WIDTHAD_READ_A,	
							NUMWORDS_A = NUMWORDS_WRITE_A,
							NUMWORDS_B = NUMWORDS_READ_A,
							INIT_FILE = USED(INIT_FILE) ? INIT_FILE : "UNUSED",
							ADDRESS_REG_B = STRATIX_DP_RDADDRESS_REG_A(),
							RDCONTROL_REG_B = STRATIX_DP_RDADDRESS_REG_A(),
							OUTDATA_REG_B = STRATIX_SP_OUTDATA_REG_A(),
							INDATA_ACLR_A = STRATIX_SP_INDATA_ACLR_A(),
							ADDRESS_ACLR_A = STRATIX_SP_WRADDRESS_ACLR_A(),
							WRCONTROL_ACLR_A = STRATIX_SP_WRCONTROL_ACLR_A(),
							ADDRESS_ACLR_B = STRATIX_DP_RDADDRESS_ACLR_A(),
							RDCONTROL_ACLR_B = STRATIX_DP_RDCONTROL_ACLR_A(),
							OUTDATA_ACLR_B = STRATIX_SP_OUTDATA_ACLR_A(),
							OPERATION_MODE = "DUAL_PORT",
							MAXIMUM_DEPTH = USED(MAXIMUM_DEPTH) & MAXIMUM_DEPTH != 0 ? MAXIMUM_DEPTH : "UNUSED",		
							ENABLE_POF = "ON",
							WIDTH_BYTEENA_A = 1,
							WIDTH_BYTEENA_B = 1														
						);	
			END GENERATE;
			IF BIDIR_DUAL_MODE() GENERATE
			ram_block : altsyncram WITH (
							WIDTH_A = WIDTH_WRITE_A,
							WIDTHAD_A = WIDTHAD_WRITE_A,
							WIDTH_B = WIDTH_WRITE_B,
							WIDTHAD_B = WIDTHAD_WRITE_B,	
							NUMWORDS_A = NUMWORDS_WRITE_A,
							NUMWORDS_B = NUMWORDS_WRITE_B,
							INIT_FILE = USED(INIT_FILE) ? INIT_FILE : "UNUSED",
							ADDRESS_REG_B = STRATIX_BDP_WRADDRESS_REG_B(),
							INDATA_REG_B = STRATIX_BDP_WRADDRESS_REG_B(),						
							WRCONTROL_WRADDRESS_REG_B = STRATIX_BDP_WRADDRESS_REG_B(),
							OUTDATA_REG_B = STRATIX_BDP_OUTDATA_REG_B(),
							OUTDATA_REG_A = STRATIX_BDP_OUTDATA_REG_A(),
							INDATA_ACLR_A = STRATIX_BDP_INDATA_ACLR_A(),
							INDATA_ACLR_B = STRATIX_BDP_INDATA_ACLR_B(),
							ADDRESS_ACLR_A = STRATIX_BDP_WRADDRESS_ACLR_A(),
							WRCONTROL_ACLR_A = STRATIX_BDP_WRCONTROL_ACLR_A(),
							ADDRESS_ACLR_B = STRATIX_BDP_WRADDRESS_ACLR_B(),
							WRCONTROL_ACLR_B = STRATIX_BDP_WRCONTROL_ACLR_B(),
							OUTDATA_ACLR_B = STRATIX_BDP_OUTDATA_ACLR_B(),
							OUTDATA_ACLR_A = STRATIX_BDP_OUTDATA_ACLR_A(),													
							OPERATION_MODE = "BIDIR_DUAL_PORT",
							WIDTH_BYTEENA_A = 1,
							WIDTH_BYTEENA_B = 1,
							MAXIMUM_DEPTH = USED(MAXIMUM_DEPTH) & MAXIMUM_DEPTH != 0 ? MAXIMUM_DEPTH : "UNUSED",
							ENABLE_POF = "ON"									
							);	
			END GENERATE;
		ELSE GENERATE
			IF STRATIX_RAM_NOT_IMPOSSIBLE() GENERATE
				IF ROM_MODE() GENERATE
					ram_block : altsyncram WITH (
								OPERATION_MODE = "ROM",
								OUTDATA_REG_A = STRATIX_ROM_OUTDATA_REG_A(),
								OUTDATA_ACLR_A = STRATIX_ROM_OUTDATA_ACLR_A(),
								ADDRESS_ACLR_A = STRATIX_ROM_RDADDRESS_ACLR_A(),
								WIDTH_A = WIDTH_READ_A,
								WIDTHAD_A = WIDTHAD_READ_A,
								NUMWORDS_A = NUMWORDS_READ_A,
								MAXIMUM_DEPTH = USED(MAXIMUM_DEPTH) & MAXIMUM_DEPTH != 0 ? MAXIMUM_DEPTH : "UNUSED",
								INIT_FILE = USED(INIT_FILE) ? INIT_FILE : "UNUSED",
								ENABLE_POF = "OFF"
								);	
				END GENERATE;
				IF SINGLE_PORT_MODE() GENERATE
					ram_block : altsyncram WITH (
							OPERATION_MODE = "SINGLE_PORT",
							INIT_FILE = USED(INIT_FILE) ? INIT_FILE : "UNUSED",
							WIDTH_A = WIDTH_WRITE_A,
							WIDTHAD_A = WIDTHAD_WRITE_A,
							NUMWORDS_A = NUMWORDS_WRITE_A,
							OUTDATA_REG_A = STRATIX_SP_OUTDATA_REG_A(),
							OUTDATA_ACLR_A = STRATIX_SP_OUTDATA_ACLR_A(),
							INDATA_ACLR_A = STRATIX_SP_INDATA_ACLR_A(),
							ADDRESS_ACLR_A = STRATIX_SP_WRADDRESS_ACLR_A(),
							WRCONTROL_ACLR_A = STRATIX_SP_WRCONTROL_ACLR_A(),
							MAXIMUM_DEPTH = USED(MAXIMUM_DEPTH) & MAXIMUM_DEPTH != 0 ? MAXIMUM_DEPTH : "UNUSED",
							WIDTH_BYTEENA_A = 1,
							ENABLE_POF = "OFF"
							);	
				END GENERATE;
				IF DUAL_PORT_MODE() GENERATE
					ram_block : altsyncram WITH (
							WIDTH_A = WIDTH_WRITE_A,
							WIDTHAD_A = WIDTHAD_WRITE_A,
							WIDTH_B = WIDTH_READ_A,
							WIDTHAD_B = WIDTHAD_READ_A,	
							NUMWORDS_A = NUMWORDS_WRITE_A,
							NUMWORDS_B = NUMWORDS_READ_A,
							INIT_FILE = USED(INIT_FILE) ? INIT_FILE : "UNUSED",
							ADDRESS_REG_B = STRATIX_DP_RDADDRESS_REG_A(),
							RDCONTROL_REG_B = STRATIX_DP_RDADDRESS_REG_A(),
							OUTDATA_REG_B = STRATIX_SP_OUTDATA_REG_A(),
							INDATA_ACLR_A = STRATIX_SP_INDATA_ACLR_A(),
							ADDRESS_ACLR_A = STRATIX_SP_WRADDRESS_ACLR_A(),
							WRCONTROL_ACLR_A = STRATIX_SP_WRCONTROL_ACLR_A(),
							ADDRESS_ACLR_B = STRATIX_DP_RDADDRESS_ACLR_A(),
							RDCONTROL_ACLR_B = STRATIX_DP_RDCONTROL_ACLR_A(),
							OUTDATA_ACLR_B = STRATIX_SP_OUTDATA_ACLR_A(),
							OPERATION_MODE = "DUAL_PORT",
							WIDTH_BYTEENA_A = 1,
							MAXIMUM_DEPTH = USED(MAXIMUM_DEPTH) & MAXIMUM_DEPTH != 0 ? MAXIMUM_DEPTH : "UNUSED",		
							ENABLE_POF = "OFF"							
							);	
				END GENERATE;
				IF BIDIR_DUAL_MODE() GENERATE
					ram_block : altsyncram WITH (
							WIDTH_A = WIDTH_WRITE_A,
							WIDTHAD_A = WIDTHAD_WRITE_A,
							WIDTH_B = WIDTH_WRITE_B,
							WIDTHAD_B = WIDTHAD_WRITE_B,	
							NUMWORDS_A = NUMWORDS_WRITE_A,
							NUMWORDS_B = NUMWORDS_WRITE_B,
							INIT_FILE = USED(INIT_FILE) ? INIT_FILE : "UNUSED",
							ADDRESS_REG_B = STRATIX_BDP_WRADDRESS_REG_B(),
							INDATA_REG_B = STRATIX_BDP_WRADDRESS_REG_B(),						
							WRCONTROL_WRADDRESS_REG_B = STRATIX_BDP_WRADDRESS_REG_B(),
							OUTDATA_REG_B = STRATIX_BDP_OUTDATA_REG_B(),
							OUTDATA_REG_A = STRATIX_BDP_OUTDATA_REG_A(),
							INDATA_ACLR_A = STRATIX_BDP_INDATA_ACLR_A(),
							INDATA_ACLR_B = STRATIX_BDP_INDATA_ACLR_B(),
							ADDRESS_ACLR_A = STRATIX_BDP_WRADDRESS_ACLR_A(),
							WRCONTROL_ACLR_A = STRATIX_BDP_WRCONTROL_ACLR_A(),
							ADDRESS_ACLR_B = STRATIX_BDP_WRADDRESS_ACLR_B(),
							WRCONTROL_ACLR_B = STRATIX_BDP_WRCONTROL_ACLR_B(),
							OUTDATA_ACLR_B = STRATIX_BDP_OUTDATA_ACLR_B(),
							OUTDATA_ACLR_A = STRATIX_BDP_OUTDATA_ACLR_A(),													
							OPERATION_MODE = "BIDIR_DUAL_PORT",
							WIDTH_BYTEENA_A = 1,
							WIDTH_BYTEENA_B = 1,
							MAXIMUM_DEPTH = USED(MAXIMUM_DEPTH) & MAXIMUM_DEPTH != 0 ? MAXIMUM_DEPTH : "UNUSED",
							ENABLE_POF = "OFF"									
							);	
				END GENERATE;
			END GENERATE;
		END GENERATE;
	ELSE GENERATE
	IF CONSTRUCT_WRITE_A_DECODE() GENERATE
		external_decoder_a	:	lpm_decode WITH	(
													LPM_WIDTH = EXTERNAL_ADDRESS_BITS,
													LPM_DECODES = EXTERNAL_DECODES
												);
	END GENERATE;

	IF USED_WRITE_A_PORT() GENERATE
		portawe_actual[ESB_ROWS - 1..0] : NODE;
	END GENERATE;

	IF CONSTRUCT_WRITE_B_DECODE() GENERATE
		external_decoder_b :	lpm_decode WITH	(
													LPM_WIDTH = EXTERNAL_ADDRESS_BITS,
													LPM_DECODES = EXTERNAL_DECODES
												);
	END GENERATE;

	IF USED_WRITE_B_PORT() GENERATE
		portbwe_actual[ESB_ROWS - 1..0] : NODE;
	END GENERATE;

	IF CONSTRUCT_READ_A_MUX() GENERATE
		external_mux_a :	lpm_mux WITH	(
												LPM_WIDTH = WIDTH_READ_A_ACTUAL,
												LPM_WIDTHS = EXTERNAL_ADDRESS_BITS,
												LPM_SIZE = EXTERNAL_DECODES
											);

		IF !ADD_CELL_DELAY_TO_READ_A() GENERATE
			IF LATCH_RD_ADDRESS_A() GENERATE
				x_addr_a_latch[EXTERNAL_ADDRESS_BITS - 1..0] : LATCH;
			ELSE GENERATE
				x_addr_a_latch[EXTERNAL_ADDRESS_BITS - 1..0] : NODE;
			END GENERATE;

			IF REG_ADDRESS_DFF_A() GENERATE
				x_reg_addr_a[EXTERNAL_ADDRESS_BITS - 1..0] : DFFE;
			ELSE GENERATE
				x_reg_addr_a[EXTERNAL_ADDRESS_BITS - 1..0] : NODE;
			END GENERATE;
		ELSE GENERATE
			latch_emulator_a : a_rdenreg WITH	(
													WIDTH = EXTERNAL_ADDRESS_BITS,
													D_ACLR = RDADDRESS_ACLR_A == "NONE" ? "NONE" : "ACLR",
													E_ACLR = RDCONTROL_ACLR_A == "NONE" ? "NONE" : (RDCONTROL_ACLR_A == RDADDRESS_ACLR_A ? "ACLR" : "ACLRE")
												);
			x_addr_a_latch[EXTERNAL_ADDRESS_BITS - 1..0] : NODE;
		END GENERATE;

		IF EXTRA_ADDRESS_DFF_A() GENERATE
			x_xreg_addr_a[EXTERNAL_ADDRESS_BITS - 1..0] : DFFE;
		ELSE GENERATE
			x_xreg_addr_a[EXTERNAL_ADDRESS_BITS - 1..0] : NODE;
		END GENERATE;

		IF RDCONTROL_A_REGISTERED() & MODE_HAS_RDEN() GENERATE
			x_rea_dffe : DFFE;
		END GENERATE;
		x_rea : NODE;
	END GENERATE;

	IF USED_READ_A_PORT() GENERATE
		pre_out_a[ESB_ROWS - 1..0][WIDTH_READ_A_ACTUAL - 1..0] : NODE;
	END GENERATE;

	IF CONSTRUCT_READ_B_MUX() GENERATE
		external_mux_b :	lpm_mux WITH	(
												LPM_WIDTH = WIDTH_READ_B_ACTUAL,
												LPM_WIDTHS = EXTERNAL_ADDRESS_BITS,
												LPM_SIZE = EXTERNAL_DECODES
											);

		IF !ADD_CELL_DELAY_TO_READ_B() GENERATE
			IF LATCH_RD_ADDRESS_B() GENERATE
				x_addr_b_latch[EXTERNAL_ADDRESS_BITS - 1..0] : LATCH;
			ELSE GENERATE
				x_addr_b_latch[EXTERNAL_ADDRESS_BITS - 1..0] : NODE;
			END GENERATE;

			IF REG_ADDRESS_DFF_B() GENERATE
				x_reg_addr_b[EXTERNAL_ADDRESS_BITS - 1..0] : DFFE;
			ELSE GENERATE
				x_reg_addr_b[EXTERNAL_ADDRESS_BITS - 1..0] : NODE;
			END GENERATE;
		ELSE GENERATE
			latch_emulator_b : a_rdenreg WITH	(
													WIDTH = EXTERNAL_ADDRESS_BITS,
													D_ACLR = RDADDRESS_ACLR_B == "NONE" ? "NONE" : "ACLR",
													E_ACLR = RDCONTROL_ACLR_B == "NONE" ? "NONE" : (RDCONTROL_ACLR_B == RDADDRESS_ACLR_B ? "ACLR" : "ACLRE")
												);
			x_addr_b_latch[EXTERNAL_ADDRESS_BITS - 1..0] : NODE;
		END GENERATE;

		IF EXTRA_ADDRESS_DFF_B() GENERATE
			x_xreg_addr_b[EXTERNAL_ADDRESS_BITS - 1..0] : DFFE;
		ELSE GENERATE
			x_xreg_addr_b[EXTERNAL_ADDRESS_BITS - 1..0] : NODE;
		END GENERATE;

		IF RDCONTROL_B_REGISTERED() & MODE_HAS_RDEN() GENERATE
			x_reb_dffe : DFFE;
		END GENERATE;
		x_reb : NODE;
	END GENERATE;

	IF USED_READ_B_PORT() GENERATE
		pre_out_b[ESB_ROWS - 1..0][WIDTH_READ_B_ACTUAL - 1..0] : NODE;
	END GENERATE;

	-- allocate the ESB blocks
	IF FAMILY_MERCURY() == 1 GENERATE
		IF QUAD_PORT_MODE() GENERATE
			memory_blocks[ESB_COLS - 1..0][ESB_ROWS - 1..0] :
				FOR col IN ESB_COLS - 1 TO 0 GENERATE
					FOR row IN ESB_ROWS - 1 TO 0 GENERATE
						mercury_ram_block WITH (
													-- Ram-wide parameters
													OPERATION_MODE = OPERATION_MODE,
													INIT_FILE = INTERNAL_FILE,
													LOGICAL_RAM_NAME = LOGICAL_RAM_NAME,
													DATA_INTERLEAVE_OFFSET_IN_BITS = DATA_INTERLEAVE_OFFSET_IN_BITS,
													DATA_INTERLEAVE_WIDTH_IN_BITS = DATA_INTERLEAVE_WIDTH_IN_BITS,
													-- Port A parameters
													PORT_A_OPERATION_MODE = PORT_A_OPERATION_MODE,
													PORT_A_LOGICAL_RAM_NAME = PORT_A_LOGICAL_RAM_NAME,
													PORT_A_INIT_FILE = PORT_A_INIT_FILE,
													PORT_A_WRITE_DEEP_RAM_MODE = PORT_A_WRITE_DEEP_RAM_MODE,
													PORT_A_WRITE_LOGICAL_RAM_DEPTH = PORT_A_WRITE_LOGICAL_RAM_DEPTH,
													PORT_A_WRITE_LOGICAL_RAM_WIDTH = PORT_A_WRITE_LOGICAL_RAM_WIDTH,
													PORT_A_WRITE_ADDRESS_WIDTH = PORT_A_WRITE_ADDRESS_WIDTH(row),
													PORT_A_READ_DEEP_RAM_MODE = PORT_A_READ_DEEP_RAM_MODE,
													PORT_A_READ_LOGICAL_RAM_DEPTH = PORT_A_READ_LOGICAL_RAM_DEPTH,
													PORT_A_READ_LOGICAL_RAM_WIDTH = PORT_A_READ_LOGICAL_RAM_WIDTH,
													PORT_A_READ_ADDRESS_WIDTH = PORT_A_READ_ADDRESS_WIDTH(row),
													PORT_A_DATA_IN_CLOCK = PORT_A_DATA_IN_CLOCK(),
													PORT_A_DATA_IN_CLEAR = PORT_A_DATA_IN_CLEAR(),
													PORT_A_WRITE_LOGIC_CLOCK = PORT_A_WRITE_LOGIC_CLOCK(),
													PORT_A_WRITE_ADDRESS_CLEAR = PORT_A_WRITE_ADDRESS_CLEAR(),
													PORT_A_WRITE_ENABLE_CLEAR = PORT_A_WRITE_ENABLE_CLEAR(),
													PORT_A_READ_ENABLE_CLOCK = PORT_A_READ_ENABLE_CLOCK(),
													PORT_A_READ_ENABLE_CLEAR = PORT_A_READ_ENABLE_CLEAR(),
													PORT_A_READ_ADDRESS_CLOCK = PORT_A_READ_ADDRESS_CLOCK(),
													PORT_A_READ_ADDRESS_CLEAR = PORT_A_READ_ADDRESS_CLEAR(),
													PORT_A_DATA_OUT_CLOCK = PORT_A_DATA_OUT_CLOCK(),
													PORT_A_DATA_OUT_CLEAR = PORT_A_DATA_OUT_CLEAR(),
													PORT_A_WRITE_FIRST_ADDRESS = PORT_A_WRITE_FIRST_ADDRESS(row),
													PORT_A_WRITE_LAST_ADDRESS = PORT_A_WRITE_LAST_ADDRESS(row),
													PORT_A_WRITE_FIRST_BIT_NUMBER = PORT_A_WRITE_FIRST_BIT_NUMBER(col),
													PORT_A_WRITE_DATA_WIDTH = PORT_A_WRITE_DATA_WIDTH(col),
													PORT_A_READ_FIRST_ADDRESS = PORT_A_READ_FIRST_ADDRESS(row),
													PORT_A_READ_LAST_ADDRESS = PORT_A_READ_LAST_ADDRESS(row),
													PORT_A_READ_FIRST_BIT_NUMBER = PORT_A_READ_FIRST_BIT_NUMBER(col),
													PORT_A_READ_DATA_WIDTH = PORT_A_READ_DATA_WIDTH(col),
													-- Port B parameters
													PORT_B_OPERATION_MODE = PORT_B_OPERATION_MODE,
													PORT_B_LOGICAL_RAM_NAME = PORT_B_LOGICAL_RAM_NAME,
													PORT_B_INIT_FILE = PORT_B_INIT_FILE,
													PORT_B_WRITE_DEEP_RAM_MODE = PORT_B_WRITE_DEEP_RAM_MODE,
													PORT_B_WRITE_LOGICAL_RAM_DEPTH = PORT_B_WRITE_LOGICAL_RAM_DEPTH,
													PORT_B_WRITE_LOGICAL_RAM_WIDTH = PORT_B_WRITE_LOGICAL_RAM_WIDTH,
													PORT_B_WRITE_ADDRESS_WIDTH = PORT_B_WRITE_ADDRESS_WIDTH(row),
													PORT_B_READ_DEEP_RAM_MODE = PORT_B_READ_DEEP_RAM_MODE,
													PORT_B_READ_LOGICAL_RAM_DEPTH = PORT_B_READ_LOGICAL_RAM_DEPTH,
													PORT_B_READ_LOGICAL_RAM_WIDTH = PORT_B_READ_LOGICAL_RAM_WIDTH,
													PORT_B_READ_ADDRESS_WIDTH = PORT_B_READ_ADDRESS_WIDTH(row),
													PORT_B_DATA_IN_CLOCK = PORT_B_DATA_IN_CLOCK(),
													PORT_B_DATA_IN_CLEAR = PORT_B_DATA_IN_CLEAR(),
													PORT_B_WRITE_LOGIC_CLOCK = PORT_B_WRITE_LOGIC_CLOCK(),
													PORT_B_WRITE_ADDRESS_CLEAR = PORT_B_WRITE_ADDRESS_CLEAR(),
													PORT_B_WRITE_ENABLE_CLEAR = PORT_B_WRITE_ENABLE_CLEAR(),
													PORT_B_READ_ENABLE_CLOCK = PORT_B_READ_ENABLE_CLOCK(),
													PORT_B_READ_ENABLE_CLEAR = PORT_B_READ_ENABLE_CLEAR(),
													PORT_B_READ_ADDRESS_CLOCK = PORT_B_READ_ADDRESS_CLOCK(),
													PORT_B_READ_ADDRESS_CLEAR = PORT_B_READ_ADDRESS_CLEAR(),
													PORT_B_DATA_OUT_CLOCK = PORT_B_DATA_OUT_CLOCK(),
													PORT_B_DATA_OUT_CLEAR = PORT_B_DATA_OUT_CLEAR(),
													PORT_B_WRITE_FIRST_ADDRESS = PORT_B_WRITE_FIRST_ADDRESS(row),
													PORT_B_WRITE_LAST_ADDRESS = PORT_B_WRITE_LAST_ADDRESS(row),
													PORT_B_WRITE_FIRST_BIT_NUMBER = PORT_B_WRITE_FIRST_BIT_NUMBER(col),
													PORT_B_WRITE_DATA_WIDTH = PORT_B_WRITE_DATA_WIDTH(col),
													PORT_B_READ_FIRST_ADDRESS = PORT_B_READ_FIRST_ADDRESS(row),
													PORT_B_READ_LAST_ADDRESS = PORT_B_READ_LAST_ADDRESS(row),
													PORT_B_READ_FIRST_BIT_NUMBER = PORT_B_READ_FIRST_BIT_NUMBER(col),
													PORT_B_READ_DATA_WIDTH = PORT_B_READ_DATA_WIDTH(col)
												)
					END GENERATE
				END GENERATE;
		ELSE GENERATE IF BIDIR_DUAL_MODE() GENERATE
			memory_blocks[ESB_COLS - 1..0][ESB_ROWS - 1..0] :
			FOR col IN ESB_COLS - 1 TO 0 GENERATE
				FOR row IN ESB_ROWS - 1 TO 0 GENERATE
						mercury_ram_block WITH (
													-- Ram-wide parameters
													OPERATION_MODE = "BIDIR_DUAL_PORT",
													INIT_FILE = INTERNAL_FILE,
													LOGICAL_RAM_NAME = LOGICAL_RAM_NAME,
													DATA_INTERLEAVE_OFFSET_IN_BITS = DATA_INTERLEAVE_OFFSET_IN_BITS,
													DATA_INTERLEAVE_WIDTH_IN_BITS = DATA_INTERLEAVE_WIDTH_IN_BITS,
													-- Port A parameters
													PORT_A_OPERATION_MODE = PORT_A_OPERATION_MODE,
													PORT_A_LOGICAL_RAM_NAME = PORT_A_LOGICAL_RAM_NAME,
													PORT_A_INIT_FILE = PORT_A_INIT_FILE,
													PORT_A_WRITE_DEEP_RAM_MODE = PORT_A_WRITE_DEEP_RAM_MODE,
													PORT_A_WRITE_LOGICAL_RAM_DEPTH = PORT_A_WRITE_LOGICAL_RAM_DEPTH,
													PORT_A_WRITE_LOGICAL_RAM_WIDTH = PORT_A_WRITE_LOGICAL_RAM_WIDTH,
													PORT_A_WRITE_ADDRESS_WIDTH = PORT_A_WRITE_ADDRESS_WIDTH(row),
													PORT_A_READ_DEEP_RAM_MODE = PORT_A_READ_DEEP_RAM_MODE,
													PORT_A_READ_LOGICAL_RAM_DEPTH = PORT_A_READ_LOGICAL_RAM_DEPTH,
													PORT_A_READ_LOGICAL_RAM_WIDTH = PORT_A_READ_LOGICAL_RAM_WIDTH,
													PORT_A_READ_ADDRESS_WIDTH = PORT_A_READ_ADDRESS_WIDTH(row),
													PORT_A_DATA_IN_CLOCK = PORT_A_DATA_IN_CLOCK(),
													PORT_A_DATA_IN_CLEAR = PORT_A_DATA_IN_CLEAR(),
													PORT_A_WRITE_LOGIC_CLOCK = PORT_A_WRITE_LOGIC_CLOCK(),
													PORT_A_WRITE_ADDRESS_CLEAR = PORT_A_WRITE_ADDRESS_CLEAR(),
													PORT_A_WRITE_ENABLE_CLEAR = PORT_A_WRITE_ENABLE_CLEAR(),
													PORT_A_READ_ADDRESS_CLOCK = PORT_A_WRITE_LOGIC_CLOCK(),
													PORT_A_READ_ADDRESS_CLEAR = PORT_A_WRITE_ADDRESS_CLEAR(),
													PORT_A_DATA_OUT_CLOCK = PORT_A_DATA_OUT_CLOCK(),
													PORT_A_DATA_OUT_CLEAR = PORT_A_DATA_OUT_CLEAR(),
													PORT_A_WRITE_FIRST_ADDRESS = PORT_A_WRITE_FIRST_ADDRESS(row),
													PORT_A_WRITE_LAST_ADDRESS = PORT_A_WRITE_LAST_ADDRESS(row),
													PORT_A_WRITE_FIRST_BIT_NUMBER = PORT_A_WRITE_FIRST_BIT_NUMBER(col),
													PORT_A_WRITE_DATA_WIDTH = PORT_A_WRITE_DATA_WIDTH(col),
													PORT_A_READ_FIRST_ADDRESS = PORT_A_WRITE_FIRST_ADDRESS(row),
													PORT_A_READ_LAST_ADDRESS = PORT_A_WRITE_LAST_ADDRESS(row),
													PORT_A_READ_FIRST_BIT_NUMBER = PORT_A_READ_FIRST_BIT_NUMBER(col),
													PORT_A_READ_DATA_WIDTH = PORT_A_READ_DATA_WIDTH(col),
													-- Port B parameters
													PORT_B_OPERATION_MODE = PORT_B_OPERATION_MODE,
													PORT_B_LOGICAL_RAM_NAME = PORT_B_LOGICAL_RAM_NAME,
													PORT_B_INIT_FILE = PORT_B_INIT_FILE,
													PORT_B_WRITE_DEEP_RAM_MODE = PORT_B_WRITE_DEEP_RAM_MODE,
													PORT_B_WRITE_LOGICAL_RAM_DEPTH = PORT_B_WRITE_LOGICAL_RAM_DEPTH,
													PORT_B_WRITE_LOGICAL_RAM_WIDTH = PORT_B_WRITE_LOGICAL_RAM_WIDTH,
													PORT_B_WRITE_ADDRESS_WIDTH = PORT_B_WRITE_ADDRESS_WIDTH(row),
													PORT_B_READ_DEEP_RAM_MODE = PORT_B_READ_DEEP_RAM_MODE,
													PORT_B_READ_LOGICAL_RAM_DEPTH = PORT_B_READ_LOGICAL_RAM_DEPTH,
													PORT_B_READ_LOGICAL_RAM_WIDTH = PORT_B_READ_LOGICAL_RAM_WIDTH,
													PORT_B_READ_ADDRESS_WIDTH = PORT_B_WRITE_ADDRESS_WIDTH(row),
													PORT_B_DATA_IN_CLOCK = PORT_B_DATA_IN_CLOCK(),
													PORT_B_DATA_IN_CLEAR = PORT_B_DATA_IN_CLEAR(),
													PORT_B_WRITE_LOGIC_CLOCK = PORT_B_WRITE_LOGIC_CLOCK(),
													PORT_B_WRITE_ADDRESS_CLEAR = PORT_B_WRITE_ADDRESS_CLEAR(),
													PORT_B_WRITE_ENABLE_CLEAR = PORT_B_WRITE_ENABLE_CLEAR(),
													PORT_B_READ_ADDRESS_CLOCK = PORT_B_WRITE_LOGIC_CLOCK(),
													PORT_B_READ_ADDRESS_CLEAR = PORT_B_WRITE_ADDRESS_CLEAR(),
													PORT_B_DATA_OUT_CLOCK = PORT_B_DATA_OUT_CLOCK(),
													PORT_B_DATA_OUT_CLEAR = PORT_B_DATA_OUT_CLEAR(),
													PORT_B_WRITE_FIRST_ADDRESS = PORT_B_WRITE_FIRST_ADDRESS(row),
													PORT_B_WRITE_LAST_ADDRESS = PORT_B_WRITE_LAST_ADDRESS(row),
													PORT_B_WRITE_FIRST_BIT_NUMBER = PORT_B_WRITE_FIRST_BIT_NUMBER(col),
													PORT_B_WRITE_DATA_WIDTH = PORT_B_WRITE_DATA_WIDTH(col),
													PORT_B_READ_FIRST_ADDRESS = PORT_B_WRITE_FIRST_ADDRESS(row),
													PORT_B_READ_LAST_ADDRESS = PORT_B_WRITE_LAST_ADDRESS(row),
													PORT_B_READ_FIRST_BIT_NUMBER = PORT_B_READ_FIRST_BIT_NUMBER(col),
													PORT_B_READ_DATA_WIDTH = PORT_B_READ_DATA_WIDTH(col)
												)
				END GENERATE
			END GENERATE;
		ELSE GENERATE IF DUAL_PORT_MODE() GENERATE
			memory_blocks[ESB_COLS - 1..0][ESB_ROWS - 1..0] :
			FOR col IN ESB_COLS - 1 TO 0 GENERATE
				FOR row IN ESB_ROWS - 1 TO 0 GENERATE
					mercury_ram_block WITH (
												-- Ram-wide parameters
												OPERATION_MODE = "DUAL_PORT",
												INIT_FILE = INTERNAL_FILE,
												LOGICAL_RAM_NAME = LOGICAL_RAM_NAME,
												DATA_INTERLEAVE_OFFSET_IN_BITS = DATA_INTERLEAVE_OFFSET_IN_BITS,
												DATA_INTERLEAVE_WIDTH_IN_BITS = DATA_INTERLEAVE_WIDTH_IN_BITS,
												-- Port A parameters
												PORT_A_OPERATION_MODE = PORT_A_OPERATION_MODE,
												PORT_A_LOGICAL_RAM_NAME = PORT_A_LOGICAL_RAM_NAME,
												PORT_A_INIT_FILE = PORT_A_INIT_FILE,
												PORT_A_WRITE_DEEP_RAM_MODE = PORT_A_WRITE_DEEP_RAM_MODE,
												PORT_A_WRITE_LOGICAL_RAM_DEPTH = PORT_A_WRITE_LOGICAL_RAM_DEPTH,
												PORT_A_WRITE_LOGICAL_RAM_WIDTH = PORT_A_WRITE_LOGICAL_RAM_WIDTH,
												PORT_A_WRITE_ADDRESS_WIDTH = PORT_A_WRITE_ADDRESS_WIDTH(row),
												PORT_A_READ_DEEP_RAM_MODE = PORT_A_READ_DEEP_RAM_MODE,
												PORT_A_READ_LOGICAL_RAM_DEPTH = PORT_A_READ_LOGICAL_RAM_DEPTH,
												PORT_A_READ_LOGICAL_RAM_WIDTH = PORT_A_READ_LOGICAL_RAM_WIDTH,
												PORT_A_READ_ADDRESS_WIDTH = PORT_A_READ_ADDRESS_WIDTH(row),
												PORT_A_DATA_IN_CLOCK = PORT_A_DATA_IN_CLOCK(),
												PORT_A_DATA_IN_CLEAR = PORT_A_DATA_IN_CLEAR(),
												PORT_A_WRITE_LOGIC_CLOCK = PORT_A_WRITE_LOGIC_CLOCK(),
												PORT_A_WRITE_ADDRESS_CLEAR = PORT_A_WRITE_ADDRESS_CLEAR(),
												PORT_A_WRITE_ENABLE_CLEAR = PORT_A_WRITE_ENABLE_CLEAR(),
												PORT_A_READ_ENABLE_CLOCK = PORT_A_READ_ENABLE_CLOCK(),
												PORT_A_READ_ENABLE_CLEAR = PORT_A_READ_ENABLE_CLEAR(),
												PORT_A_READ_ADDRESS_CLOCK = PORT_A_READ_ADDRESS_CLOCK(),
												PORT_A_READ_ADDRESS_CLEAR = PORT_A_READ_ADDRESS_CLEAR(),
												PORT_A_DATA_OUT_CLOCK = PORT_A_DATA_OUT_CLOCK(),
												PORT_A_DATA_OUT_CLEAR = PORT_A_DATA_OUT_CLEAR(),
												PORT_A_WRITE_FIRST_ADDRESS = PORT_A_WRITE_FIRST_ADDRESS(row),
												PORT_A_WRITE_LAST_ADDRESS = PORT_A_WRITE_LAST_ADDRESS(row),
												PORT_A_WRITE_FIRST_BIT_NUMBER = PORT_A_WRITE_FIRST_BIT_NUMBER(col),
												PORT_A_WRITE_DATA_WIDTH = PORT_A_WRITE_DATA_WIDTH(col),
												PORT_A_READ_FIRST_ADDRESS = PORT_A_READ_FIRST_ADDRESS(row),
												PORT_A_READ_LAST_ADDRESS = PORT_A_READ_LAST_ADDRESS(row),
												PORT_A_READ_FIRST_BIT_NUMBER = PORT_A_READ_FIRST_BIT_NUMBER(col),
												PORT_A_READ_DATA_WIDTH = PORT_A_READ_DATA_WIDTH(col)
												-- Port B parameters
												-- not used... fitter will do auto-pack
											)
				END GENERATE
			END GENERATE;
		ELSE GENERATE IF SINGLE_PORT_MODE() GENERATE
			memory_blocks[ESB_COLS - 1..0][ESB_ROWS - 1..0] :
			FOR col IN ESB_COLS - 1 TO 0 GENERATE
				FOR row IN ESB_ROWS - 1 TO 0 GENERATE
					mercury_ram_block WITH (
												-- Ram-wide parameters
												OPERATION_MODE = "SINGLE_PORT",
												INIT_FILE = INTERNAL_FILE,
												LOGICAL_RAM_NAME = LOGICAL_RAM_NAME,
												DATA_INTERLEAVE_OFFSET_IN_BITS = DATA_INTERLEAVE_OFFSET_IN_BITS,
												DATA_INTERLEAVE_WIDTH_IN_BITS = DATA_INTERLEAVE_WIDTH_IN_BITS,
												-- Port A parameters
												PORT_A_OPERATION_MODE = PORT_A_OPERATION_MODE,
												PORT_A_LOGICAL_RAM_NAME = PORT_A_LOGICAL_RAM_NAME,
												PORT_A_INIT_FILE = PORT_A_INIT_FILE,
												PORT_A_WRITE_DEEP_RAM_MODE = PORT_A_WRITE_DEEP_RAM_MODE,
												PORT_A_WRITE_LOGICAL_RAM_DEPTH = PORT_A_WRITE_LOGICAL_RAM_DEPTH,
												PORT_A_WRITE_LOGICAL_RAM_WIDTH = PORT_A_WRITE_LOGICAL_RAM_WIDTH,
												PORT_A_WRITE_ADDRESS_WIDTH = PORT_A_WRITE_ADDRESS_WIDTH(row),
												PORT_A_READ_DEEP_RAM_MODE = PORT_A_READ_DEEP_RAM_MODE,
												PORT_A_READ_LOGICAL_RAM_DEPTH = PORT_A_READ_LOGICAL_RAM_DEPTH,
												PORT_A_READ_LOGICAL_RAM_WIDTH = PORT_A_READ_LOGICAL_RAM_WIDTH,
												PORT_A_READ_ADDRESS_WIDTH = PORT_A_READ_ADDRESS_WIDTH(row),
												PORT_A_DATA_IN_CLOCK = PORT_A_DATA_IN_CLOCK(),
												PORT_A_DATA_IN_CLEAR = PORT_A_DATA_IN_CLEAR(),
												PORT_A_WRITE_LOGIC_CLOCK = PORT_A_WRITE_LOGIC_CLOCK(),
												PORT_A_WRITE_ADDRESS_CLEAR = PORT_A_WRITE_ADDRESS_CLEAR(),
												PORT_A_WRITE_ENABLE_CLEAR = PORT_A_WRITE_ENABLE_CLEAR(),
												PORT_A_READ_ADDRESS_CLOCK = PORT_A_WRITE_LOGIC_CLOCK(),
												PORT_A_READ_ADDRESS_CLEAR = PORT_A_WRITE_ADDRESS_CLEAR(),
												PORT_A_DATA_OUT_CLOCK = PORT_A_DATA_OUT_CLOCK(),
												PORT_A_DATA_OUT_CLEAR = PORT_A_DATA_OUT_CLEAR(),
												PORT_A_WRITE_FIRST_ADDRESS = PORT_A_WRITE_FIRST_ADDRESS(row),
												PORT_A_WRITE_LAST_ADDRESS = PORT_A_WRITE_LAST_ADDRESS(row),
												PORT_A_WRITE_FIRST_BIT_NUMBER = PORT_A_WRITE_FIRST_BIT_NUMBER(col),
												PORT_A_WRITE_DATA_WIDTH = PORT_A_WRITE_DATA_WIDTH(col),
												PORT_A_READ_FIRST_ADDRESS = PORT_A_WRITE_FIRST_ADDRESS(row),
												PORT_A_READ_LAST_ADDRESS = PORT_A_WRITE_LAST_ADDRESS(row),
												PORT_A_READ_FIRST_BIT_NUMBER = PORT_A_READ_FIRST_BIT_NUMBER(col),
												PORT_A_READ_DATA_WIDTH = PORT_A_READ_DATA_WIDTH(col)
												-- Port B parameters
												-- not used... fitter will auto-pack if nercessary
											)
				END GENERATE
			END GENERATE;
		ELSE GENERATE -- IF ROM_MODE() GENERATE  --> check with a later assert to make sure this is true
			memory_blocks[ESB_COLS - 1..0][ESB_ROWS - 1..0] :
			FOR col IN ESB_COLS - 1 TO 0 GENERATE
				FOR row IN ESB_ROWS - 1 TO 0 GENERATE
					mercury_ram_block WITH (
												-- Ram-wide parameters
												OPERATION_MODE = "ROM",
												INIT_FILE = INTERNAL_FILE,
												LOGICAL_RAM_NAME = LOGICAL_RAM_NAME,
												DATA_INTERLEAVE_OFFSET_IN_BITS = DATA_INTERLEAVE_OFFSET_IN_BITS,
												DATA_INTERLEAVE_WIDTH_IN_BITS = DATA_INTERLEAVE_WIDTH_IN_BITS,
												-- Port A parameters
												PORT_A_OPERATION_MODE = PORT_A_OPERATION_MODE,
												PORT_A_LOGICAL_RAM_NAME = PORT_A_LOGICAL_RAM_NAME,
												PORT_A_INIT_FILE = PORT_A_INIT_FILE,
												PORT_A_READ_DEEP_RAM_MODE = PORT_A_READ_DEEP_RAM_MODE,
												PORT_A_READ_LOGICAL_RAM_DEPTH = PORT_A_READ_LOGICAL_RAM_DEPTH,
												PORT_A_READ_LOGICAL_RAM_WIDTH = PORT_A_READ_LOGICAL_RAM_WIDTH,
												PORT_A_READ_ADDRESS_WIDTH = PORT_A_READ_ADDRESS_WIDTH(row),
												PORT_A_READ_ADDRESS_CLOCK = PORT_A_READ_ADDRESS_CLOCK(),
												PORT_A_READ_ADDRESS_CLEAR = PORT_A_READ_ADDRESS_CLEAR(),
												PORT_A_DATA_OUT_CLOCK = PORT_A_DATA_OUT_CLOCK(),
												PORT_A_DATA_OUT_CLEAR = PORT_A_DATA_OUT_CLEAR(),
												PORT_A_READ_FIRST_ADDRESS = PORT_A_READ_FIRST_ADDRESS(row),
												PORT_A_READ_LAST_ADDRESS = PORT_A_READ_LAST_ADDRESS(row),
												PORT_A_READ_FIRST_BIT_NUMBER = PORT_A_READ_FIRST_BIT_NUMBER(col),
												PORT_A_READ_DATA_WIDTH = PORT_A_READ_DATA_WIDTH(col)
											)
				END GENERATE
			END GENERATE;
		END GENERATE; END GENERATE; END GENERATE; END GENERATE;
	ELSE GENERATE IF (FAMILY_APEXII() == 1) GENERATE
		IF BIDIR_DUAL_MODE() GENERATE
			memory_blocks[ESB_COLS - 1..0][ESB_ROWS - 1..0] :
			FOR col IN ESB_COLS - 1 TO 0 GENERATE
				FOR row IN ESB_ROWS - 1 TO 0 GENERATE
						apexii_ram_block WITH (
													-- Ram-wide parameters
													OPERATION_MODE = "BIDIR_DUAL_PORT",
													INIT_FILE = INTERNAL_FILE,
													LOGICAL_RAM_NAME = LOGICAL_RAM_NAME,
													DATA_INTERLEAVE_OFFSET_IN_BITS = DATA_INTERLEAVE_OFFSET_IN_BITS,
													DATA_INTERLEAVE_WIDTH_IN_BITS = DATA_INTERLEAVE_WIDTH_IN_BITS,
													-- Port A parameters
													PORT_A_OPERATION_MODE = PORT_A_OPERATION_MODE,
													PORT_A_LOGICAL_RAM_NAME = PORT_A_LOGICAL_RAM_NAME,
													PORT_A_INIT_FILE = PORT_A_INIT_FILE,
													PORT_A_WRITE_DEEP_RAM_MODE = PORT_A_WRITE_DEEP_RAM_MODE,
													PORT_A_WRITE_LOGICAL_RAM_DEPTH = PORT_A_WRITE_LOGICAL_RAM_DEPTH,
													PORT_A_WRITE_LOGICAL_RAM_WIDTH = PORT_A_WRITE_LOGICAL_RAM_WIDTH,
													PORT_A_WRITE_ADDRESS_WIDTH = PORT_A_WRITE_ADDRESS_WIDTH(row),
													PORT_A_READ_DEEP_RAM_MODE = PORT_A_READ_DEEP_RAM_MODE,
													PORT_A_READ_LOGICAL_RAM_DEPTH = PORT_A_READ_LOGICAL_RAM_DEPTH,
													PORT_A_READ_LOGICAL_RAM_WIDTH = PORT_A_READ_LOGICAL_RAM_WIDTH,
													PORT_A_READ_ADDRESS_WIDTH = PORT_A_READ_ADDRESS_WIDTH(row),
													PORT_A_DATA_IN_CLOCK = PORT_A_DATA_IN_CLOCK(),
													PORT_A_DATA_IN_CLEAR = PORT_A_DATA_IN_CLEAR(),
													PORT_A_WRITE_LOGIC_CLOCK = PORT_A_WRITE_LOGIC_CLOCK(),
													PORT_A_WRITE_ADDRESS_CLEAR = PORT_A_WRITE_ADDRESS_CLEAR(),
													PORT_A_WRITE_ENABLE_CLEAR = PORT_A_WRITE_ENABLE_CLEAR(),
													PORT_A_READ_ADDRESS_CLOCK = PORT_A_WRITE_LOGIC_CLOCK(),
													PORT_A_READ_ADDRESS_CLEAR = PORT_A_WRITE_ADDRESS_CLEAR(),
													PORT_A_DATA_OUT_CLOCK = PORT_A_DATA_OUT_CLOCK(),
													PORT_A_DATA_OUT_CLEAR = PORT_A_DATA_OUT_CLEAR(),
													PORT_A_WRITE_FIRST_ADDRESS = PORT_A_WRITE_FIRST_ADDRESS(row),
													PORT_A_WRITE_LAST_ADDRESS = PORT_A_WRITE_LAST_ADDRESS(row),
													PORT_A_WRITE_FIRST_BIT_NUMBER = PORT_A_WRITE_FIRST_BIT_NUMBER(col),
													PORT_A_WRITE_DATA_WIDTH = PORT_A_WRITE_DATA_WIDTH(col),
													PORT_A_READ_FIRST_ADDRESS = PORT_A_WRITE_FIRST_ADDRESS(row),
													PORT_A_READ_LAST_ADDRESS = PORT_A_WRITE_LAST_ADDRESS(row),
													PORT_A_READ_FIRST_BIT_NUMBER = PORT_A_READ_FIRST_BIT_NUMBER(col),
													PORT_A_READ_DATA_WIDTH = PORT_A_READ_DATA_WIDTH(col),
													-- Port B parameters
													PORT_B_OPERATION_MODE = PORT_B_OPERATION_MODE,
													PORT_B_LOGICAL_RAM_NAME = PORT_B_LOGICAL_RAM_NAME,
													PORT_B_INIT_FILE = PORT_B_INIT_FILE,
													PORT_B_WRITE_DEEP_RAM_MODE = PORT_B_WRITE_DEEP_RAM_MODE,
													PORT_B_WRITE_LOGICAL_RAM_DEPTH = PORT_B_WRITE_LOGICAL_RAM_DEPTH,
													PORT_B_WRITE_LOGICAL_RAM_WIDTH = PORT_B_WRITE_LOGICAL_RAM_WIDTH,
													PORT_B_WRITE_ADDRESS_WIDTH = PORT_B_WRITE_ADDRESS_WIDTH(row),
													PORT_B_READ_DEEP_RAM_MODE = PORT_B_READ_DEEP_RAM_MODE,
													PORT_B_READ_LOGICAL_RAM_DEPTH = PORT_B_READ_LOGICAL_RAM_DEPTH,
													PORT_B_READ_LOGICAL_RAM_WIDTH = PORT_B_READ_LOGICAL_RAM_WIDTH,
													PORT_B_READ_ADDRESS_WIDTH = PORT_B_WRITE_ADDRESS_WIDTH(row),
													PORT_B_DATA_IN_CLOCK = PORT_B_DATA_IN_CLOCK(),
													PORT_B_DATA_IN_CLEAR = PORT_B_DATA_IN_CLEAR(),
													PORT_B_WRITE_LOGIC_CLOCK = PORT_B_WRITE_LOGIC_CLOCK(),
													PORT_B_WRITE_ADDRESS_CLEAR = PORT_B_WRITE_ADDRESS_CLEAR(),
													PORT_B_WRITE_ENABLE_CLEAR = PORT_B_WRITE_ENABLE_CLEAR(),
													PORT_B_READ_ADDRESS_CLOCK = PORT_B_WRITE_LOGIC_CLOCK(),
													PORT_B_READ_ADDRESS_CLEAR = PORT_B_WRITE_ADDRESS_CLEAR(),
													PORT_B_DATA_OUT_CLOCK = PORT_B_DATA_OUT_CLOCK(),
													PORT_B_DATA_OUT_CLEAR = PORT_B_DATA_OUT_CLEAR(),
													PORT_B_WRITE_FIRST_ADDRESS = PORT_B_WRITE_FIRST_ADDRESS(row),
													PORT_B_WRITE_LAST_ADDRESS = PORT_B_WRITE_LAST_ADDRESS(row),
													PORT_B_WRITE_FIRST_BIT_NUMBER = PORT_B_WRITE_FIRST_BIT_NUMBER(col),
													PORT_B_WRITE_DATA_WIDTH = PORT_B_WRITE_DATA_WIDTH(col),
													PORT_B_READ_FIRST_ADDRESS = PORT_B_WRITE_FIRST_ADDRESS(row),
													PORT_B_READ_LAST_ADDRESS = PORT_B_WRITE_LAST_ADDRESS(row),
													PORT_B_READ_FIRST_BIT_NUMBER = PORT_B_READ_FIRST_BIT_NUMBER(col),
													PORT_B_READ_DATA_WIDTH = PORT_B_READ_DATA_WIDTH(col)
												)
				END GENERATE
			END GENERATE;
		ELSE GENERATE IF DUAL_PORT_MODE() GENERATE
			memory_blocks[ESB_COLS - 1..0][ESB_ROWS - 1..0] :
			FOR col IN ESB_COLS - 1 TO 0 GENERATE
				FOR row IN ESB_ROWS - 1 TO 0 GENERATE
					apexii_ram_block WITH (
												-- Ram-wide parameters
												OPERATION_MODE = "DUAL_PORT",
												INIT_FILE = INTERNAL_FILE,
												LOGICAL_RAM_NAME = LOGICAL_RAM_NAME,
												DATA_INTERLEAVE_OFFSET_IN_BITS = DATA_INTERLEAVE_OFFSET_IN_BITS,
												DATA_INTERLEAVE_WIDTH_IN_BITS = DATA_INTERLEAVE_WIDTH_IN_BITS,
												-- Port A parameters
												PORT_A_OPERATION_MODE = PORT_A_OPERATION_MODE,
												PORT_A_LOGICAL_RAM_NAME = PORT_A_LOGICAL_RAM_NAME,
												PORT_A_INIT_FILE = PORT_A_INIT_FILE,
												PORT_A_WRITE_DEEP_RAM_MODE = PORT_A_WRITE_DEEP_RAM_MODE,
												PORT_A_WRITE_LOGICAL_RAM_DEPTH = PORT_A_WRITE_LOGICAL_RAM_DEPTH,
												PORT_A_WRITE_LOGICAL_RAM_WIDTH = PORT_A_WRITE_LOGICAL_RAM_WIDTH,
												PORT_A_WRITE_ADDRESS_WIDTH = PORT_A_WRITE_ADDRESS_WIDTH(row),
												PORT_A_READ_DEEP_RAM_MODE = PORT_A_READ_DEEP_RAM_MODE,
												PORT_A_READ_LOGICAL_RAM_DEPTH = PORT_A_READ_LOGICAL_RAM_DEPTH,
												PORT_A_READ_LOGICAL_RAM_WIDTH = PORT_A_READ_LOGICAL_RAM_WIDTH,
												PORT_A_READ_ADDRESS_WIDTH = PORT_A_READ_ADDRESS_WIDTH(row),
												PORT_A_DATA_IN_CLOCK = PORT_A_DATA_IN_CLOCK(),
												PORT_A_DATA_IN_CLEAR = PORT_A_DATA_IN_CLEAR(),
												PORT_A_WRITE_LOGIC_CLOCK = PORT_A_WRITE_LOGIC_CLOCK(),
												PORT_A_WRITE_ADDRESS_CLEAR = PORT_A_WRITE_ADDRESS_CLEAR(),
												PORT_A_WRITE_ENABLE_CLEAR = PORT_A_WRITE_ENABLE_CLEAR(),
												PORT_A_READ_ENABLE_CLOCK = PORT_A_READ_ENABLE_CLOCK(),
												PORT_A_READ_ENABLE_CLEAR = PORT_A_READ_ENABLE_CLEAR(),
												PORT_A_READ_ADDRESS_CLOCK = PORT_A_READ_ADDRESS_CLOCK(),
												PORT_A_READ_ADDRESS_CLEAR = PORT_A_READ_ADDRESS_CLEAR(),
												PORT_A_DATA_OUT_CLOCK = PORT_A_DATA_OUT_CLOCK(),
												PORT_A_DATA_OUT_CLEAR = PORT_A_DATA_OUT_CLEAR(),
												PORT_A_WRITE_FIRST_ADDRESS = PORT_A_WRITE_FIRST_ADDRESS(row),
												PORT_A_WRITE_LAST_ADDRESS = PORT_A_WRITE_LAST_ADDRESS(row),
												PORT_A_WRITE_FIRST_BIT_NUMBER = PORT_A_WRITE_FIRST_BIT_NUMBER(col),
												PORT_A_WRITE_DATA_WIDTH = PORT_A_WRITE_DATA_WIDTH(col),
												PORT_A_READ_FIRST_ADDRESS = PORT_A_READ_FIRST_ADDRESS(row),
												PORT_A_READ_LAST_ADDRESS = PORT_A_READ_LAST_ADDRESS(row),
												PORT_A_READ_FIRST_BIT_NUMBER = PORT_A_READ_FIRST_BIT_NUMBER(col),
												PORT_A_READ_DATA_WIDTH = PORT_A_READ_DATA_WIDTH(col)
												-- Port B parameters
												-- not used... fitter will do auto-pack
											)
				END GENERATE
			END GENERATE;
		ELSE GENERATE IF SINGLE_PORT_MODE() GENERATE
			memory_blocks[ESB_COLS - 1..0][ESB_ROWS - 1..0] :
			FOR col IN ESB_COLS - 1 TO 0 GENERATE
				FOR row IN ESB_ROWS - 1 TO 0 GENERATE
					apexii_ram_block WITH (
												-- Ram-wide parameters
												OPERATION_MODE = "SINGLE_PORT",
												INIT_FILE = INTERNAL_FILE,
												LOGICAL_RAM_NAME = LOGICAL_RAM_NAME,
												DATA_INTERLEAVE_OFFSET_IN_BITS = DATA_INTERLEAVE_OFFSET_IN_BITS,
												DATA_INTERLEAVE_WIDTH_IN_BITS = DATA_INTERLEAVE_WIDTH_IN_BITS,
												-- Port A parameters
												PORT_A_OPERATION_MODE = PORT_A_OPERATION_MODE,
												PORT_A_LOGICAL_RAM_NAME = PORT_A_LOGICAL_RAM_NAME,
												PORT_A_INIT_FILE = PORT_A_INIT_FILE,
												PORT_A_WRITE_DEEP_RAM_MODE = PORT_A_WRITE_DEEP_RAM_MODE,
												PORT_A_WRITE_LOGICAL_RAM_DEPTH = PORT_A_WRITE_LOGICAL_RAM_DEPTH,
												PORT_A_WRITE_LOGICAL_RAM_WIDTH = PORT_A_WRITE_LOGICAL_RAM_WIDTH,
												PORT_A_WRITE_ADDRESS_WIDTH = PORT_A_WRITE_ADDRESS_WIDTH(row),
												PORT_A_READ_DEEP_RAM_MODE = PORT_A_READ_DEEP_RAM_MODE,
												PORT_A_READ_LOGICAL_RAM_DEPTH = PORT_A_READ_LOGICAL_RAM_DEPTH,
												PORT_A_READ_LOGICAL_RAM_WIDTH = PORT_A_READ_LOGICAL_RAM_WIDTH,
												PORT_A_READ_ADDRESS_WIDTH = PORT_A_READ_ADDRESS_WIDTH(row),
												PORT_A_DATA_IN_CLOCK = PORT_A_DATA_IN_CLOCK(),
												PORT_A_DATA_IN_CLEAR = PORT_A_DATA_IN_CLEAR(),
												PORT_A_WRITE_LOGIC_CLOCK = PORT_A_WRITE_LOGIC_CLOCK(),
												PORT_A_WRITE_ADDRESS_CLEAR = PORT_A_WRITE_ADDRESS_CLEAR(),
												PORT_A_WRITE_ENABLE_CLEAR = PORT_A_WRITE_ENABLE_CLEAR(),
												PORT_A_READ_ADDRESS_CLOCK = PORT_A_WRITE_LOGIC_CLOCK(),
												PORT_A_READ_ADDRESS_CLEAR = PORT_A_WRITE_ADDRESS_CLEAR(),
												PORT_A_DATA_OUT_CLOCK = PORT_A_DATA_OUT_CLOCK(),
												PORT_A_DATA_OUT_CLEAR = PORT_A_DATA_OUT_CLEAR(),
												PORT_A_WRITE_FIRST_ADDRESS = PORT_A_WRITE_FIRST_ADDRESS(row),
												PORT_A_WRITE_LAST_ADDRESS = PORT_A_WRITE_LAST_ADDRESS(row),
												PORT_A_WRITE_FIRST_BIT_NUMBER = PORT_A_WRITE_FIRST_BIT_NUMBER(col),
												PORT_A_WRITE_DATA_WIDTH = PORT_A_WRITE_DATA_WIDTH(col),
												PORT_A_READ_FIRST_ADDRESS = PORT_A_WRITE_FIRST_ADDRESS(row),
												PORT_A_READ_LAST_ADDRESS = PORT_A_WRITE_LAST_ADDRESS(row),
												PORT_A_READ_FIRST_BIT_NUMBER = PORT_A_READ_FIRST_BIT_NUMBER(col),
												PORT_A_READ_DATA_WIDTH = PORT_A_READ_DATA_WIDTH(col)
												-- Port B parameters
												-- not used... fitter will auto-pack if nercessary
											)
				END GENERATE
			END GENERATE;
		ELSE GENERATE -- IF ROM_MODE() GENERATE  --> check with a later assert to make sure this is true
			memory_blocks[ESB_COLS - 1..0][ESB_ROWS - 1..0] :
			FOR col IN ESB_COLS - 1 TO 0 GENERATE
				FOR row IN ESB_ROWS - 1 TO 0 GENERATE
					apexii_ram_block WITH (
												-- Ram-wide parameters
												OPERATION_MODE = "ROM",
												INIT_FILE = INTERNAL_FILE,
												LOGICAL_RAM_NAME = LOGICAL_RAM_NAME,
												DATA_INTERLEAVE_OFFSET_IN_BITS = DATA_INTERLEAVE_OFFSET_IN_BITS,
												DATA_INTERLEAVE_WIDTH_IN_BITS = DATA_INTERLEAVE_WIDTH_IN_BITS,
												-- Port A parameters
												PORT_A_OPERATION_MODE = PORT_A_OPERATION_MODE,
												PORT_A_LOGICAL_RAM_NAME = PORT_A_LOGICAL_RAM_NAME,
												PORT_A_INIT_FILE = PORT_A_INIT_FILE,
												PORT_A_READ_DEEP_RAM_MODE = PORT_A_READ_DEEP_RAM_MODE,
												PORT_A_READ_LOGICAL_RAM_DEPTH = PORT_A_READ_LOGICAL_RAM_DEPTH,
												PORT_A_READ_LOGICAL_RAM_WIDTH = PORT_A_READ_LOGICAL_RAM_WIDTH,
												PORT_A_READ_ADDRESS_WIDTH = PORT_A_READ_ADDRESS_WIDTH(row),
												PORT_A_READ_ADDRESS_CLOCK = PORT_A_READ_ADDRESS_CLOCK(),
												PORT_A_READ_ADDRESS_CLEAR = PORT_A_READ_ADDRESS_CLEAR(),
												PORT_A_DATA_OUT_CLOCK = PORT_A_DATA_OUT_CLOCK(),
												PORT_A_DATA_OUT_CLEAR = PORT_A_DATA_OUT_CLEAR(),
												PORT_A_READ_FIRST_ADDRESS = PORT_A_READ_FIRST_ADDRESS(row),
												PORT_A_READ_LAST_ADDRESS = PORT_A_READ_LAST_ADDRESS(row),
												PORT_A_READ_FIRST_BIT_NUMBER = PORT_A_READ_FIRST_BIT_NUMBER(col),
												PORT_A_READ_DATA_WIDTH = PORT_A_READ_DATA_WIDTH(col)
											)
				END GENERATE
			END GENERATE;
		END GENERATE; END GENERATE; END GENERATE; END GENERATE;
	END GENERATE;
	END GENERATE;
BEGIN

---------------------
-- Assertion Block --
---------------------
-- Stratix check

	-- CAUSE : 	The design contains altqpram megafunction, but the selected device or device family
	-- 			is the Stratix device family. The altqpram megafunction does not support Stratix device family. The Quartus II
	--			software is attempting to convert the altqpram megafunction implementations to altsyncram megafunction.
	--			However the power up states will be different and also read during write behavior for Stratix devices.
	-- ACTION : No action is necessary. To avoid receiving this message in future, set SUPPRESS_MEMORY_CONVERSION_WARNINGS to ON
	ASSERT ((FAMILY_STRATIX() & SUPPRESS_MEMORY_CONVERSION_WARNINGS == "ON" & (STRATIX_RAM_POSSIBLE() # STRATIX_SPECIAL_CASE())) # FAMILY_STRATIX() != 1 # (STRATIX_VALID_CASE()))
		REPORT "altqpram does not support % device family -- attempting best-case memory conversions, but power-up states and read during write behavior will be different for % devices" DEVICE_FAMILY, DEVICE_FAMILY
		SEVERITY WARNING
		HELP_ID FAMILY_STRATIX_CONVERSION_WARNING;

	-- CAUSE : 	The design contains altqpram megafunction, but the selected device or device family
	-- 			is the Stratix device family. The altqpram megafunction does not support Stratix device family. The Quartus II
	--			software is not able to convert the altqpram megafunction implementations to altsyncram megafunction, and is not 
	--			able to implement it using benchmarking mode, because the ROM is asynchronous.
	-- ACTION : Use at least one clock for input or output and compile again to allow the Quartus II software to attempt to implement using benchmarking mode. 
	ASSERT ((FAMILY_STRATIX() & (STRATIX_RAM_POSSIBLE() # STRATIX_RAM_NOT_IMPOSSIBLE())) # FAMILY_STRATIX() != 1 # QUAD_PORT_MODE())				
		REPORT "Can't convert % mode RAM for % device family using altsyncram megafunction -- at least one clock is needed in order to implement benchmarking mode for altsyncram" OPERATION_MODE, DEVICE_FAMILY
		SEVERITY ERROR
		HELP_ID FAMILY_STRATIX_ROM_NOT_POSSIBLE;


	-- CAUSE : 	The design contains altqpram megafunction, but the selected device or device family
	-- 			is the Stratix device family. The altqpram megafunction does not support Stratix device family. The Quartus II
	--			software is not able to convert the altqpram megafunction implementations to altsyncram megafunction, because the RAM inputs are
	--			not synchronous. The Quartus II software is attempting to implement dual-portRAM using benchmarking mode and by using existing clocks
	-- 			to make it synchronous; however, the output behavior will be different from the original version.
	-- ACTION : No action is required.
	ASSERT ((FAMILY_STRATIX() & STRATIX_RAM_POSSIBLE() != 1 & !STRATIX_RAM_NOT_IMPOSSIBLE())# FAMILY_STRATIX()!= 1 # STRATIX_RAM_POSSIBLE() # QUAD_PORT_MODE() # STRATIX_SPECIAL_CASE())
		REPORT "Can't convert % mode RAM for % device family using altsyncram megafunction -- implementing % RAM using benchmarking mode and attempting to tie up inputs using available clocks, which will cause output behavior to be different. Programming file output will not be generated." OPERATION_MODE, DEVICE_FAMILY, OPERATION_MODE
		SEVERITY WARNING
		HELP_ID FAMILY_STRATIX_RAM_NOT_IMPOSSIBLE;


	--CAUSE: Quad port mode is not supported for Stratix device family
	--ACTION: none.
	ASSERT (FAMILY_STRATIX() != 1 # ((FAMILY_STRATIX() == 1) & !QUAD_PORT_MODE()))
		REPORT "Quad port mode not supported in % device family" DEVICE_FAMILY
		SEVERITY ERROR
		HELP_ID FAMILY_STRATIX_QPRAM_NO_QUAD_PORT;

			
-------------------------
-- Check Maximum Depth --
-------------------------
	ASSERT LEGAL_MAXIMUM_DEPTH(MAXIMUM_DEPTH) # FAMILY_STRATIX() == 1 # MAXIMUM_DEPTH == 0
	REPORT "Illegal value for MAXIMUM_DEPTH (%) parameter" MAXIMUM_DEPTH
	SEVERITY ERROR
	HELP_ID QUAD_MAXIMUM_ILLEGAL;

	-----------------------------
	-- Check the device family --
	-----------------------------
	ASSERT (FAMILY_MERCURY() == 1) # (FAMILY_APEXII() == 1) # (FAMILY_STRATIX() == 1)
	REPORT "altqpram megafunction is only supported for Mercury and Apex II device family. Partial support is available for stratix"
	SEVERITY ERROR
	HELP_ID QUAD_ILLEGAL_DEVICE;

	-------------------
	-- Apex F checks --
	-------------------
	-- Cause: Apex II does not support quad_port_mode
	-- Action: Select a device which has quad_port mode or do not use quad_port mode with Apex II
	ASSERT (FAMILY_APEXII() == 1) !& QUAD_PORT_MODE()
	REPORT "QUAD_PORT mode is not supported by Apex II device family."
	SEVERITY ERROR
	HELP_ID QUAD_AND_APEXF;

	-- Cause:	Apex II does not support using differing widths on the A and B ports when in
	--			BIDIR_DUAL_PORT mode
	-- Action:	Do not use differing widths when in BIDIR_DUAL_PORT mode
	ASSERT !((FAMILY_APEXII() == 1) & BIDIR_DUAL_MODE() & USING_MIXED_MODE())
	REPORT "In Apex II, BIDIR_DUAL_MODE does not support differing widths or depths on the A and B ports"
	SEVERITY ERROR
	HELP_ID BIDIR_MIXED_FOR_APEXII;

	-----------------------------------------------
	-- Legal Parameter Value Checks for Integers --
	-----------------------------------------------
	-- Cause: This parameter must have a value greater than 0
	-- Action: Set the parameter's value to be greater than 0
	ASSERT WIDTH_READ_A_ACTUAL > 0
	REPORT "WIDTH_READ_A (%) must be greater than 0" WIDTH_READ_A
	SEVERITY ERROR
	HELP_ID QUAD_PARAM_MUST_BE_NATURAL;

	ASSERT WIDTHAD_READ_A_ACTUAL > 0
	REPORT "WIDTHAD_READ_A (%) must be greater than 0" WIDTHAD_READ_A
	SEVERITY ERROR
	HELP_ID QUAD_PARAM_MUST_BE_NATURAL;

	ASSERT NUMWORDS_READ_A_ACTUAL > 0
	REPORT "NUMWORDS_READ_A (%) must be greater than 0" NUMWORDS_READ_A
	SEVERITY ERROR
	HELP_ID QUAD_PARAM_MUST_BE_NATURAL;

	ASSERT WIDTH_WRITE_A_ACTUAL > 0
	REPORT "WIDTH_WRITE_A (%) must be greater than 0" WIDTH_WRITE_A
	SEVERITY ERROR
	HELP_ID QUAD_PARAM_MUST_BE_NATURAL;

	ASSERT WIDTHAD_WRITE_A_ACTUAL > 0
	REPORT "WIDTHAD_WRITE_A (%) must be greater than 0" WIDTHAD_WRITE_A
	SEVERITY ERROR
	HELP_ID QUAD_PARAM_MUST_BE_NATURAL;

	ASSERT NUMWORDS_WRITE_A_ACTUAL > 0
	REPORT "NUMWORDS_WRITE_A (%) must be greater than 0" NMUMWORDS_WRITE_A
	SEVERITY ERROR
	HELP_ID QUAD_PARAM_MUST_BE_NATURAL;

	ASSERT WIDTH_WRITE_B_ACTUAL > 0
	REPORT "WIDTH_WRITE_B (%) must be greater than 0" WIDTH_WRITE_B
	SEVERITY ERROR
	HELP_ID QUAD_PARAM_MUST_BE_NATURAL;

	ASSERT WIDTHAD_WRITE_B_ACTUAL > 0
	REPORT "WIDTHAD_WRITE_B (%) must be greater than 0" WIDTHAD_WRITE_B
	SEVERITY ERROR
	HELP_ID QUAD_PARAM_MUST_BE_NATURAL;

	ASSERT NUMWORDS_WRITE_B_ACTUAL > 0
	REPORT "NUMWORDS_WRITE_B (%) must be greater than 0" NUMWORDS_WRITE_B
	SEVERITY ERROR
	HELP_ID QUAD_PARAM_MUST_BE_NATURAL;

	ASSERT WIDTH_READ_B_ACTUAL > 0
	REPORT "WIDTH_READ_B (%) must be greater than 0" WIDTH_READ_B
	SEVERITY ERROR
	HELP_ID QUAD_PARAM_MUST_BE_NATURAL;

	ASSERT WIDTHAD_READ_B_ACTUAL > 0
	REPORT "WIDTHAD_READ_B (%) must be greater than 0" WIDTHAD_READ_B
	SEVERITY ERROR
	HELP_ID QUAD_PARAM_MUST_BE_NATURAL;

	ASSERT NUMWORDS_READ_B_ACTUAL > 0
	REPORT "NUMWORDS_READ_B (%) must be greater than 0" NUMWORDS_READ_B
	SEVERITY ERROR
	HELP_ID QUAD_PARAM_MUST_BE_NATURAL;

	-- Cause: The number of bits used by each port must be equal
	-- Action: Set the ports so that the depth * width of each port is equal
	-- WA <=> RA
	ASSERT BITS_USED_WRITE_PORT_A == BITS_USED_READ_PORT_A
	REPORT "Bits used by write port A (%) does not equal to bits used by read port A (%)" BITS_USED_WRITE_PORT_A,
																							BITS_USED_READ_PORT_A
	SEVERITY ERROR
	HELP_ID QUAD_BIT_USAGE_MISMATCH;

	-- RA <=> WB
	ASSERT BITS_USED_READ_PORT_A == BITS_USED_WRITE_PORT_B
	REPORT "Bits used by read port A (%) does not equal to bits used by write port B (%)" BITS_USED_READ_PORT_A,
																							BITS_USED_WRITE_PORT_B
	SEVERITY ERROR
	HELP_ID QUAD_BIT_USAGE_MISMATCH;

	-- WB <=> RB
	ASSERT BITS_USED_WRITE_PORT_B == BITS_USED_READ_PORT_B
	REPORT "Bits used by write port B (%) does not equal to bits used by read port B (%)" BITS_USED_WRITE_PORT_B,
																							BITS_USED_READ_PORT_B
	SEVERITY ERROR
	HELP_ID QUAD_BIT_USAGE_MISMATCH;

	-- RB <=> WA
	ASSERT BITS_USED_READ_PORT_B == BITS_USED_WRITE_PORT_A
	REPORT "Bits used by read port B (%) does not equal to bits used by write port A (%)" BITS_USED_READ_PORT_B,
																							BITS_USED_WRITE_PORT_A
	SEVERITY ERROR
	HELP_ID QUAD_BIT_USAGE_MISMATCH;

	-- Cause: The number of address bits being used by this port does not agree with its depth
	-- Action: Change the depth and address width parameters for this port so that
	--			2^(address_width - 1) < numwords <= 2^address_width
	ASSERT (2^(WIDTHAD_WRITE_A_ACTUAL - 1) < NUMWORDS_WRITE_A_ACTUAL) & (NUMWORDS_WRITE_A_ACTUAL <= 2^WIDTHAD_WRITE_A_ACTUAL)
	REPORT "WIDTHAD_WRITE_A (%) does not agree with NUMWORDS_WRITE_A (%)" WIDTHAD_WRITE_A, NUMWORDS_WRITE_A
	SEVERITY ERROR
	HELP_ID QUAD_ADDRESS_DEPTH_MISMATCH;

	ASSERT (2^(WIDTHAD_READ_A_ACTUAL - 1) < NUMWORDS_READ_A_ACTUAL) & (NUMWORDS_READ_A_ACTUAL <= 2^WIDTHAD_READ_A_ACTUAL)
	REPORT "WIDTHAD_READ_A (%) does not agree with NUMWORDS_READ_A (%)" WIDTHAD_READ_A, NUMWORDS_READ_A
	SEVERITY ERROR
	HELP_ID QUAD_ADDRESS_DEPTH_MISMATCH;

	ASSERT (2^(WIDTHAD_WRITE_B_ACTUAL - 1) < NUMWORDS_WRITE_B_ACTUAL) & (NUMWORDS_WRITE_B_ACTUAL <= 2^WIDTHAD_WRITE_B_ACTUAL)
	REPORT "WIDTHAD_WRITE_B (%) does not agree with NUMWORDS_WRITE_B (%)" WIDTHAD_WRITE_B_ACTUAL_ACTUAL, NUMWORDS_WRITE_B_ACTUAL
	SEVERITY ERROR
	HELP_ID QUAD_ADDRESS_DEPTH_MISMATCH;

	ASSERT (2^(WIDTHAD_READ_B_ACTUAL - 1) < NUMWORDS_READ_B_ACTUAL) & (NUMWORDS_READ_B_ACTUAL <= 2^WIDTHAD_READ_B_ACTUAL)
	REPORT "WIDTHAD_READ_B (%) does not agree with NUMWORDS_READ_B (%)" WIDTHAD_READ_B_ACTUAL, NUMWORDS_READ_B_ACTUAL
	SEVERITY ERROR
	HELP_ID QUAD_ADDRESS_DEPTH_MISMATCH;

	-- Cause: The data widths on these ports have an illegal ratio
	-- Action: Set the data widths on these ports so their ratio is 1, 2, 4, 8, or 16
	ASSERT RATIOS_ARE_VALID(WIDTH_WRITE_A_ACTUAL, WIDTH_READ_A_ACTUAL)
	REPORT "Ratio between WIDTH_WRITE_A (%) and WIDTH_READ_A (%) is illegal" WIDTH_WRITE_A, WIDTH_READ_A
	SEVERITY ERROR
	HELP_ID QUAD_WIDTH_RATIO_MISMATCH;

	ASSERT RATIOS_ARE_VALID(WIDTH_WRITE_A_ACTUAL, WIDTH_WRITE_B_ACTUAL)
	REPORT "Ratio between WIDTH_WRITE_A (%) and WIDTH_WRITE_B (%) is illegal" WIDTH_WRITE_A, WIDTH_WRITE_B
	SEVERITY ERROR
	HELP_ID QUAD_WIDTH_RATIO_MISMATCH;

	ASSERT RATIOS_ARE_VALID(WIDTH_WRITE_A_ACTUAL, WIDTH_READ_B_ACTUAL)
	REPORT "Ratio between WIDTH_WRITE_A (%) and WIDTH_READ_B (%) is illegal" WIDTH_WRITE_A, WIDTH_READ_B
	SEVERITY ERROR
	HELP_ID QUAD_WIDTH_RATIO_MISMATCH;

	ASSERT RATIOS_ARE_VALID(WIDTH_READ_A_ACTUAL, WIDTH_WRITE_B_ACTUAL)
	REPORT "Ratio between WIDTH_READ_A (%) and WIDTH_WRITE_B (%) is illegal" WIDTH_READ_A, WIDTH_WRITE_B
	SEVERITY ERROR
	HELP_ID QUAD_WIDTH_RATIO_MISMATCH;

	ASSERT RATIOS_ARE_VALID(WIDTH_READ_A_ACTUAL, WIDTH_READ_B_ACTUAL)
	REPORT "Ratio between WIDTH_READ_A (%) and WIDTH_READ_B (%) is illegal" WIDTH_READ_A, WIDTH_READ_B
	SEVERITY ERROR
	HELP_ID QUAD_WIDTH_RATIO_MISMATCH;

	ASSERT RATIOS_ARE_VALID(WIDTH_WRITE_B_ACTUAL, WIDTH_READ_B_ACTUAL)
	REPORT "Ratio between WIDTH_WRITE_B (%) and WIDTH_READ_B (%) is illegal" WIDTH_WRITE_B, WIDTH_READ_B
	SEVERITY ERROR
	HELP_ID QUAD_WIDTH_RATIO_MISMATCH;

	---------------------------------------------
	-- Legal Parameter Value Checks for Strings--
	---------------------------------------------
	-- Cause: Attempting to use ROM without setting INIT_FILE
	-- Action: Set a value for INIT_FILE
	ASSERT !ROM_MODE() # USED(INIT_FILE)
	REPORT "It is illegal to use ROM mode without setting a value for the INIT_FILE parameter."
	SEVERITY ERROR
	HELP_ID ROM_MODE_NO_INIT_FILE;

	-- Cause: There is an illegal operation mode
	-- Action: Set OPERATION_MODE to one of its legal values : "QUAD_PORT", "BIDIR_DUAL_PORT", "DUAL_PORT", "SINGLE_PORT",
	--			or "ROM"
	ASSERT QUAD_PORT_MODE() # BIDIR_DUAL_MODE() # DUAL_PORT_MODE() # SINGLE_PORT_MODE() # ROM_MODE()
	REPORT "OPERATION_MODE (%) is set to an illegal value" OPERATION_MODE
	SEVERITY ERROR
	HELP_ID QUAD_PORT_ILLEGAL_OPERATION_MODE;

	-- Cause: This registering parameter is set to an illegal value
	-- Action: Change the value to one of the legal values: "INCLOCK_A" or "UNREGISTERED"
	ASSERT (WRCONTROL_WRADDRESS_REG_A == "INCLOCK_A") # (WRCONTROL_WRADDRESS_REG_A == "UNREGISTERED")
	REPORT "WRCONTROL_WRADDRESS_REG (%) must be set to ""INCLOCK_A"" or ""UNREGISTERED""" WRCONTROL_WRADDRESS_REG_A
	SEVERITY ERROR
	HELP_ID QUAD_INPUTA_REGISTERING_IS_ILLEGAL;

	ASSERT (INDATA_REG_A == "INCLOCK_A") # (INDATA_REG_A == "UNREGISTERED")
	REPORT "INDATA_REG_A (%) must be set to ""INCLOCK_A"" or ""UNREGISTERED""" INDATA_REG_A
	SEVERITY ERROR
	HELP_ID QUAD_INPUTA_REGISTERING_IS_ILLEGAL;
	
	-- Cause: This registering parameter is set to an illegal value
	-- Action: Change the value to one of the legal values: "INCLOCK_B" or "UNREGISTERED"
	ASSERT (INDATA_REG_B == "INCLOCK_B") # (INDATA_REG_B == "UNREGISTERED")
	REPORT "INDATA_REG_B (%) must be set to ""INCLOCK_B"" or ""UNREGISTERED""" INDATA_REG_B
	SEVERITY ERROR
	HELP_ID QUAD_INPUTB_REGISTERING_IS_ILLEGAL;

	ASSERT (WRCONTROL_WRADDRESS_REG_B == "INCLOCK_B") # (WRCONTROL_WRADDRESS_REG_B == "UNREGISTERED")
	REPORT "WRCONTROL_WRADDRESS_REG_B (%) must be set to ""INCLOCK_B"" or ""UNREGISTERED""" WRCONTROL_WRADDRESS_REG_B
	SEVERITY ERROR
	HELP_ID QUAD_INPUTB_REGISTERING_IS_ILLEGAL;

	-- Cause: This registering parameter is set to an illegal value
	-- Action: Change the value to one of the legal values: "INCLOCK_A", "OUTCLOCK_A", or "UNREGISTERED"
	ASSERT (RDCONTROL_REG_A == "INCLOCK_A") # (RDCONTROL_REG_A == "OUTCLOCK_A") # (RDCONTROL_REG_A == "UNREGISTERED")
	REPORT "RDCONTROL_REG_A (%) must be set to ""INCLOCK_A"", ""OUTCLOCK_A"", or ""UNREGISTERED""" RDCONTROL_REG_A
	SEVERITY ERROR
	HELP_ID QUAD_OUTPUTA_REGISTERING_IS_ILLEGAL;

	ASSERT (RDADDRESS_REG_A == "INCLOCK_A") # (RDADDRESS_REG_A == "OUTCLOCK_A") # (RDADDRESS_REG_A == "UNREGISTERED")
	REPORT "RDADDRESS_REG_A (%) must be set to ""INCLOCK_A"", ""OUTCLOCK_A"", or ""UNREGISTERED""" RDADDRESS_REG_A
	SEVERITY ERROR
	HELP_ID QUAD_OUTPUTA_REGISTERING_IS_ILLEGAL;

	ASSERT (OUTDATA_REG_A == "INCLOCK_A") # (OUTDATA_REG_A == "OUTCLOCK_A") # (OUTDATA_REG_A == "UNREGISTERED")
	REPORT "OUTDATA_REG_A (%) must be set to ""INCLOCK_A"", ""OUTCLOCK_A"", or ""UNREGISTERED""" OUTDATA_REG_A
	SEVERITY ERROR
	HELP_ID QUAD_OUTPUTA_REGISTERING_IS_ILLEGAL;

	-- Cause: This registering parameter is set to an illegal value
	-- Action: Change the value to one of the legal values: "INCLOCK_B", "OUTCLOCK_B", or "UNREGISTERED"
	ASSERT (RDCONTROL_REG_B == "INCLOCK_B") # (RDCONTROL_REG_B == "OUTCLOCK_B") # (RDCONTROL_REG_B == "UNREGISTERED")
	REPORT "RDCONTROL_REG_B (%) must be set to ""INCLOCK_B"", ""OUTCLOCK_B"", or ""UNREGISTERED""" RDCONTROL_REG_B
	SEVERITY ERROR
	HELP_ID QUAD_OUTPUTB_REGISTERING_IS_ILLEGAL;

	ASSERT (RDADDRESS_REG_B == "INCLOCK_B") # (RDADDRESS_REG_B == "OUTCLOCK_B") # (RDADDRESS_REG_B == "UNREGISTERED")
	REPORT "RDADDRESS_REG_B (%) must be set to ""INCLOCK_B"", ""OUTCLOCK_B"", or ""UNREGISTERED""" RDADDRESS_REG_B
	SEVERITY ERROR
	HELP_ID QUAD_OUTPUTB_REGISTERING_IS_ILLEGAL;

	ASSERT (OUTDATA_REG_B == "INCLOCK_B") # (OUTDATA_REG_B == "OUTCLOCK_B") # (OUTDATA_REG_B == "UNREGISTERED")
	REPORT "OUTDATA_REG_B (%) must be set to ""INCLOCK_B"", ""OUTCLOCK_B"", or ""UNREGISTERED""" OUTDATA_REG_B
	SEVERITY ERROR
	HELP_ID QUAD_OUTPUTB_REGISTERING_IS_ILLEGAL;

	-- Cause: This parameter has set an illegal asynchronous clear value
	-- Action: Change the value for this parameter to "INACLR_A" and "NONE"
	ASSERT (WRCONTROL_ACLR_A == "INACLR_A") # (WRCONTROL_ACLR_A == "NONE")
	REPORT "WRCONTROL_ACLR_A (%) must be set to ""INACLR_A"" or to ""NONE""" WRCONTROL_ACLR_A
	SEVERITY ERROR
	HELP_ID QUAD_INACLRA_ONLY_LEGAL;

	ASSERT (WRADDRESS_ACLR_A == "INACLR_A") # (WRADDRESS_ACLR_A == "NONE")
	REPORT "WRADDRESS_ACLR_A (%) must be set to ""INACLR_A"" or to ""NONE""" WRADRRESS_ACLR_A
	SEVERITY ERROR
	HELP_ID QUAD_INACLRA_ONLY_LEGAL;

	ASSERT (INDATA_ACLR_A == "INACLR_A") # (INDATA_ACLR_A == "NONE")
	REPORT "INDATA_ACLR_A (%) must be set to ""INACLR_A"" or to ""NONE""" INDATA_ACLR_A
	SEVERITY ERROR
	HELP_ID QUAD_INACLRA_ONLY_LEGAL;

	-- Cause: This parameter has set an illegal asynchronous clear value
	-- Action: Change the value for this parameter to "INACLR_B" or "NONE"
	ASSERT (INDATA_ACLR_B == "INACLR_B") # (INDATA_ACLR_B == "NONE")
	REPORT "INDATA_ACLR_B (%) must be set to ""INACLR_B"" or to ""NONE""" INDATA_ACLR_B
	SEVERITY ERROR
	HELP_ID QUAD_INACLRB_ONLY_LEGAL;

	ASSERT (WRADDRESS_ACLR_B == "INACLR_B") # (WRADDRESS_ACLR_B == "NONE")
	REPORT "WRADDRESS_ACLR_B (%) must be set to ""INACLR_B"" or to ""NONE""" WRADDRESS_ACLR_B
	SEVERITY ERROR
	HELP_ID QUAD_INACLRB_ONLY_LEGAL;

	ASSERT (WRCONTROL_ACLR_B == "INACLR_B") # (WRCONTROL_ACLR_B == "NONE")
	REPORT "WRCONTROL_ACLR_B (%) must be set to ""INACLR_B"" or to ""NONE""" WRCONTROL_ACLR_B
	SEVERITY ERROR
	HELP_ID QUAD_INACLRB_ONLY_LEGAL;

	-- Cause: This parameter has set an illegal asynchronous clear value
	-- Action: Change the value for this parameter to "INACLR_A", "OUTACLR_A", or "NONE"
	ASSERT (RDCONTROL_ACLR_A == "INACLR_A") # (RDCONTROL_ACLR_A == "OUTACLR_A") # (RDCONTROL_ACLR_A == "NONE")
	REPORT "RDCONTROL_ACLR_A (%) must be set to ""INACLR_A"", ""OUTACLR_A"", or ""NONE""" RDCONTROL_ACLR_A
	SEVERITY ERROR
	HELP_ID QUAD_OUTACLRA_ILLEGAL;

	ASSERT (RDADDRESS_ACLR_A == "INACLR_A") # (RDADDRESS_ACLR_A == "OUTACLR_A") # (RDADDRESS_ACLR_A == "NONE")
	REPORT "RDADDRESS_ACLR_A (%) must be set to ""INACLR_A"", ""OUTACLR_A"", or ""NONE""" RDADDRESS_ACLR_A
	SEVERITY ERROR
	HELP_ID QUAD_OUTACLRA_ILLEGAL;

	ASSERT (OUTDATA_ACLR_A == "INACLR_A") # (OUTDATA_ACLR_A == "OUTACLR_A") # (OUTDATA_ACLR_A == "NONE")
	REPORT "OUTDATA_ACLR_A (%) must be set to ""INACLR_A"", ""OUTACLR_A"", or ""NONE""" OUTDATA_ACLR_A
	SEVERITY ERROR
	HELP_ID QUAD_OUTACLRA_ILLEGAL;

	-- Cause: This parameter has set an illegal asynchronous clear value
	-- Action: Change the value for this parameter to "INACLR_B", "OUTACLR_B", or "NONE"
	ASSERT (RDCONTROL_ACLR_B == "INACLR_B") # (RDCONTROL_ACLR_B == "OUTACLR_B") # (RDCONTROL_ACLR_B == "NONE")
	REPORT "RDCONTROL_ACLR_B (%) must be set to ""INACLR_B"", ""OUTACLR_B"", or ""NONE""" RDCONTROL_ACLR_B
	SEVERITY ERROR
	HELP_ID QUAD_OUTACLRB_ILLEGAL;

	ASSERT (RDADDRESS_ACLR_B == "INACLR_B") # (RDADDRESS_ACLR_B == "OUTACLR_B") # (RDADDRESS_ACLR_B == "NONE")
	REPORT "RDADDRESS_ACLR_B (%) must be set to ""INACLR_B"", ""OUTACLR_B"", or ""NONE""" RDADDRESS_ACLR_B
	SEVERITY ERROR
	HELP_ID QUAD_OUTACLRB_ILLEGAL;

	ASSERT (OUTDATA_ACLR_B == "INACLR_B") # (OUTDATA_ACLR_B == "OUTACLR_B") # (OUTDATA_ACLR_B == "NONE")
	REPORT "OUTDATA_ACLR_B (%) must be set to ""INACLR_B"", ""OUTACLR_B"", or ""NONE""" OUTDATA_ACLR_B
	SEVERITY ERROR
	HELP_ID QUAD_OUTACLRB_ILLEGAL;


	----------------------------------------
	-- Sweep for illegal port connections --
	----------------------------------------
	-- Cause: A port is connected for a mode in which use of the port is illegal
	-- Action: Use a different mode in which the parameter is legal or do not use the
	--			port
	ASSERT !ROM_MODE() # !USED(wren_a)
	REPORT "Use of 'wren_a' is illegal in ROM mode"
	SEVERITY ERROR
	HELP_ID QUAD_ILLEGAL_PORT_CONNECT_ERROR;
	
	ASSERT QUAD_PORT_MODE() # BIDIR_DUAL_MODE() # !USED(wren_b)
	REPORT "Use of 'wren'b' is illegal in % mode" OPERATION_MODE
	SEVERITY ERROR
	HELP_ID QUAD_ILLEGAL_PORT_CONNECT_ERROR;

	ASSERT !ROM_MODE() # !USED(data_a)
	REPORT "Use of 'data_a' is illegal in ROM mode"
	SEVERITY ERROR
	HELP_ID QUAD_ILLEGAL_PORT_CONNECT_ERROR;

	ASSERT QUAD_PORT_MODE() # BIDIR_DUAL_MODE() # !USED(data_b)
	REPORT "Use of 'data_b' is illegal in % mode" OPERATION_MODE
	SEVERITY ERROR
	HELP_ID QUAD_ILLEGAL_PORT_CONNECT_ERROR;

	ASSERT !ROM_MODE() # !USED(wraddress_a)
	REPORT "Use of 'wraddress_a' is illegal in % mode" OPERATION_MODE
	SEVERITY ERROR
	HELP_ID QUAD_ILLEGAL_PORT_CONNECT_ERROR;

	ASSERT QUAD_PORT_MODE() # BIDIR_DUAL_MODE() # !USED(wraddress_b)
	REPORT "Use of 'wraddress_b' is illegal in % mode" OPERATION_MODE
	SEVERITY ERROR
	HELP_ID QUAD_ILLEGAL_PORT_CONNECT_ERROR;

	ASSERT QUAD_PORT_MODE() # BIDIR_DUAL_MODE() # !USED(inclock_b)
	REPORT "Use of 'inclock_b' is illegal in % mode" OPERATION_MODE
	SEVERITY ERROR
	HELP_ID QUAD_ILLEGAL_PORT_CONNECT_ERROR;

	ASSERT QUAD_PORT_MODE() # BIDIR_DUAL_MODE() # !USED(inclocken_b)
	REPORT "Use of 'inclocken_b' is illegal in % mode" OPERATION_MODE
	SEVERITY ERROR
	HELP_ID QUAD_ILLEGAL_PORT_CONNECT_ERROR;

	ASSERT QUAD_PORT_MODE() # DUAL_PORT_MODE() # !USED(rden_a)
	REPORT "Use of 'rden_a' is illegal in % mode" OPERATION_MODE
	SEVERITY ERROR
	HELP_ID QUAD_ILLEGAL_PORT_CONNECT_ERROR;

	ASSERT QUAD_PORT_MODE() # !USED(rden_b)
	REPORT "Use of 'rden_b' is illegal in % mode" OPERATION_MODE
	SEVERITY ERROR
	HELP_ID QUAD_ILLEGAL_PORT_CONNECT_ERROR;

	ASSERT (SINGLE_PORT_MODE() !# BIDIR_DUAL_MODE()) # !USED(rdaddress_a)
	REPORT "Use of 'rdaddress_a' is illegal in % mode" OPERATION_MODE
	SEVERITY ERROR
	HELP_ID QUAD_ILLEGAL_PORT_CONNECT_ERROR;

	ASSERT QUAD_PORT_MODE() # !USED(rdaddress_b)
	REPORT "Use of 'rdaddress_b' is illegal in % mode" OPERATION_MODE
	SEVERITY ERROR
	HELP_ID QUAD_ILLEGAL_PORT_CONNECT_ERROR;

	ASSERT QUAD_PORT_MODE() # BIDIR_DUAL_MODE() # !USED(outclock_b)
	REPORT "Use of 'outclock_b' is illegal in % mode" OPERATION_MODE
	SEVERITY ERROR
	HELP_ID QUAD_ILLEGAL_PORT_CONNECT_ERROR;

	ASSERT QUAD_PORT_MODE() # BIDIR_DUAL_MODE() # !USED(outclocken_b)
	REPORT "Use of 'outclocken_b' is illegal in % mode" OPERATION_MODE
	SEVERITY ERROR
	HELP_ID QUAD_ILLEGAL_PORT_CONNECT_ERROR;

	ASSERT QUAD_PORT_MODE() # BIDIR_DUAL_MODE() # !USED(inaclr_b)
	REPORT "Use of 'inaclr_b' is illegal in % mode" OPERATION_MODE
	SEVERITY ERROR
	HELP_ID QUAD_ILLEGAL_PORT_CONNECT_ERROR;

	ASSERT QUAD_PORT_MODE() # BIDIR_DUAL_MODE() # !USED(q_b)
	REPORT "Use of 'q_b' is illegal in % mode" OPERATION_MODE
	SEVERITY ERROR
	HELP_ID QUAD_ILLEGAL_PORT_CONNECT_ERROR;

	-------------------------------------------------------------
	-- Check to see that port usage and parameter values agree --
	-------------------------------------------------------------
	-- Cause: The values of the registering parameters do not agree with the
	--			usage of this clock
	-- Action: Make sure that the registering parameters agree with the usage of a clock
	--			signal
	---------------
	-- inclock_a --
	---------------
	ASSERT USED(inclock_a) !$	((PORT_A_DATA_IN_CLOCK() == CLOCK_AZ) #
								(PORT_A_WRITE_LOGIC_CLOCK() == CLOCK_AZ) #
								(PORT_A_READ_ENABLE_CLOCK() == CLOCK_AZ) #
								(PORT_A_READ_ADDRESS_CLOCK() == CLOCK_AZ) #
								(PORT_A_DATA_OUT_CLOCK() == CLOCK_AZ))
	REPORT "The usage of 'inclock_a' does not agree with its registering parameters."
	SEVERITY ERROR
	HELP_ID QUAD_CLOCK_MISCONNECT;

	---------------
	-- inclock_b --
	---------------
	ASSERT USED(inclock_b) !$	((PORT_B_DATA_IN_CLOCK() == CLOCK_BZ) #
								(PORT_B_WRITE_LOGIC_CLOCK() == CLOCK_BZ) #
								(PORT_B_READ_ENABLE_CLOCK() == CLOCK_BZ) #
								(PORT_B_READ_ADDRESS_CLOCK() == CLOCK_BZ) #
								(PORT_B_DATA_OUT_CLOCK() == CLOCK_BZ))
	REPORT "The usage of 'inclock_b' does not agree with its registering parameters."
	SEVERITY ERROR
	HELP_ID QUAD_CLOCK_MISCONNECT;

	----------------
	-- outclock_a --
	----------------
	ASSERT USED(outclock_a) !$	((PORT_A_READ_ENABLE_CLOCK() == CLOCK_AO) #
								(PORT_A_READ_ADDRESS_CLOCK() == CLOCK_AO) #
								(PORT_A_DATA_OUT_CLOCK() == CLOCK_AO))
	REPORT "The usage of 'outclock_a' does not agree with its registering parameters."
	SEVERITY ERROR
	HELP_ID QUAD_CLOCK_MISCONNECT;

	----------------
	-- outclock_b --
	----------------
	ASSERT USED(outclock_b) !$	((PORT_B_READ_ADDRESS_CLOCK() == CLOCK_BO) #
								(PORT_B_READ_ENABLE_CLOCK() == CLOCK_BO) #
								(PORT_B_DATA_OUT_CLOCK() == CLOCK_BO))
	REPORT "The usage of 'outclock_b' does not agree with its registering parameters."
	SEVERITY ERROR
	HELP_ID QUAD_CLOCK_MISCONNECT;

	------------------------
	-- Clock Enable Check --
	------------------------
	-- Cause: A clock enable is connected, however, its associated clock is not connected
	-- Action: Disconnect the clock enable or connect the clock
	ASSERT !USED(inclocken_a) # USED(inclock_a)
	REPORT "'inclocken_a' is connected but 'inclock_a' is not connected."
	SEVERITY ERROR
	HELP_ID QUAD_CLOCK_ENABLE_MISMATCH;

	ASSERT !USED(inclocken_b) # USED(inclock_b)
	REPORT "'inclocken_b' is connected but 'inclock_b' is not connected."
	SEVERITY ERROR
	HELP_ID QUAD_CLOCK_ENABLE_MISMATCH;

	ASSERT !USED(outclocken_a) # USED(outclock_a)
	REPORT "'outclocken_a' is connected but 'outclock_a' is not connected."
	SEVERITY ERROR
	HELP_ID QUAD_CLOCK_ENABLE_MISMATCH;

	ASSERT !USED(outclocken_b) # USED(outclock_b)
	REPORT "'outclocken_b' is connected but 'outclock_b' is not connected."
	SEVERITY ERROR
	HELP_ID QUAD_CLOCK_ENABLE_MISMATCH;

	-----------------
	-- Clear Check --
	-----------------
	-- Cause: The usage of the clear port does not agree with the clearing parameter values
	-- Action: Change the usage of the clear port to match the values of the clearing parameters
	ASSERT !USED(inaclr_a) #	((PORT_A_DATA_IN_CLEAR() == CLEAR_AZ) #
								(PORT_A_WRITE_ENABLE_CLEAR() == CLEAR_AZ) #
								(PORT_A_WRITE_ADDRESS_CLEAR() == CLEAR_AZ) #
								(PORT_A_READ_ENABLE_CLEAR() == CLEAR_AZ) #
								(PORT_A_READ_ADDRESS_CLEAR() == CLEAR_AZ) #
								(PORT_A_DATA_OUT_CLEAR() == CLEAR_AZ))
	REPORT "The usage of 'inaclr_a' does not agree with the clearing parameter values"
	SEVERITY ERROR
	HELP_ID QUAD_CLEARING_PARAM_MISMATCH;

	-- Cause: The write control logic is not affected by the clear, but the write address is.
	-- Action: If a clear affects the write address registers, it must also affect the
	--			write control registers
	ASSERT !USED(inaclr_a) #	((PORT_A_WRITE_ENABLE_CLEAR() == "UNUSED") !& (PORT_A_WRITE_ADDRESS_CLEAR() == CLEAR_AZ))
	REPORT "If the write control registeres are not affected by an asynchronous clear, neither can the write address registers."
	SEVERITY ERROR
	HELP_ID QUAD_ILLEGAL_CLEARING_COMBO;

	ASSERT !USED(inaclr_b) #	((PORT_B_WRITE_ENABLE_CLEAR() == "UNUSED") !& (PORT_B_WRITE_ADDRESS_CLEAR() == CLEAR_BZ))
	REPORT "If the write control registers are not affected by an asynchronous clear, neither can the write address registers."
	SEVERITY ERROR
	HELP_ID QUAD_ILLEGAL_CLEARING_COMBO;

	ASSERT !USED(inaclr_b) #	((PORT_B_DATA_IN_CLEAR() == CLEAR_BZ) #
								(PORT_B_WRITE_ENABLE_CLEAR() == CLEAR_BZ) #
								(PORT_B_WRITE_ADDRESS_CLEAR() == CLEAR_BZ) #
								(PORT_B_READ_ENABLE_CLEAR() == CLEAR_BZ) #
								(PORT_B_READ_ADDRESS_CLEAR() == CLEAR_BZ) #
								(PORT_B_DATA_OUT_CLEAR() == CLEAR_BZ))
	REPORT "The usage of 'inaclr_b' does not agree with the clearing parameter values"
	SEVERITY ERROR
	HELP_ID QUAD_CLEARING_PARAM_MISMATCH;

	ASSERT !USED(outaclr_a) #	((PORT_A_READ_ENABLE_CLEAR() == CLEAR_AO) #
								(PORT_A_READ_ADDRESS_CLEAR() == CLEAR_AO) #
								(PORT_A_DATA_OUT_CLEAR() == CLEAR_AO))
	REPORT "The usage of 'outaclr_a' does not agree with the clearing parameter values"
	SEVERITY ERROR
	HELP_ID QUAD_CLEARING_PARAM_MISMATCH;

	ASSERT !USED(outaclr_b) #	((PORT_B_READ_ENABLE_CLEAR() == CLEAR_BO) #
								(PORT_B_READ_ADDRESS_CLEAR() == CLEAR_BO) #
								(PORT_B_DATA_OUT_CLEAR() == CLEAR_BO))
	REPORT "The usage of 'outaclr_b' does not agree with the clearing parameter values"
	SEVERITY ERROR
	HELP_ID QUAD_CLEARING_PARAM_MISMATCH;

	---------------------------------------------
	-- Force Defenition of Required Parameters --
	---------------------------------------------
	-- Cause: This parameter is not defined
	-- Action: Set a value for this parameter
	ASSERT SINGLE_PORT_MODE() # BIDIR_DUAL_MODE() # USED(WIDTH_READ_A)
	REPORT "WIDTH_READ_A must be passed a value in % mode" OPERATION_MODE
	SEVERITY ERROR
	HELP_ID QUAD_NECESSARY_PARAM_UNDEFINED;

	ASSERT SINGLE_PORT_MODE() # BIDIR_DUAL_MODE() # USED(WIDTHAD_READ_A)
	REPORT "WIDTHAD_READ_A must be passed a value in % mode" OPERATION_MODE
	SEVERITY ERROR
	HELP_ID QUAD_NECESSARY_PARAM_UNDEFINED;

	ASSERT ROM_MODE() # USED(WIDTH_WRITE_A)
	REPORT "WIDTH_WRITE_A must be passed a value in % mode" OPERATION_MODE
	SEVERITY ERROR
	HELP_ID QUAD_NECESSARY_PARAM_UNDEFINED;

	ASSERT ROM_MODE() # USED(WIDTHAD_WRITE_A)
	REPORT "WIDTHAD_WRITE_A must be passed a value in % mode" OPERATION_MODE
	SEVERITY ERROR
	HELP_ID QUAD_NECESSARY_PARAM_UNDEFINED;

	ASSERT (QUAD_PORT_MODE() !# BIDIR_DUAL_MODE()) # USED(WIDTH_WRITE_B)
	REPORT "WIDTH_WRITE_B must be passed a value in % mode" OPERATION_MODE
	SEVERITY ERROR
	HELP_ID QUAD_NECESSARY_PARAM_UNDEFINED;

	ASSERT (QUAD_PORT_MODE() !# BIDIR_DUAL_MODE()) # USED(WIDTHAD_WRITE_B)
	REPORT "WIDTHAD_WRITE_B must be passed a value in % mode" OPERATION_MODE
	SEVERITY ERROR
	HELP_ID QUAD_NECESSARY_PARAM_UNDEFINED;

	ASSERT !QUAD_PORT_MODE() # USED(WIDTH_READ_B)
	REPORT "WIDTH_READ_B must be passed a value in QUAD_PORT mode"
	SEVERITY ERROR
	HELP_ID QUAD_NECESSARY_PARAM_UNDEFINED;

	ASSERT !QUAD_PORT_MODE() # USED(WIDTHAD_READ_B)
	REPORT "WIDTHAD_READ_B must be passed a value in QUAD_PORT mode"
	SEVERITY ERROR
	HELP_ID QUAD_NECESSARY_PARAM_UNDEFINED;

	----------------------------------------
	-- Force Connection of Required Ports --
	----------------------------------------
	-- Cause: This port is not connected in a mode which expects it to be connected
	-- Action: Connect the port or use a mode in which this port is not required
	ASSERT ROM_MODE() # USED(wren_a)
	REPORT "In % mode, wren_a must be connected" OPERATION_MODE
	SEVERITY ERROR
	HELP_ID QUAD_FORCING_PORT_CONNECTION;

	ASSERT (QUAD_PORT_MODE() !# BIDIR_DUAL_MODE()) # USED(wren_b)
	REPORT "In % mode, wren_b must be connected" OPERATION_MODE
	SEVERITY ERROR
	HELP_ID QUAD_FORCING_PORT_CONNECTION;

	ASSERT ROM_MODE() # USED(wraddress_a)
	REPORT "In % mode, wraddress_a must be connected" OPERATION_MODE
	SEVERITY ERROR
	HELP_ID QUAD_FORCING_PORT_CONNECTION;

	ASSERT (QUAD_PORT_MODE() !# BIDIR_DUAL_MODE()) # USED(wraddress_b)
	REPORT "In % mode, wraddress_b must be connected" OPERATION_MODE
	SEVERITY ERROR
	HELP_ID QUAD_FORCING_PORT_CONNECTION;

	ASSERT !USED_READ_A_PORT() # (!QUAD_PORT_MODE() & !DUAL_PORT_MODE() & !ROM_MODE()) # USED(rdaddress_a)
	REPORT "In % mode, rdaddress_a must be connected" OPERATION_MODE
	SEVERITY ERROR
	HELP_ID QUAD_FORCING_PORT_CONNECTION;

	ASSERT !USED_READ_B_PORT() # !QUAD_PORT_MODE() # USED(rdaddress_b)
	REPORT "In % mode, rdaddress_b must be connected" OPERATION_MODE
	SEVERITY ERROR
	HELP_ID QUAD_FORCING_PORT_CONNECTION;

	IF DUMP_PARAMETERS() GENERATE
		ASSERT REPORT "MAX_DEPTH_ENTERED = %" MAX_DEPTH_ENTERED SEVERITY INFO;
		ASSERT REPORT "DEPTH = %" GEN_DEPTH SEVERITY INFO;
		ASSERT REPORT "OPERATION_MODE = %" OPERATION_MODE SEVERITY INFO;
		ASSERT REPORT "ESB_COLS = %" ESB_COLS SEVERITY INFO;
		ASSERT REPORT "ESB_ROWS = %" ESB_ROWS SEVERITY INFO;
		ASSERT REPORT "DATA_INTERLEAVE_WIDTH_IN_BITS %" DATA_INTERLEAVE_WIDTH_IN_BITS SEVERITY INFO;
		ASSERT REPORT "DATA_INTERLEAVE_OFFSET_IN_BITS %" DATA_INTERLEAVE_OFFSET_IN_BITS SEVERITY INFO;
		ASSERT REPORT "EXTERNAL_ADDRESS_BITS %" EXTERNAL_ADDRESS_BITS SEVERITY INFO;
	END GENERATE;

----------------
-- Code Block --
----------------
	-- STRATIX case
	IF FAMILY_STRATIX() GENERATE
		IF STRATIX_RAM_POSSIBLE() # STRATIX_RAM_NOT_IMPOSSIBLE() GENERATE
			IF ROM_MODE() GENERATE
				ram_block.address_a[] = rdaddress_a[];
				IF WIDTH_READ_A == 1 GENERATE
					q_a[0] = ram_block.q_a[0];
				ELSE GENERATE
					q_a[] = ram_block.q_a[];
				END GENERATE;
				IF STRATIX_ROM_CLOCK0() == "INCLOCK_A" GENERATE
					IF STRATIX_RAM_POSSIBLE() != 1 & !STRATIX_RAM_POSSIBLE() GENERATE
						-- CAUSE: inclock_a is used to clock inputs to the ROM for Stratix device family
						-- ACTION: None.
						ASSERT(0)
						REPORT "Inclock_a is used to clock rdaddress_a port to the rom in benchmarking mode"
						SEVERITY INFO;
					END GENERATE;
					ram_block.clock0 = inclock_a;
					IF USED(inclocken_a) GENERATE
						ram_block.clocken0 = inclocken_a;
					END GENERATE;
					IF STRATIX_ROM_NEED_CLOCK1() GENERATE
						IF STRATIX_ROM_CLOCK1() == "OUTCLOCK_A" GENERATE
							ram_block.clock1 = outclock_a;
							IF USED(outclocken_a) GENERATE
								ram_block.clocken1 = outclocken_a;
							END GENERATE;
						END GENERATE;
					END GENERATE;
				ELSE GENERATE
					IF STRATIX_RAM_POSSIBLE() != 1  & !STRATIX_RAM_POSSIBLE() GENERATE
						-- CAUSE: outclock_a is used to clock inputs to the ROM for Stratix device family
						-- ACTION: None.
						ASSERT(0)
						REPORT "Outclock_a is used to clock rdaddress_a port to the rom in benchmarking mode"
						SEVERITY INFO;
					END GENERATE;
					ram_block.clock0 = outclock_a;
					IF USED(outclocken_a) GENERATE
						ram_block.clocken0 = outclocken_a;
					END GENERATE;
					IF STRATIX_ROM_NEED_CLOCK1() GENERATE
						IF STRATIX_ROM_CLOCK1() == "INCLOCK_A" GENERATE
							ram_block.clock1 = inclock_a;
							IF USED(inclocken_a) GENERATE
								ram_block.clocken1 = inclocken_a;
							END GENERATE;
						END GENERATE;
					END GENERATE;
				END GENERATE;
				IF STRATIX_ROM_NEED_CLEAR0() GENERATE
					IF STRATIX_ROM_CLEAR0() == "INACLR_A" GENERATE
						ram_block.aclr0 = inaclr_a;
					ELSE GENERATE
						IF STRATIX_ROM_CLEAR0() == "OUTACLR_A" GENERATE
							ram_block.aclr0 = outaclr_a;
						END GENERATE;
					END GENERATE;
				END GENERATE;
				IF STRATIX_ROM_NEED_CLEAR1() GENERATE
					IF STRATIX_ROM_CLEAR1() == "INACLR_A" GENERATE
						ram_block.aclr1 = inaclr_a;
					END GENERATE;
					IF STRATIX_ROM_CLEAR1() == "OUTACLR_A" GENERATE
						ram_block.aclr1 = outaclr_a;
					END GENERATE;
				END GENERATE;
			END GENERATE;			
			IF SINGLE_PORT_MODE() GENERATE
				ram_block.address_a[] = wraddress_a[];
				IF WIDTH_WRITE_A == 1 GENERATE
					q_a[0] = ram_block.q_a[0];
				ELSE GENERATE
					q_a[] = ram_block.q_a[];
				END GENERATE;
				ram_block.data_a[] = data_a[];
				ram_block.wren_a = wren_a;
				IF STRATIX_SP_CLOCK0() == "INCLOCK_A" GENERATE
					IF STRATIX_RAM_POSSIBLE() != 1 & !STRATIX_RAM_POSSIBLE()  GENERATE
						-- CAUSE: inclock_a is used to clock inputs to the single-port RAM for Stratix device family
						-- ACTION: None.
						ASSERT(0)
						REPORT "inclock_a is used to clock wraddress_a port, data_a port and wren_a port to the single-port ram in benchmarking mode"
						SEVERITY INFO;
					END GENERATE;
					ram_block.clock0 = inclock_a;
					IF USED(inclocken_a) GENERATE
						ram_block.clocken0 = inclocken_a;
					END GENERATE;
					IF STRATIX_SP_NEED_CLOCK1() GENERATE
						IF STRATIX_SP_CLOCK1() == "OUTCLOCK_A" GENERATE
							ram_block.clock1 = outclock_a;
							IF USED(outclocken_a) GENERATE
								ram_block.clocken1 = outclocken_a;
							END GENERATE;
						END GENERATE;
					END GENERATE;
				ELSE GENERATE
					IF STRATIX_RAM_POSSIBLE() != 1 & !STRATIX_RAM_POSSIBLE()  GENERATE
						-- CAUSE: outclock_a is used to clock inputs to the single-port RAM for Stratix device family
						-- ACTION: None.
						ASSERT(0)
						REPORT "outclock_a is used to clock wraddress_a port, data_a port and wren_a port to the single-port ram in benchmarking mode"
						SEVERITY INFO;
					END GENERATE;
					ram_block.clock0 = outclock_a;
					IF USED(outclocken_a) GENERATE
						ram_block.clocken0 = outclocken_a;
					END GENERATE;
					IF STRATIX_SP_NEED_CLOCK1() GENERATE
						IF STRATIX_SP_CLOCK1() == "INCLOCK_A" GENERATE
							ram_block.clock1 = inclock_a;
							IF USED(inclocken_a) GENERATE
								ram_block.clocken1 = inclocken_a;
							END GENERATE;
						END GENERATE;
					END GENERATE;
				END GENERATE;
				IF STRATIX_SP_NEED_CLEAR0() GENERATE
					IF STRATIX_SP_CLEAR0() == "INACLR_A" GENERATE
						ram_block.aclr0 = inaclr_a;
					END GENERATE;
					IF STRATIX_SP_CLEAR0() == "OUTACLR_A" GENERATE
						ram_block.aclr0 = outaclr_a;
					END GENERATE;				
				END GENERATE;
				IF STRATIX_SP_NEED_CLEAR1() GENERATE
					IF STRATIX_SP_CLEAR1() == "INACLR_A" GENERATE
						ram_block.aclr1 = inaclr_a;
					END GENERATE;
					IF STRATIX_SP_CLEAR1() == "OUTACLR_A" GENERATE
						ram_block.aclr1 = outaclr_a;
					END GENERATE;				
				END GENERATE;
			END GENERATE;
			IF DUAL_PORT_MODE() GENERATE
				ram_block.address_a[] = wraddress_a[];
				ram_block.data_a[] = data_a[];
				ram_block.wren_a = wren_a;
				ram_block.address_b[] = rdaddress_a[];
				IF WIDTH_READ_A == 1 GENERATE
					q_a[0] = ram_block.q_b[0];
				ELSE GENERATE
					q_a[] = ram_block.q_b[];
				END GENERATE;
				IF USED(rden_a) GENERATE
					ram_block.rden_b = rden_a;
				END GENERATE;
				IF STRATIX_SP_CLOCK0() == "INCLOCK_A" GENERATE
					IF STRATIX_RAM_POSSIBLE() != 1 & !STRATIX_RAM_POSSIBLE() GENERATE
						-- CAUSE: inclock_a is used to clock inputs to the dual-port RAM for Stratix device family
						-- ACTION: None.
						ASSERT(0)
						REPORT "inclock_a is used to clock wraddress_a port, wren_a port and data_a port  to the dual-port ram in benchmarking mode"
						SEVERITY INFO;
					END GENERATE;
					ram_block.clock0 = inclock_a;
					IF USED(inclocken_a) GENERATE
						ram_block.clocken0 = inclocken_a;
					END GENERATE;
					IF STRATIX_DP_NEED_CLOCK1() GENERATE
						IF STRATIX_DP_CLOCK1() == "OUTCLOCK_A" GENERATE
							ram_block.clock1 = outclock_a;
							IF USED(outclocken_a) GENERATE
								ram_block.clocken1 = outclocken_a;
							END GENERATE;
						END GENERATE;
					END GENERATE;
				ELSE GENERATE
					IF STRATIX_RAM_POSSIBLE() != 1 & !STRATIX_RAM_POSSIBLE() GENERATE
						-- CAUSE: outclock_a is used to clock inputs to the dual-port RAM for Stratix device family
						-- ACTION: None.
						ASSERT(0)
						REPORT "outclock_a is used to clock wraddress_a port, wren_a port and data_a port  to the dual-port ram in benchmarking mode"
						SEVERITY INFO;
					END GENERATE;
					ram_block.clock0 = outclock_a;
					IF USED(outclocken_a) GENERATE
						ram_block.clocken0 = outclocken_a;
					END GENERATE;
					IF STRATIX_DP_NEED_CLOCK1() GENERATE
						IF STRATIX_DP_CLOCK1() == "INCLOCK_A" GENERATE
							ram_block.clock1 = inclock_a;
							IF USED(inclocken_a) GENERATE
								ram_block.clocken1 = inclocken_a;
							END GENERATE;
						END GENERATE;
					END GENERATE;
				END GENERATE;
				IF STRATIX_RAM_POSSIBLE() != 1 & !STRATIX_RAM_POSSIBLE() GENERATE
					IF STRATIX_DP_RDADDRESS_REG_A() == "CLOCK0" GENERATE
						-- CAUSE: inclock_a / outclock_a  is used to clock inputs to the dual-port RAM for Stratix device family
						-- ACTION: None.
						ASSERT(0)
						REPORT " % is used to clock rdaddress_b port and rden_b port (if used) to the dual-port ram in benchmarking mode" STRATIX_SP_CLOCK0()
						SEVERITY INFO;
					ELSE GENERATE
						-- CAUSE: inclock_a / outclock_a  is used to clock inputs to the dual-port RAM for Stratix device family
						-- ACTION: None.
						ASSERT(0)
						REPORT " % is used to clock rdaddress_b port and rden_b port (if used) to the dual-port ram in benchmarking mode" STRATIX_DP_CLOCK1()
						SEVERITY INFO;
					END GENERATE;
				END GENERATE;
				IF STRATIX_DP_NEED_CLEAR0() GENERATE
					IF STRATIX_DP_CLEAR0() == "INACLR_A" GENERATE
						ram_block.aclr0 = inaclr_a;
					END GENERATE;
					IF STRATIX_DP_CLEAR0() == "OUTACLR_A" GENERATE
						ram_block.aclr0 = outaclr_a;
					END GENERATE;				
				END GENERATE;
				IF STRATIX_DP_NEED_CLEAR1() GENERATE
					IF STRATIX_DP_CLEAR1() == "INACLR_A" GENERATE
						ram_block.aclr1 = inaclr_a;
					END GENERATE;
					IF STRATIX_DP_CLEAR1() == "OUTACLR_A" GENERATE
						ram_block.aclr1 = outaclr_a;
					END GENERATE;				
				END GENERATE;
			END GENERATE;
			IF BIDIR_DUAL_MODE() GENERATE
				ram_block.address_a[] = wraddress_a[];
				q_a[] = ram_block.q_a[];
				ram_block.data_a[] = data_a[];
				ram_block.data_b[] = data_b[];
				ram_block.wren_a = wren_a;
				ram_block.wren_b = wren_b;
				ram_block.address_b[] = wraddress_b[];
				q_b[] = ram_block.q_b[];
				IF USED(rden_b) GENERATE
					ram_block.rden_b = rden_b;
				END GENERATE;
				IF STRATIX_RAM_POSSIBLE() != 1 & !STRATIX_RAM_POSSIBLE() GENERATE
					-- CAUSE : inclock_a/outclock_a is used to clock A side inputs to the bidir dual port ram for Stratix device family
					-- ACTION : None.
					ASSERT(0)
					REPORT " % is used to clock wraddress_a port, wren_a port and data_a port to the bidir dual port ram in the benchmarking mode" STRATIX_BDP_CLOCK0()
					SEVERITY INFO;
				END GENERATE;

				IF STRATIX_BDP_CLOCK0() == "INCLOCK_A" GENERATE
					ram_block.clock0 = inclock_a;
					IF USED(inclocken_a) GENERATE
						ram_block.clocken0 = inclocken_a;
					END GENERATE;
				END GENERATE;
				IF STRATIX_BDP_CLOCK0() == "INCLOCK_B" GENERATE
					ram_block.clock0 = inclock_b;
					IF USED(inclocken_b) GENERATE
						ram_block.clocken0 = inclocken_b;
					END GENERATE;
				END GENERATE;
				IF STRATIX_BDP_CLOCK0() == "OUTCLOCK_A" GENERATE
					ram_block.clock0 = outclock_a;
					IF USED(outclocken_a) GENERATE
						ram_block.clocken0 = outclocken_a;
					END GENERATE;
				END GENERATE;
				IF STRATIX_BDP_CLOCK0() == "OUTCLOCK_B" GENERATE
					ram_block.clock0 = outclock_b;
					IF USED(outclocken_b) GENERATE
						ram_block.clocken0 = outclocken_b;
					END GENERATE;
				END GENERATE;
				IF STRATIX_BDP_NEED_CLOCK1() GENERATE
					IF STRATIX_BDP_CLOCK1() == "INCLOCK_A" GENERATE
						ram_block.clock1 = inclock_a;
						IF USED(inclocken_a) GENERATE
							ram_block.clocken1 = inclocken_a;
						END GENERATE;
					END GENERATE;
					IF STRATIX_BDP_CLOCK1() == "INCLOCK_B" GENERATE
						ram_block.clock1 = inclock_b;
						IF USED(inclocken_b) GENERATE
							ram_block.clocken1 = inclocken_b;
						END GENERATE;
					END GENERATE;
					IF STRATIX_BDP_CLOCK1() == "OUTCLOCK_A" GENERATE
						ram_block.clock1 = outclock_a;
						IF USED(outclocken_a) GENERATE
							ram_block.clocken1 = outclocken_a;
						END GENERATE;
					END GENERATE;
					IF STRATIX_BDP_CLOCK1() == "OUTCLOCK_B" GENERATE
						ram_block.clock1 = outclock_b;
						IF USED(outclocken_b) GENERATE
							ram_block.clocken1 = outclocken_b;
						END GENERATE;
					END GENERATE;
				END GENERATE;
				IF STRATIX_RAM_POSSIBLE() != 1 & !STRATIX_RAM_POSSIBLE() GENERATE
					IF STRATIX_BDP_WRADDRESS_REG_B() == "CLOCK0" GENERATE
						-- CAUSE : inclock_a/outclock_a is used to clock B side inputs to the bidir dual port ram for Stratix device family
						-- ACTION : None.
						ASSERT(0)
						REPORT " % is used to clock wraddress_b port, wren_b port and data_b port to the bidir dual port ram in the benchmarking mode" STRATIX_BDP_CLOCK0()
						SEVERITY INFO;
					ELSE GENERATE
						-- CAUSE : inclock_b/outclock_b is used to clock B side inputs to the bidir dual port ram for Stratix device family
						-- ACTION : None.
						ASSERT(0)
						REPORT " % is used to clock wraddress_b port, wren_b port and data_b port to the bidir dual port ram in the benchmarking mode" STRATIX_BDP_CLOCK1()
						SEVERITY INFO;
					END GENERATE;
				END GENERATE;
				IF STRATIX_BDP_NEED_CLEAR0() GENERATE
					IF STRATIX_BDP_CLEAR0() == "INACLR_A" GENERATE
						ram_block.aclr0 = inaclr_a;
					END GENERATE;
					IF STRATIX_BDP_CLEAR0() == "OUTACLR_A" GENERATE
						ram_block.aclr0 = outaclr_a;
					END GENERATE;				
					IF STRATIX_BDP_CLEAR0() == "INACLR_B" GENERATE
						ram_block.aclr0 = inaclr_b;
					END GENERATE;
					IF STRATIX_BDP_CLEAR0() == "OUTACLR_B" GENERATE
						ram_block.aclr0 = outaclr_b;
					END GENERATE;				

				END GENERATE;
				IF STRATIX_BDP_NEED_CLEAR1() GENERATE
					IF STRATIX_BDP_CLEAR1() == "INACLR_A" GENERATE
						ram_block.aclr1 = inaclr_a;
					END GENERATE;
					IF STRATIX_BDP_CLEAR1() == "OUTACLR_A" GENERATE
						ram_block.aclr1 = outaclr_a;
					END GENERATE;				
					IF STRATIX_BDP_CLEAR1() == "INACLR_B" GENERATE
						ram_block.aclr1 = inaclr_b;
					END GENERATE;
					IF STRATIX_BDP_CLEAR1() == "OUTACLR_B" GENERATE
						ram_block.aclr1 = outaclr_b;
					END GENERATE;				

				END GENERATE;
			END GENERATE;
		END GENERATE;
	ELSE GENERATE
	------------------------------------------------------------
	-- handle the hook-up of any external decode or mux logic --
	------------------------------------------------------------
	
	-- hook up the values... need to do bit-swapping for multi-col matrix with mixed modes
	IF CONSTRUCT_WRITE_A_DECODE() GENERATE
		-- decode logic
		external_decoder_a.data[] = wraddress_a[WIDTHAD_WRITE_A_ACTUAL - 1..WIDTHAD_WRITE_A_ACTUAL - EXTERNAL_ADDRESS_BITS];

		external_decoder_a.enable = wren_a;
	END GENERATE;

	IF CONSTRUCT_WRITE_B_DECODE() GENERATE
		-- decode logic
		external_decoder_b.data[] = wraddress_b[WIDTHAD_WRITE_B_ACTUAL - 1..WIDTHAD_WRITE_B_ACTUAL - EXTERNAL_ADDRESS_BITS];

		external_decoder_b.enable = wren_b;
	END GENERATE;

	IF USED_WRITE_A_PORT() GENERATE
		IF CONSTRUCT_WRITE_A_DECODE() GENERATE
			portawe_actual[] = external_decoder_a.eq[];
		ELSE GENERATE
			portawe_actual[] = wren_a;
		END GENERATE;
	END GENERATE;

	IF USED_WRITE_B_PORT() GENERATE
		IF CONSTRUCT_WRITE_B_DECODE() GENERATE
			portbwe_actual[] = external_decoder_b.eq[];
		ELSE GENERATE
			portbwe_actual[] = wren_b;
		END GENERATE;
	END GENERATE;

	IF CONSTRUCT_READ_A_MUX() GENERATE
		-- hook up the mux
		external_mux_a.sel[] = x_xreg_addr_a[];
		external_mux_a.data[][] = pre_out_a[][];
		
		-- set up the output
		q_a[] = external_mux_a.result[];

		IF !ADD_CELL_DELAY_TO_READ_A() GENERATE
			IF RDCONTROL_A_REGISTERED() & MODE_HAS_RDEN() GENERATE
				-- not-gate-pushback for high power-up
				x_rea_dffe.d = !rden_a;

				-- hook up the proper clock
				IF RDCONTROL_REG_A == "INCLOCK_A" GENERATE
					x_rea_dffe.(clk, ena) = (inclock_a, inclocken_a);
				ELSE GENERATE
					x_rea_dffe.(clk, ena) = (outclock_a, outclocken_a);
				END GENERATE;
				-- hook up the proper aclr or none
				IF RDCONTROL_ACLR_A == "INACLR_A" GENERATE
					x_rea_dffe.prn = !inaclr_a;
				ELSE GENERATE
					IF RDCONTROL_ACLR_A == "OUTACLR_A" GENERATE
						x_rea_dffe.prn = !outaclr_a;
					END GENERATE;
				END GENERATE;
				x_rea = !x_rea_dffe.q;
			ELSE GENERATE
				IF MODE_HAS_RDEN() GENERATE
					x_rea = rden_a;
				ELSE GENERATE
					-- read always enabled
					x_rea = VCC;
				END GENERATE;
			END GENERATE;

			-- the read addresses
			IF REG_ADDRESS_DFF_A() GENERATE
				IF !SHARED_ADDRESS_MODE() GENERATE
					x_reg_addr_a[].d = rdaddress_a[WIDTHAD_READ_A_ACTUAL - 1..WIDTHAD_READ_A_ACTUAL - EXTERNAL_ADDRESS_BITS];
				ELSE GENERATE
					x_reg_addr_a[].d = wraddress_a[WIDTHAD_READ_A_ACTUAL - 1..WIDTHAD_READ_A_ACTUAL - EXTERNAL_ADDRESS_BITS];
				END GENERATE;

				-- set the proper clock
				IF ADDRESS_A_FROM_INCLOCK_A() GENERATE
					x_reg_addr_a[].(clk, ena) = (inclock_a, inclocken_a);
				ELSE GENERATE
					x_reg_addr_a[].(clk, ena) = (outclock_a, outclocken_a);
				END GENERATE;
					
				-- set the proper clear
				IF (!SHARED_ADDRESS_MODE() & RDADDRESS_ACLR_A == "OUTACLR_A") #
					(SHARED_ADDRESS_MODE() & WRADDRESS_ACLR_A == "OUTACLR_A") GENERATE
					x_reg_addr_a[].clrn = !outaclr_a;
				ELSE GENERATE
					IF (!SHARED_ADDRESS_MODE() & RDADDRESS_ACLR_A == "INACLR_A") #
						(SHARED_ADDRESS_MODE() & WRADDRESS_ACLR_A == "INACLR_A") GENERATE
						x_reg_addr_a[].clrn = !inaclr_a;
					END GENERATE;
				END GENERATE;
			ELSE GENERATE
				IF !SHARED_ADDRESS_MODE() GENERATE
					x_reg_addr_a[] = rdaddress_a[WIDTHAD_READ_A_ACTUAL - 1..WIDTHAD_READ_A_ACTUAL - EXTERNAL_ADDRESS_BITS];
				ELSE GENERATE
					x_reg_addr_a[] = wraddress_a[WIDTHAD_READ_A_ACTUAL - 1..WIDTHAD_READ_A_ACTUAL - EXTERNAL_ADDRESS_BITS];
				END GENERATE;				
			END GENERATE;

			-- feed the latch
			IF LATCH_RD_ADDRESS_A() GENERATE
				x_addr_a_latch[].d = x_reg_addr_a[];
				x_addr_a_latch[].ena = x_rea;
			ELSE GENERATE
				x_addr_a_latch[] = x_reg_addr_a[];
			END GENERATE;
		ELSE GENERATE -- Need to perform latch emulation
			latch_emulator_a.d[] = rdaddress_a[WIDTHAD_READ_A_ACTUAL - 1..WIDTHAD_READ_A_ACTUAL - EXTERNAL_ADDRESS_BITS];
			latch_emulator_a.e = rden_a;

			IF RDCONTROL_REG_A == "INCLOCK_A" GENERATE
				latch_emulator_a.(clk, ena) = (inclock_a, inclocken_a);
			ELSE GENERATE
				latch_emulator_a.(clk, ena) = (outclock_a, outclocken_a);
			END GENERATE;

			IF RDADDRESS_ACLR_A == "INACLR_A" GENERATE
				latch_emulator_a.aclr = inaclr_a;
			ELSE GENERATE
				IF RDADDRESS_ACLR_A == "OUTACLR_A" GENERATE
					latch_emulator_a.aclr = outaclr_a;
				END GENERATE;
			END GENERATE;

			IF RDCONTROL_ACLR_A != RDADDRESS_ACLR_A GENERATE
				IF RDCONTROL_ACLR_A == "INACLR_A" GENERATE
					latch_emulator_a.aclre = inaclr_a;
				ELSE GENERATE
					IF RDCONTROL_ACLR_A == "OUTACLR_A" GENERATE
						latch_emulator_a.aclre = outaclr_a;
					END GENERATE;
				END GENERATE;
			END GENERATE;
		
			x_addr_a_latch[] = latch_emulator_a.q[];
		END GENERATE;

		-- Make sure the external address path has the same slack as the output
		IF EXTRA_ADDRESS_DFF_A() GENERATE
			x_xreg_addr_a[].d = x_addr_a_latch[];

			-- set the proper clock
			IF OUTDATA_REG_A == "INCLOCK_A" GENERATE
				x_xreg_addr_a[].(clk, ena) = (inclock_a, inclocken_a);
			ELSE GENERATE
				x_xreg_addr_a[].(clk, ena) = (outclock_a, outclocken_a);
			END GENERATE;

			-- set the proper aclr
			IF OUTDATA_ACLR_A == "INACLR_A" GENERATE
				x_xreg_addr_a[].clrn = !inaclr_a;
			ELSE GENERATE
				IF OUTDATA_ACLR_A == "OUTACLR_A" GENERATE
					x_xreg_addr_a[].clrn = !outaclr_a;
				END GENERATE;
			END GENERATE;
		ELSE GENERATE
			x_xreg_addr_a[] = x_addr_a_latch[];
		END GENERATE;
	ELSE GENERATE
		IF USED_READ_A_PORT() GENERATE
			q_a[] = pre_out_a[0][];
		END GENERATE;
	END GENERATE;

	IF CONSTRUCT_READ_B_MUX() GENERATE
		-- hook up the mux
		external_mux_b.sel[] = x_xreg_addr_b[];
		external_mux_b.data[][] = pre_out_b[][];
		
		-- set up the output
		q_b[] = external_mux_b.result[];

		IF !ADD_CELL_DELAY_TO_READ_B() GENERATE
			IF RDCONTROL_B_REGISTERED() & MODE_HAS_RDEN() GENERATE
				-- not-gate-pushback for high power-up
				x_reb_dffe.d = !rden_b;

				-- hook up the proper clock
				IF RDCONTROL_REG_B == "INCLOCK_B" GENERATE
					x_reb_dffe.(clk, ena) = (inclock_b, inclocken_b);
				ELSE GENERATE
					x_reb_dffe.(clk, ena) = (outclock_b, outclocken_b);
				END GENERATE;
				-- hook up the proper aclr or none
				IF RDCONTROL_ACLR_B == "INACLR_B" GENERATE
					x_reb_dffe.prn = !inaclr_b;
				ELSE GENERATE
					IF RDCONTROL_ACLR_B == "OUTACLR_B" GENERATE
						x_reb_dffe.prn = !outaclr_b;
					END GENERATE;
				END GENERATE;
				x_reb = !x_reb_dffe.q;
			ELSE GENERATE
				IF MODE_HAS_RDEN() GENERATE
					x_reb = rden_b;
				ELSE GENERATE
					-- read always enabled
					x_reb = VCC;
				END GENERATE;
			END GENERATE;

			-- the read addresses
			IF REG_ADDRESS_DFF_B() GENERATE
				IF !SHARED_ADDRESS_MODE() GENERATE
					x_reg_addr_b[].d = rdaddress_b[WIDTHAD_READ_B_ACTUAL - 1..WIDTHAD_READ_B_ACTUAL - EXTERNAL_ADDRESS_BITS];
				ELSE GENERATE
					x_reg_addr_b[].d = wraddress_b[WIDTHAD_READ_B_ACTUAL - 1..WIDTHAD_READ_B_ACTUAL - EXTERNAL_ADDRESS_BITS];
				END GENERATE;

				-- set the proper clock
				IF ADDRESS_B_FROM_INCLOCK_B() GENERATE
					x_reg_addr_b[].(clk, ena) = (inclock_b, inclocken_b);
				ELSE GENERATE
					x_reg_addr_b[].(clk, ena) = (outclock_b, outclocken_b);
				END GENERATE;
					
				-- set the proper clear
				IF (!SHARED_ADDRESS_MODE() & RDADDRESS_ACLR_B == "OUTACLR_B") #
					(SHARED_ADDRESS_MODE() & WRADDRESS_ACLR_B == "OUTACLR_B") GENERATE
					x_reg_addr_b[].clrn = !outaclr_b;
				ELSE GENERATE
					IF (!SHARED_ADDRESS_MODE() & RDADDRESS_ACLR_B == "INACLR_B") #
						(SHARED_ADDRESS_MODE() & WRADDRESS_ACLR_B == "INACLR_B") GENERATE
						x_reg_addr_b[].clrn = !inaclr_b;
					END GENERATE;
				END GENERATE;
			ELSE GENERATE
				IF !SHARED_ADDRESS_MODE() GENERATE
					x_reg_addr_b[] = rdaddress_b[WIDTHAD_READ_B_ACTUAL - 1..WIDTHAD_READ_B_ACTUAL - EXTERNAL_ADDRESS_BITS];
				ELSE GENERATE
					x_reg_addr_b[] = wraddress_b[WIDTHAD_READ_B_ACTUAL - 1..WIDTHAD_READ_B_ACTUAL - EXTERNAL_ADDRESS_BITS];
				END GENERATE;				
			END GENERATE;

			-- feed the latch
			IF LATCH_RD_ADDRESS_B() GENERATE
				x_addr_b_latch[].d = x_reg_addr_b[];
				x_addr_b_latch[].ena = x_reb;
			ELSE GENERATE
				x_addr_b_latch[] = x_reg_addr_b[];
			END GENERATE;
		ELSE GENERATE -- Need to perform latch emulation
			latch_emulator_b.d[] = rdaddress_b[WIDTHAD_READ_B_ACTUAL - 1..WIDTHAD_READ_B_ACTUAL - EXTERNAL_ADDRESS_BITS];
			latch_emulator_b.e = rden_b;

			IF RDCONTROL_REG_B == "INCLOCK_B" GENERATE
				latch_emulator_b.(clk, ena) = (inclock_b, inclocken_b);
			ELSE GENERATE
				latch_emulator_b.(clk, ena) = (outclock_b, outclocken_b);
			END GENERATE;

			IF RDADDRESS_ACLR_B == "INACLR_B" GENERATE
				latch_emulator_b.aclr = inaclr_b;
			ELSE GENERATE
				IF RDADDRESS_ACLR_B == "OUTACLR_B" GENERATE
					latch_emulator_b.aclr = outaclr_b;
				END GENERATE;
			END GENERATE;

			IF RDCONTROL_ACLR_B != RDADDRESS_ACLR_B GENERATE
				IF RDCONTROL_ACLR_B == "INACLR_B" GENERATE
					latch_emulator_b.aclre = inaclr_b;
				ELSE GENERATE
					IF RDCONTROL_ACLR_B == "OUTACLR_B" GENERATE
						latch_emulator_b.aclre = outaclr_b;
					END GENERATE;
				END GENERATE;
			END GENERATE;
		
			x_addr_b_latch[] = latch_emulator_b.q[];
		END GENERATE;

		-- Make sure the external address path has the same slack as the output
		IF EXTRA_ADDRESS_DFF_B() GENERATE
			x_xreg_addr_b[].d = x_addr_b_latch[];

			-- set the proper clock
			IF OUTDATA_REG_B == "INCLOCK_B" GENERATE
				x_xreg_addr_b[].(clk, ena) = (inclock_b, inclocken_b);
			ELSE GENERATE
				x_xreg_addr_b[].(clk, ena) = (outclock_b, outclocken_b);
			END GENERATE;

			-- set the proper aclr
			IF OUTDATA_ACLR_B == "INACLR_B" GENERATE
				x_xreg_addr_b[].clrn = !inaclr_b;
			ELSE GENERATE
				IF OUTDATA_ACLR_B == "OUTACLR_B" GENERATE
					x_xreg_addr_b[].clrn = !outaclr_b;
				END GENERATE;
			END GENERATE;
		ELSE GENERATE
			x_xreg_addr_b[] = x_addr_b_latch[];
		END GENERATE;
	ELSE GENERATE
		IF USED_READ_B_PORT() GENERATE
			q_b[] = pre_out_b[0][];
		END GENERATE;
	END GENERATE;

	FOR row IN ESB_ROWS - 1 TO 0 GENERATE
		FOR col IN 0 TO ESB_COLS - 1 GENERATE
			-- shuffle the A input bits if necessary
			IF USED_WRITE_A_PORT() GENERATE
				IF USING_MIXED_MODE() GENERATE
					FOR dis_numb IN 0 TO WRITE_A_DISCONTINUITIES - 1 GENERATE
						-- the bit shuffle
						memory_blocks[col][row].portadatain
									[(dis_numb + 1) * DATA_INTERLEAVE_WIDTH_IN_BITS - 1..dis_numb * DATA_INTERLEAVE_WIDTH_IN_BITS]
						=
						data_a[PORT_A_WRITE_FIRST_BIT_NUMBER(col) + dis_numb * DATA_INTERLEAVE_OFFSET_IN_BITS +
								DATA_INTERLEAVE_WIDTH_IN_BITS - 1..PORT_A_WRITE_FIRST_BIT_NUMBER(col) + dis_numb
																	* DATA_INTERLEAVE_OFFSET_IN_BITS];
					END GENERATE;
				ELSE GENERATE
					memory_blocks[col][row].portadatain
								[MIXED_BITS_WA(col) - 1..0] = data_a[PORT_A_WRITE_LAST_BIT_NUMBER(col)..
																	PORT_A_WRITE_FIRST_BIT_NUMBER(col)];
				END GENERATE; -- USING_MIXED_MODE()
			END GENERATE; -- USED_WRITE_A_PORT()

			-- shuffle the B input bits if necessary
			IF USED_WRITE_B_PORT() GENERATE
				IF USING_MIXED_MODE() GENERATE
					FOR dis_numb IN 0 TO WRITE_B_DISCONTINUITIES - 1 GENERATE
						-- the bit shuffle
						memory_blocks[col][row].portbdatain
									[(dis_numb + 1) * DATA_INTERLEAVE_WIDTH_IN_BITS - 1..dis_numb * DATA_INTERLEAVE_WIDTH_IN_BITS]
						=
						data_b[PORT_B_WRITE_FIRST_BIT_NUMBER(col) + dis_numb * DATA_INTERLEAVE_OFFSET_IN_BITS +
								DATA_INTERLEAVE_WIDTH_IN_BITS - 1..PORT_B_WRITE_FIRST_BIT_NUMBER(col) + dis_numb
																	* DATA_INTERLEAVE_OFFSET_IN_BITS];
					END GENERATE;
				ELSE GENERATE
					memory_blocks[col][row].portbdatain
								[MIXED_BITS_WB(col) - 1..0] = data_b[PORT_B_WRITE_LAST_BIT_NUMBER(col)..
																	PORT_B_WRITE_FIRST_BIT_NUMBER(col)];
				END GENERATE; -- USING_MIXED_MODE()
			END GENERATE; -- USED_WRITE_B_PORT()

			-- shuffle the A input bits if necessary
			IF USED_READ_A_PORT() GENERATE
				IF USING_MIXED_MODE() GENERATE
					FOR dis_numb IN 0 TO READ_A_DISCONTINUITIES - 1 GENERATE
						pre_out_a[row]	[PORT_A_READ_FIRST_BIT_NUMBER(col) + dis_numb * DATA_INTERLEAVE_OFFSET_IN_BITS +
										DATA_INTERLEAVE_WIDTH_IN_BITS - 1..  PORT_A_READ_FIRST_BIT_NUMBER(col)
										+ dis_numb * DATA_INTERLEAVE_OFFSET_IN_BITS] =
						memory_blocks[col][row].portadataout
								[(dis_numb + 1) * DATA_INTERLEAVE_WIDTH_IN_BITS - 1..
								dis_numb * DATA_INTERLEAVE_WIDTH_IN_BITS];
					END GENERATE;
				ELSE GENERATE
					pre_out_a[row][PORT_A_READ_LAST_BIT_NUMBER(col)..
									PORT_A_READ_FIRST_BIT_NUMBER(col)] =
					memory_blocks[col][row].portadataout[MIXED_BITS_RA(col) - 1..0];
				END GENERATE;
			END GENERATE;

			-- shuffle the B input bits if necessary
			IF USED_READ_B_PORT() GENERATE
				IF USING_MIXED_MODE() GENERATE
					FOR dis_numb IN 0 TO READ_B_DISCONTINUITIES - 1 GENERATE
						pre_out_b[row]	[PORT_B_READ_FIRST_BIT_NUMBER(col) + dis_numb * DATA_INTERLEAVE_OFFSET_IN_BITS +
										DATA_INTERLEAVE_WIDTH_IN_BITS - 1..  PORT_B_READ_FIRST_BIT_NUMBER(col)
										+ dis_numb * DATA_INTERLEAVE_OFFSET_IN_BITS] =
						memory_blocks[col][row].portbdataout
								[(dis_numb + 1) * DATA_INTERLEAVE_WIDTH_IN_BITS - 1..
								dis_numb * DATA_INTERLEAVE_WIDTH_IN_BITS];
					END GENERATE;
				ELSE GENERATE
					pre_out_b[row][PORT_B_READ_LAST_BIT_NUMBER(col)..
									PORT_B_READ_FIRST_BIT_NUMBER(col)] =
					memory_blocks[col][row].portbdataout[MIXED_BITS_RB(col) - 1..0];
				END GENERATE;
			END GENERATE;
		END GENERATE; -- col
	END GENERATE; -- row

	-- connect as few ports as possible to reduce routing requirements
	FOR row IN ESB_ROWS - 1 TO 0 GENERATE
		FOR col IN ESB_COLS - 1 TO 0 GENERATE
			IF USED(wren_a) GENERATE
				memory_blocks[col][row].portawe = portawe_actual[row];
			END GENERATE;
			IF USED(wren_b) GENERATE
				memory_blocks[col][row].portbwe = portbwe_actual[row];
			END GENERATE;

			IF USED(wraddress_a) GENERATE
				memory_blocks[col][row].portawaddr[] = wraddress_a[PORT_A_WRITE_ADDRESS_WIDTH(row) - 1..0];
				IF BIDIR_DUAL_MODE() # SINGLE_PORT_MODE() GENERATE
					memory_blocks[col][row].portaraddr[] = wraddress_a[PORT_A_WRITE_ADDRESS_WIDTH(row) - 1..0];
				END GENERATE;
			END GENERATE;
			IF USED(wraddress_b) GENERATE
				memory_blocks[col][row].portbwaddr[] = wraddress_b[PORT_B_WRITE_ADDRESS_WIDTH(row) - 1..0];
				IF BIDIR_DUAL_MODE() GENERATE
					memory_blocks[col][row].portbraddr[] = wraddress_b[PORT_B_WRITE_ADDRESS_WIDTH(row) - 1..0];
				END GENERATE;
			END GENERATE;
			IF USED(rdaddress_a) GENERATE
				memory_blocks[col][row].portaraddr[] = rdaddress_a[PORT_A_READ_ADDRESS_WIDTH(row) - 1..0];
			END GENERATE;
			IF USED(rdaddress_b) GENERATE
				memory_blocks[col][row].portbraddr[] = rdaddress_b[PORT_B_READ_ADDRESS_WIDTH(row) - 1..0];
			END GENERATE;
		END GENERATE; -- col FOR
	END GENERATE; -- row FOR

	IF USED(inclock_a) GENERATE
		memory_blocks[][].portaclk0 = inclock_a;
	END GENERATE;
	IF USED(inclock_b) GENERATE
		memory_blocks[][].portbclk0 = inclock_b;
	END GENERATE;
	IF USED(outclock_a) GENERATE
		memory_blocks[][].portaclk1 = outclock_a;
	END GENERATE;
	IF USED(outclock_b) GENERATE
		memory_blocks[][].portbclk1 = outclock_b;
	END GENERATE;
	IF USED(inclocken_a) GENERATE
		memory_blocks[][].portaena0 = inclocken_a;
	END GENERATE;
	IF USED(inclocken_b) GENERATE
		memory_blocks[][].portbena0 = inclocken_b;
	END GENERATE;
	IF USED(rden_a) # DUAL_PORT_MODE() # QUAD_PORT_MODE() GENERATE
		memory_blocks[][].portare = rden_a;
	END GENERATE;
	IF USED(rden_b) # QUAD_PORT_MODE() GENERATE
		memory_blocks[][].portbre = rden_b;
	END GENERATE;
	IF USED(outclocken_a) GENERATE
		memory_blocks[][].portaena1 = outclocken_a;
	END GENERATE;
	IF USED(outclocken_b) GENERATE
		memory_blocks[][].portbena1 = outclocken_b;
	END GENERATE;
	IF USED(inaclr_a) GENERATE
		memory_blocks[][].portaclr0 = inaclr_a;
	END GENERATE;
	IF USED(inaclr_b) GENERATE
		memory_blocks[][].portbclr0 = inaclr_b;
	END GENERATE;
	IF USED(outaclr_a) GENERATE
		memory_blocks[][].portaclr1 = outaclr_a;
	END GENERATE;
	IF USED(outaclr_b) GENERATE
		memory_blocks[][].portbclr1 = outaclr_b;
	END GENERATE;

	-- avoid warnings and errors about unconnected outputs
	FOR col IN ESB_COLS - 1 TO 0 GENERATE
		FOR row IN ESB_ROWS - 1 TO 0 GENERATE
			IF QUAD_PORT_MODE() # BIDIR_DUAL_MODE() GENERATE
				FOR k IN MIXED_BITS_RB(col) - 1 TO 0 GENERATE
					q_b[] = GND & memory_blocks[col][row].portbdataout[k];
				END GENERATE;
			END GENERATE;
			FOR l IN MIXED_BITS_RA(col) - 1 TO 0 GENERATE
				q_a[] = GND & memory_blocks[col][row].portadataout[l];
			END GENERATE;
		END GENERATE;
	END GENERATE;
	END GENERATE; -- ! family generate
	IF !USED(q_a) GENERATE
		q_a[] = GND;
	END GENERATE;
	IF !USED(q_b) GENERATE
		q_b[] = GND;
	END GENERATE;
END; -- Function section
