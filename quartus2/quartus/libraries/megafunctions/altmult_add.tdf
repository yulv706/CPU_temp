------------------------------------------------------------------
-- ALTMULT_ADD
--
-- This megafunction computes the sum of several multipliers
--
--  Copyright 1991-2009 Corporation  
--  Your use of Altera Corporation's design tools, logic functions  
--  and other software and tools, and its AMPP partner logic  
--  functions, and any output files from any of the foregoing  
--  (including device programming or simulation files), and any  
--  associated documentation or information are expressly subject  
--  to the terms and conditions of the Altera Program License  
--  Subscription Agreement, Altera MegaCore Function License  
--  Agreement, or other applicable license agreement, including,  
--  without limitation, that your use is for the sole purpose of  
--  programming logic devices manufactured by Altera and sold by  
--  Altera or its authorized distributors.  Please refer to the  
--  applicable agreement for further details. 
--  
--  9.0 Build 184  03/01/2009   
------------------------------------------------------------------
OPTIONS NAME_SUBSTITUTION = ON;
OPTIONS TREAT_DEFAULT_VALUE_AS_UNUSED = ON;

INCLUDE "aglobal90.inc";

-- define some legal parameter names
CONSTANT NO_CLOCK = "UNREGISTERED";
CONSTANT CLK0 = "CLOCK0";
CONSTANT CLK1 = "CLOCK1";
CONSTANT CLK2 = "CLOCK2";
CONSTANT CLK3 = "CLOCK3";
CONSTANT CLEAR0 = "ACLR0";
CONSTANT CLEAR1 = "ACLR1";
CONSTANT CLEAR2 = "ACLR2";
CONSTANT CLEAR3 = "ACLR3";
CONSTANT UNSIGNED_REPRESENTATION = "UNSIGNED";
CONSTANT SIGNED_REPRESENTATION = "SIGNED";
CONSTANT ADD_DIRECTION = "ADD";
CONSTANT SUB_DIRECTION = "SUB";
CONSTANT DATAA_SOURCE = "DATAA";
CONSTANT DATAB_SOURCE = "DATAB";
CONSTANT SCANA_SOURCE = "SCANA";
CONSTANT SCANB_SOURCE = "SCANB";
CONSTANT YES_STRING = "YES";
CONSTANT NO_STRING = "NO";
CONSTANT VARIABLE_STRING = "VARIABLE";
CONSTANT UNUSED_STRING = "UNUSED";
CONSTANT USED_STRING = "USED";
CONSTANT DEFAULT_USAGE = "PORT_CONNECTIVITY";

PARAMETERS
(
	ACCUM_DIRECTION = "ADD",
	ACCUM_SLOAD_ACLR = "ACLR3",
	ACCUM_SLOAD_PIPELINE_ACLR = "ACLR3",
	ACCUM_SLOAD_PIPELINE_REGISTER = "CLOCK0",
	ACCUM_SLOAD_REGISTER = "CLOCK0",
	ACCUMULATOR = "NO",
	ADDER1_ROUNDING = "NO",
	ADDER3_ROUNDING = "NO",
	ADDNSUB1_ROUND_ACLR = "ACLR3",
	ADDNSUB1_ROUND_PIPELINE_ACLR = "ACLR3",
	ADDNSUB1_ROUND_PIPELINE_REGISTER = "CLOCK0",
	ADDNSUB1_ROUND_REGISTER = "CLOCK0",
	ADDNSUB3_ROUND_ACLR = "ACLR3",
	ADDNSUB3_ROUND_PIPELINE_ACLR = "ACLR3",
	ADDNSUB3_ROUND_PIPELINE_REGISTER = "CLOCK0",
	ADDNSUB3_ROUND_REGISTER = "CLOCK0",
	ADDNSUB_MULTIPLIER_ACLR1 = "ACLR3",
	ADDNSUB_MULTIPLIER_ACLR3 = "ACLR3",
	ADDNSUB_MULTIPLIER_PIPELINE_ACLR1 = "ACLR3",
	ADDNSUB_MULTIPLIER_PIPELINE_ACLR3 = "ACLR3",
	ADDNSUB_MULTIPLIER_PIPELINE_REGISTER1 = "CLOCK0",
	ADDNSUB_MULTIPLIER_PIPELINE_REGISTER3 = "CLOCK0",
	ADDNSUB_MULTIPLIER_REGISTER1 = "CLOCK0",
	ADDNSUB_MULTIPLIER_REGISTER3 = "CLOCK0",
	CHAINOUT_ACLR = "ACLR3",
	CHAINOUT_ADDER = "NO",
	CHAINOUT_REGISTER = "CLOCK0",
	CHAINOUT_ROUND_ACLR = "ACLR3",
	CHAINOUT_ROUND_OUTPUT_ACLR = "ACLR3",
	CHAINOUT_ROUND_OUTPUT_REGISTER = "CLOCK0",
	CHAINOUT_ROUND_PIPELINE_ACLR = "ACLR3",
	CHAINOUT_ROUND_PIPELINE_REGISTER = "CLOCK0",
	CHAINOUT_ROUND_REGISTER = "CLOCK0",
	CHAINOUT_ROUNDING = "NO",
	CHAINOUT_SATURATE_ACLR = "ACLR3",
	CHAINOUT_SATURATE_OUTPUT_ACLR = "ACLR3",
	CHAINOUT_SATURATE_OUTPUT_REGISTER = "CLOCK0",
	CHAINOUT_SATURATE_PIPELINE_ACLR = "ACLR3",
	CHAINOUT_SATURATE_PIPELINE_REGISTER = "CLOCK0",
	CHAINOUT_SATURATE_REGISTER = "CLOCK0",
	CHAINOUT_SATURATION = "NO",
	DEDICATED_MULTIPLIER_CIRCUITRY = "AUTO",
	DSP_BLOCK_BALANCING = "Auto",
	EXTRA_LATENCY = 0,
	INPUT_ACLR_A0 = "ACLR3",
	INPUT_ACLR_A1 = "ACLR3",
	INPUT_ACLR_A2 = "ACLR3",
	INPUT_ACLR_A3 = "ACLR3",
	INPUT_ACLR_B0 = "ACLR3",
	INPUT_ACLR_B1 = "ACLR3",
	INPUT_ACLR_B2 = "ACLR3",
	INPUT_ACLR_B3 = "ACLR3",
	INPUT_REGISTER_A0 = "CLOCK0",
	INPUT_REGISTER_A1 = "CLOCK0",
	INPUT_REGISTER_A2 = "CLOCK0",
	INPUT_REGISTER_A3 = "CLOCK0",
	INPUT_REGISTER_B0 = "CLOCK0",
	INPUT_REGISTER_B1 = "CLOCK0",
	INPUT_REGISTER_B2 = "CLOCK0",
	INPUT_REGISTER_B3 = "CLOCK0",
	INPUT_SOURCE_A0 = "DATAA",
	INPUT_SOURCE_A1 = "DATAA",
	INPUT_SOURCE_A2 = "DATAA",
	INPUT_SOURCE_A3 = "DATAA",
	INPUT_SOURCE_B0 = "DATAB",
	INPUT_SOURCE_B1 = "DATAB",
	INPUT_SOURCE_B2 = "DATAB",
	INPUT_SOURCE_B3 = "DATAB",
	MULT01_ROUND_ACLR = "ACLR3",
	MULT01_ROUND_REGISTER = "CLOCK0",
	MULT01_SATURATION_ACLR = "ACLR2",
	MULT01_SATURATION_REGISTER = "CLOCK0",
	MULT23_ROUND_ACLR = "ACLR3",
	MULT23_ROUND_REGISTER = "CLOCK0",
	MULT23_SATURATION_ACLR = "ACLR3",
	MULT23_SATURATION_REGISTER = "CLOCK0",
	MULTIPLIER01_ROUNDING = "NO",
	MULTIPLIER01_SATURATION = "NO",
	MULTIPLIER1_DIRECTION = "ADD",
	MULTIPLIER23_ROUNDING = "NO",
	MULTIPLIER23_SATURATION = "NO",
	MULTIPLIER3_DIRECTION = "ADD",
	MULTIPLIER_ACLR0 = "ACLR3",
	MULTIPLIER_ACLR1 = "ACLR3",
	MULTIPLIER_ACLR2 = "ACLR3",
	MULTIPLIER_ACLR3 = "ACLR3",
	MULTIPLIER_REGISTER0 = "CLOCK0",
	MULTIPLIER_REGISTER1 = "CLOCK0",
	MULTIPLIER_REGISTER2 = "CLOCK0",
	MULTIPLIER_REGISTER3 = "CLOCK0",
	NUMBER_OF_MULTIPLIERS,
	OUTPUT_ACLR = "ACLR3",
	OUTPUT_REGISTER = "CLOCK0",
	OUTPUT_ROUND_ACLR = "ACLR3",
	OUTPUT_ROUND_PIPELINE_ACLR = "ACLR3",
	OUTPUT_ROUND_PIPELINE_REGISTER = "CLOCK0",
	OUTPUT_ROUND_REGISTER = "CLOCK0",
	OUTPUT_ROUND_TYPE = "NEAREST_INTEGER",
	OUTPUT_ROUNDING = "NO",
	OUTPUT_SATURATE_ACLR = "ACLR3",
	OUTPUT_SATURATE_PIPELINE_ACLR = "ACLR3",
	OUTPUT_SATURATE_PIPELINE_REGISTER = "CLOCK0",
	OUTPUT_SATURATE_REGISTER = "CLOCK0",
	OUTPUT_SATURATE_TYPE = "ASYMMETRIC",
	OUTPUT_SATURATION = "NO",
	port_addnsub1 = "PORT_CONNECTIVITY",
	port_addnsub3 = "PORT_CONNECTIVITY",
	PORT_CHAINOUT_SAT_IS_OVERFLOW = "PORT_UNUSED",
	PORT_MULT0_IS_SATURATED = "UNUSED",
	PORT_MULT1_IS_SATURATED = "UNUSED",
	PORT_MULT2_IS_SATURATED = "UNUSED",
	PORT_MULT3_IS_SATURATED = "UNUSED",
	PORT_OUTPUT_IS_OVERFLOW = "PORT_UNUSED",
	port_signa = "PORT_CONNECTIVITY",
	port_signb = "PORT_CONNECTIVITY",
	REPRESENTATION_A = "UNSIGNED",
	REPRESENTATION_B = "UNSIGNED",
	ROTATE_ACLR = "ACLR3",
	ROTATE_OUTPUT_ACLR = "ACLR3",
	ROTATE_OUTPUT_REGISTER = "CLOCK0",
	ROTATE_PIPELINE_ACLR = "ACLR3",
	ROTATE_PIPELINE_REGISTER = "CLOCK0",
	ROTATE_REGISTER = "CLOCK0",
	WIDTH_MSB = 17,
	WIDTH_SATURATE_SIGN = 1,
	SCANOUTA_ACLR = "ACLR3",
	SCANOUTA_REGISTER = "UNREGISTERED",
	SHIFT_MODE = "NO",
	SHIFT_RIGHT_ACLR = "ACLR3",
	SHIFT_RIGHT_OUTPUT_ACLR = "ACLR3",
	SHIFT_RIGHT_OUTPUT_REGISTER = "CLOCK0",
	SHIFT_RIGHT_PIPELINE_ACLR = "ACLR3",
	SHIFT_RIGHT_PIPELINE_REGISTER = "CLOCK0",
	SHIFT_RIGHT_REGISTER = "CLOCK0",
	SIGNED_ACLR_A = "ACLR3",
	SIGNED_ACLR_B = "ACLR3",
	SIGNED_PIPELINE_ACLR_A = "ACLR3",
	SIGNED_PIPELINE_ACLR_B = "ACLR3",
	SIGNED_PIPELINE_REGISTER_A = "CLOCK0",
	SIGNED_PIPELINE_REGISTER_B = "CLOCK0",
	SIGNED_REGISTER_A = "CLOCK0",
	SIGNED_REGISTER_B = "CLOCK0",
	WIDTH_A,
	WIDTH_B,
	WIDTH_CHAININ = 1,
	WIDTH_RESULT,
	ZERO_CHAINOUT_OUTPUT_ACLR = "ACLR3",
	ZERO_CHAINOUT_OUTPUT_REGISTER = "CLOCK0",
	ZERO_LOOPBACK_ACLR = "ACLR3",
	ZERO_LOOPBACK_OUTPUT_ACLR = "ACLR3",
	ZERO_LOOPBACK_OUTPUT_REGISTER = "CLOCK0",
	ZERO_LOOPBACK_PIPELINE_ACLR = "ACLR3",
	ZERO_LOOPBACK_PIPELINE_REGISTER = "CLOCK0",
	ZERO_LOOPBACK_REGISTER = "CLOCK0",
	CBXI_PARAMETER = "NOTHING",
	DEVICE_FAMILY
);

INCLUDE "stratix_mac_mult";
INCLUDE "stratix_mac_out";
-- Need this for clearbox
FUNCTION @CBXI_PARAMETER (accum_sload, aclr0, aclr1, aclr2, aclr3, addnsub1, addnsub1_round, addnsub3, addnsub3_round, chainin[WIDTH_CHAININ-1..0], chainout_round, chainout_saturate, clock0, clock1, clock2, clock3, dataa[WIDTH_A*NUMBER_OF_MULTIPLIERS-1..0], datab[WIDTH_B*NUMBER_OF_MULTIPLIERS-1..0], ena0, ena1, ena2, ena3, mult01_round, mult01_saturation, mult23_round, mult23_saturation, output_round, output_saturate, rotate, scanina[WIDTH_A-1..0], scaninb[WIDTH_B-1..0], shift_right, signa, signb, sourcea[NUMBER_OF_MULTIPLIERS-1..0], sourceb[NUMBER_OF_MULTIPLIERS-1..0], zero_chainout, zero_loopback)
RETURNS (chainout_sat_overflow, mult0_is_saturated, mult1_is_saturated, mult2_is_saturated, mult3_is_saturated, overflow, result[WIDTH_RESULT-1..0], scanouta[WIDTH_A-1..0], scanoutb[WIDTH_B-1..0]);
-- for detecting a legal cases
DEFINE LEGAL_CLOCK_SOURCE(x) = (x == CLK0) # (x == CLK1) # (x == CLK2) # (x == CLK3) # (x == NO_CLOCK);
DEFINE LEGAL_CLEAR_SOURCE(x) = (x == CLEAR0) # (x == CLEAR1) # (x == CLEAR2) # (x == CLEAR3);
DEFINE LEGAL_INPUT_SOURCE_A(x) = (x == DATAA_SOURCE) # (x == SCANA_SOURCE);
DEFINE LEGAL_INPUT_SOURCE_B(x) = (x == DATAB_SOURCE) # (x == SCANB_SOURCE);
DEFINE LEGAL_REPRESENTATION(x) = (x == SIGNED_REPRESENTATION) # (x == UNSIGNED_REPRESENTATION) # (x == UNUSED_STRING);
DEFINE LEGAL_DIRECTION(x) = (x == ADD_DIRECTION) # (x == SUB_DIRECTION) # (x == UNUSED_STRING);

CONSTANT MAX_MULTIPLIERS_PER_ATOM = 4;
CONSTANT MAX_WIDTH_PER_ATOM = 18;
DEFINE ONE_ATOM_CASE() = (NUMBER_OF_MULTIPLIERS <= MAX_MULTIPLIERS_PER_ATOM) & (WIDTH_A <= MAX_WIDTH_PER_ATOM) &
							(WIDTH_B <= MAX_WIDTH_PER_ATOM);
DEFINE CLOCK_TRANSLATE(x) =	(x == CLK0)	?		"0" :
							(x == CLK1) ?		"1" :
							(x == CLK2) ?		"2" :
							(x == CLK3) ?		"3" :
							(x == NO_CLOCK) ?	"UNUSED" :
							%else%				"UNUSED";
DEFINE CLEAR_TRANSLATE(x) =	(x == CLEAR0) ?		"0" :
							(x == CLEAR1) ?		"1" :
							(x == CLEAR2) ?		"2" :
							(x == CLEAR3) ?		"3" :
							%else%				"NONE";

CONSTANT WYS0_DATAA_CLOCK = CLOCK_TRANSLATE(INPUT_REGISTER_A0);
CONSTANT WYS0_DATAB_CLOCK = CLOCK_TRANSLATE(INPUT_REGISTER_B0);
CONSTANT WYS0_OUTPUT_CLOCK = CLOCK_TRANSLATE(MULTIPLIER_REGISTER0);
CONSTANT WYS0_DATAA_CLEAR = WYS0_DATAA_CLOCK != "UNUSED" ? CLEAR_TRANSLATE(INPUT_ACLR_A0) : "UNUSED";
CONSTANT WYS0_DATAB_CLEAR = WYS0_DATAB_CLOCK != "UNUSED" ? CLEAR_TRANSLATE(INPUT_ACLR_B0) : "UNUSED";
CONSTANT WYS0_OUTPUT_CLEAR = WYS0_OUTPUT_CLOCK != "UNUSED" ? CLEAR_TRANSLATE(MULTIPLIER_ACLR0) : "UNUSED";

CONSTANT WYS1_DATAA_CLOCK = CLOCK_TRANSLATE(INPUT_REGISTER_A1);
CONSTANT WYS1_DATAB_CLOCK = CLOCK_TRANSLATE(INPUT_REGISTER_B1);
CONSTANT WYS1_OUTPUT_CLOCK = CLOCK_TRANSLATE(MULTIPLIER_REGISTER1);
CONSTANT WYS1_DATAA_CLEAR = WYS1_DATAA_CLOCK != "UNUSED" ? CLEAR_TRANSLATE(INPUT_ACLR_A1) : "UNUSED";
CONSTANT WYS1_DATAB_CLEAR = WYS1_DATAB_CLOCK != "UNUSED" ? CLEAR_TRANSLATE(INPUT_ACLR_B1) : "UNUSED";
CONSTANT WYS1_OUTPUT_CLEAR = WYS1_OUTPUT_CLOCK != "UNUSED" ? CLEAR_TRANSLATE(MULTIPLIER_ACLR1) : "UNUSED";

CONSTANT WYS2_DATAA_CLOCK = CLOCK_TRANSLATE(INPUT_REGISTER_A2);
CONSTANT WYS2_DATAB_CLOCK = CLOCK_TRANSLATE(INPUT_REGISTER_B2);
CONSTANT WYS2_OUTPUT_CLOCK = CLOCK_TRANSLATE(MULTIPLIER_REGISTER2);
CONSTANT WYS2_DATAA_CLEAR = WYS2_DATAA_CLOCK != "UNUSED" ? CLEAR_TRANSLATE(INPUT_ACLR_A2) : "UNUSED";
CONSTANT WYS2_DATAB_CLEAR = WYS2_DATAB_CLOCK != "UNUSED" ? CLEAR_TRANSLATE(INPUT_ACLR_B2) : "UNUSED";
CONSTANT WYS2_OUTPUT_CLEAR = WYS2_OUTPUT_CLOCK != "UNUSED" ? CLEAR_TRANSLATE(MULTIPLIER_ACLR2) : "UNUSED";

CONSTANT WYS3_DATAA_CLOCK = CLOCK_TRANSLATE(INPUT_REGISTER_A3);
CONSTANT WYS3_DATAB_CLOCK = CLOCK_TRANSLATE(INPUT_REGISTER_B3);
CONSTANT WYS3_OUTPUT_CLOCK = CLOCK_TRANSLATE(MULTIPLIER_REGISTER3);
CONSTANT WYS3_DATAA_CLEAR = WYS3_DATAA_CLOCK != "UNUSED" ? CLEAR_TRANSLATE(INPUT_ACLR_A3) : "UNUSED";
CONSTANT WYS3_DATAB_CLEAR = WYS3_DATAB_CLOCK != "UNUSED" ? CLEAR_TRANSLATE(INPUT_ACLR_B3) : "UNUSED";
CONSTANT WYS3_OUTPUT_CLEAR = WYS3_OUTPUT_CLOCK != "UNUSED" ? CLEAR_TRANSLATE(MULTIPLIER_ACLR3) : "UNUSED";

DEFINE SELECTOR(index, choice0, choice1, choice2, choice3) =	(index >= NUMBER_OF_MULTIPLIERS) ? "NONE" : -- add a trigger to force unregistered if packing extras
																(index == 0) ? choice0 :
																(index == 1) ? choice1 :
																(index == 2) ? choice2 :
																choice3;

CONSTANT WYS_DATAA_WIDTH = WIDTH_A;
CONSTANT WYS_DATAB_WIDTH = WIDTH_B;
DEFINE WYS_DATAA_CLOCK(x) = SELECTOR(x, WYS0_DATAA_CLOCK, WYS1_DATAA_CLOCK, WYS2_DATAA_CLOCK, WYS3_DATAA_CLOCK);
DEFINE WYS_DATAB_CLOCK(x) = SELECTOR(x, WYS0_DATAB_CLOCK, WYS1_DATAB_CLOCK, WYS2_DATAB_CLOCK, WYS3_DATAB_CLOCK);
DEFINE WYS_SIGNA_CLOCK() = USED(signa) ? CLOCK_TRANSLATE(SIGNED_REGISTER_A) : "UNUSED";
DEFINE WYS_SIGNB_CLOCK() = USED(signb) ? CLOCK_TRANSLATE(SIGNED_REGISTER_B) : "UNUSED";
DEFINE WYS_OUTPUT_CLOCK(x) = SELECTOR(x, WYS0_OUTPUT_CLOCK, WYS1_OUTPUT_CLOCK, WYS2_OUTPUT_CLOCK, WYS3_OUTPUT_CLOCK);
DEFINE WYS_DATAA_CLEAR(x) = WYS_DATAA_CLOCK(x) != "UNUSED" ? SELECTOR(x, WYS0_DATAA_CLEAR, WYS1_DATAA_CLEAR, WYS2_DATAA_CLEAR, WYS3_DATAA_CLEAR) : "UNUSED";
DEFINE WYS_DATAB_CLEAR(x) = WYS_DATAB_CLOCK(x) != "UNUSED" ? SELECTOR(x, WYS0_DATAB_CLEAR, WYS1_DATAB_CLEAR, WYS2_DATAB_CLEAR, WYS3_DATAB_CLEAR) : "UNUSED";
DEFINE WYS_SIGNA_CLEAR() = WYS_SIGNA_CLOCK() != "UNUSED" ? CLEAR_TRANSLATE(SIGNED_ACLR_A) : "UNUSED";
DEFINE WYS_SIGNB_CLEAR() = WYS_SIGNB_CLOCK() != "UNUSED" ? CLEAR_TRANSLATE(SIGNED_ACLR_B) : "UNUSED";
DEFINE WYS_OUTPUT_CLEAR(x) = WYS_OUTPUT_CLOCK(x) != "UNUSED" ? SELECTOR(x, WYS0_OUTPUT_CLEAR, WYS1_OUTPUT_CLEAR, WYS2_OUTPUT_CLEAR, WYS3_OUTPUT_CLEAR) : "UNUSED";

-- defintion of some constants
CONSTANT OUTPUT_ONLY_MODE = "OUTPUT_ONLY";
CONSTANT ONE_LEVEL_ADDER_MODE = "ONE_LEVEL_ADDER";
CONSTANT TWO_LEVEL_ADDER_MODE = "TWO_LEVEL_ADDER";

-- specific to the output atom
CONSTANT WYS_OPERATION_MODE =	(NUMBER_OF_MULTIPLIERS == 1) ? OUTPUT_ONLY_MODE :
								(NUMBER_OF_MULTIPLIERS == 2) ? ONE_LEVEL_ADDER_MODE :
								% 4 >= NUMBER_OF_MULTIPLIERS > 2%TWO_LEVEL_ADDER_MODE;

CONSTANT WYS_DATAA_WIDTH_MULTOUT =	WYS_DATAA_WIDTH + WYS_DATAB_WIDTH;
CONSTANT WYS_DATAB_WIDTH_MULTOUT =	(NUMBER_OF_MULTIPLIERS > 1) ? WYS_DATAA_WIDTH_MULTOUT : "UNUSED";
CONSTANT WYS_DATAC_WIDTH_MULTOUT =	(NUMBER_OF_MULTIPLIERS > 2) ? WYS_DATAA_WIDTH_MULTOUT : "UNUSED";
CONSTANT WYS_DATAD_WIDTH_MULTOUT =	(NUMBER_OF_MULTIPLIERS > 2) ? WYS_DATAA_WIDTH_MULTOUT : "UNUSED";
DEFINE WYS_ADDNSUB0_CLOCK_MULTOUT() = USED(addnsub1) ? CLOCK_TRANSLATE(ADDNSUB_MULTIPLIER_REGISTER1) : "UNUSED";
DEFINE WYS_ADDNSUB1_CLOCK_MULTOUT() = ((NUMBER_OF_MULTIPLIERS > 2) & USED(addnsub3)) ? CLOCK_TRANSLATE(ADDNSUB_MULTIPLIER_REGISTER3) : "UNUSED";
DEFINE WYS_SIGNA_CLOCK_MULTOUT() = USED(signa) ? CLOCK_TRANSLATE(SIGNED_REGISTER_A) : "UNUSED";
DEFINE WYS_SIGNB_CLOCK_MULTOUT() = USED(signb) ? CLOCK_TRANSLATE(SIGNED_REGISTER_B) : "UNUSED";
CONSTANT WYS_OUTPUT_CLOCK_MULTOUT = CLOCK_TRANSLATE(OUTPUT_REGISTER);
DEFINE WYS_ADDNSUB0_CLEAR_MULTOUT() = WYS_ADDNSUB0_CLOCK_MULTOUT() != "UNUSED" ? CLEAR_TRANSLATE(ADDNSUB_MULTIPLIER_ACLR1) : "UNUSED";
DEFINE WYS_ADDNSUB1_CLEAR_MULTOUT() = (WYS_OPERATION_MODE == TWO_LEVEL_ADDER_MODE) & (WYS_ADDNSUB1_CLOCK_MULTOUT() != "UNUSED") ?
											CLEAR_TRANSLATE(ADDNSUB_MULTIPLIER_ACLR3) :
											"UNUSED";
DEFINE WYS_SIGNA_CLEAR_MULTOUT() = WYS_SIGNA_CLOCK_MULTOUT() != "UNUSED" ? CLEAR_TRANSLATE(SIGNED_ACLR_A) : "UNUSED";
DEFINE WYS_SIGNB_CLEAR_MULTOUT() = WYS_SIGNB_CLOCK_MULTOUT() != "UNUSED" ? CLEAR_TRANSLATE(SIGNED_ACLR_B) : "UNUSED";
CONSTANT WYS_OUTPUT_CLEAR_MULTOUT = WYS_OUTPUT_CLOCK_MULTOUT != "UNUSED" ? CLEAR_TRANSLATE(OUTPUT_ACLR) : "UNUSED";
DEFINE WYS_ADDNSUB0_PIPELINE_CLOCK() = USED(addnsub1) ? CLOCK_TRANSLATE(ADDNSUB_MULTIPLIER_PIPELINE_REGISTER1) : "UNUSED";
DEFINE WYS_ADDNSUB1_PIPELINE_CLOCK() = (WYS_OPERATION_MODE == TWO_LEVEL_ADDER_MODE) & USED(addnsub3) ? 
											CLOCK_TRANSLATE(ADDNSUB_MULTIPLIER_PIPELINE_REGISTER3) : "UNUSED";
DEFINE WYS_SIGNA_PIPELINE_CLOCK() = USED(signa) ? CLOCK_TRANSLATE(SIGNED_PIPELINE_REGISTER_A) : "UNUSED";
DEFINE WYS_SIGNB_PIPELINE_CLOCK() = USED(signb) ? CLOCK_TRANSLATE(SIGNED_PIPELINE_REGISTER_B) : "UNUSED";
DEFINE WYS_ADDNSUB0_PIPELINE_CLEAR() = WYS_ADDNSUB0_PIPELINE_CLOCK() != "UNUSED" ? CLEAR_TRANSLATE(ADDNSUB_MULTIPLIER_PIPELINE_ACLR1) : "UNUSED";
DEFINE WYS_ADDNSUB1_PIPELINE_CLEAR() = (WYS_OPERATION_MODE == TWO_LEVEL_ADDER_MODE) & (WYS_ADDNSUB1_PIPELINE_CLOCK() != "UNUSED") ? 
											CLEAR_TRANSLATE(ADDNSUB_MULTIPLIER_PIPELINE_ACLR3) : "UNUSED";
DEFINE WYS_SIGNA_PIPELINE_CLEAR() = WYS_SIGNA_PIPELINE_CLOCK() != "UNUSED" ? CLEAR_TRANSLATE(SIGNED_PIPELINE_ACLR_A) : "UNUSED";
DEFINE WYS_SIGNB_PIPELINE_CLEAR() = WYS_SIGNB_PIPELINE_CLOCK() != "UNUSED" ? CLEAR_TRANSLATE(SIGNED_PIPELINE_ACLR_B) : "UNUSED";

DEFINE MULT_USING_CLOCK(index, clock) =	(WYS_DATAA_CLOCK(index) == clock) # (WYS_DATAB_CLOCK(index) == clock) #
										(WYS_SIGNA_CLOCK() == clock) # (WYS_SIGNB_CLOCK() == clock) #
										(WYS_OUTPUT_CLOCK(index) == clock);
DEFINE MULT_USING_CLEAR(index, clear) =	(WYS_DATAA_CLEAR(index) == clear) # (WYS_DATAB_CLEAR(index) == clear) #
										(WYS_SIGNA_CLEAR() == clear) # (WYS_SIGNB_CLEAR() == clear) #
										(WYS_OUTPUT_CLEAR(index) == clear);

DEFINE MULTOUT_USING_CLOCK(clock) =	(WYS_ADDNSUB0_CLOCK_MULTOUT() == clock) # (WYS_ADDNSUB1_CLOCK_MULTOUT() == clock) #
									(WYS_SIGNA_CLOCK_MULTOUT() == clock) # (WYS_SIGNB_CLOCK_MULTOUT() == clock) #
									(WYS_OUTPUT_CLOCK_MULTOUT == clock) # (WYS_ADDNSUB0_PIPELINE_CLOCK() == clock) #
									(WYS_ADDNSUB1_PIPELINE_CLOCK() == clock) # (WYS_SIGNA_PIPELINE_CLOCK() == clock) #
									(WYS_SIGNB_PIPELINE_CLOCK() == clock);
DEFINE MULTOUT_USING_CLEAR(CLEAR) =		(WYS_ADDNSUB0_CLEAR_MULTOUT() == clear) # (WYS_ADDNSUB1_CLEAR_MULTOUT() == clear) #
										(WYS_SIGNA_CLEAR_MULTOUT() == clear) # (WYS_SIGNB_CLEAR_MULTOUT() == clear) #
										(WYS_OUTPUT_CLEAR_MULTOUT == clear) # (WYS_ADDNSUB0_PIPELINE_CLEAR() == clear) #
										(WYS_ADDNSUB1_PIPELINE_CLEAR() == clear) # (WYS_SIGNA_PIPELINE_CLEAR() == clear) #
										(WYS_SIGNB_PIPELINE_CLEAR() == clear);
DEFINE BIG_MULTOUT_USING_CLOCK(clock) =		(WYS_SIGNA_CLOCK_MULTOUT() == clock) # (WYS_SIGNB_CLOCK_MULTOUT() == clock) #
											(WYS_OUTPUT_CLOCK_MULTOUT == clock) # (WYS_SIGNA_PIPELINE_CLOCK() == clock) #
											(WYS_SIGNB_PIPELINE_CLOCK() == clock);
DEFINE BIG_MULTOUT_USING_CLEAR(clear) =	(WYS_SIGNA_CLEAR_MULTOUT() == clear) # (WYS_SIGNB_CLEAR_MULTOUT() == clear) #
										(WYS_OUTPUT_CLEAR_MULTOUT == clear) # (WYS_SIGNA_PIPELINE_CLEAR() == clear) #
										(WYS_SIGNB_PIPELINE_CLEAR() == clear);
CONSTANT FULL_OUTPUT_WIDTH =	(NUMBER_OF_MULTIPLIERS == 1) ?	WIDTH_A + WIDTH_B :
																WIDTH_A + WIDTH_B + CEIL(LOG2(NUMBER_OF_MULTIPLIERS));
CONSTANT REAL_NUMBER_OF_MULTIPLIERS = NUMBER_OF_MULTIPLIERS + (((NUMBER_OF_MULTIPLIERS MOD 4) == 3) ? 1 : 0);
DEFINE ADD_DUMMY_MULT() = REAL_NUMBER_OF_MULTIPLIERS != NUMBER_OF_MULTIPLIERS;
-- The maximum width that can be handled by the MAC block
CONSTANT MAXIMUM_MULT_WIDTH = 36;
-- Maximum width that can be input into each individual multiplier atom
CONSTANT MAXIMUM_ONE_LEVEL_MULT_WIDTH = 18;
-- Going to do the special case of constructing a 36 bit mult
DEFINE BIG_MULT() = (NUMBER_OF_MULTIPLIERS == 1) &	((WIDTH_A > MAX_WIDTH_PER_ATOM) # (WIDTH_B > MAX_WIDTH_PER_ATOM));
DEFINE CBX_ONLY_FAMILY() = (FAMILY_STRATIXII() == 1) # (FAMILY_CYCLONEII() == 1) ? 1 : 0;

SUBDESIGN altmult_add
(
	accum_sload		:	INPUT = GND;
	aclr0		:	INPUT = GND;
	aclr1		:	INPUT = GND;
	aclr2		:	INPUT = GND;
	aclr3		:	INPUT = GND;
	addnsub1		:	INPUT = VCC;
	addnsub1_round		:	INPUT = GND;
	addnsub3		:	INPUT = VCC;
	addnsub3_round		:	INPUT = GND;
	chainin[WIDTH_CHAININ-1..0]		:	INPUT = GND;
	chainout_round		:	INPUT = GND;
	chainout_sat_overflow		:	OUTPUT;
	chainout_saturate		:	INPUT = GND;
	clock0		:	INPUT = VCC;
	clock1		:	INPUT = VCC;
	clock2		:	INPUT = VCC;
	clock3		:	INPUT = VCC;
	dataa[WIDTH_A*NUMBER_OF_MULTIPLIERS-1..0]		:	INPUT = GND;
	datab[WIDTH_B*NUMBER_OF_MULTIPLIERS-1..0]		:	INPUT = GND;
	ena0		:	INPUT = VCC;
	ena1		:	INPUT = VCC;
	ena2		:	INPUT = VCC;
	ena3		:	INPUT = VCC;
	mult01_round		:	INPUT = GND;
	mult01_saturation		:	INPUT = GND;
	mult0_is_saturated		:	OUTPUT;
	mult1_is_saturated		:	OUTPUT;
	mult23_round		:	INPUT = GND;
	mult23_saturation		:	INPUT = GND;
	mult2_is_saturated		:	OUTPUT;
	mult3_is_saturated		:	OUTPUT;
	output_round		:	INPUT = GND;
	output_saturate		:	INPUT = GND;
	overflow		:	OUTPUT;
	result[WIDTH_RESULT-1..0]		:	OUTPUT;
	rotate		:	INPUT = GND;
	scanina[WIDTH_A-1..0]		:	INPUT = GND;
	scaninb[WIDTH_B-1..0]		:	INPUT = GND;
	scanouta[WIDTH_A-1..0]		:	OUTPUT;
	scanoutb[WIDTH_B-1..0]		:	OUTPUT;
	shift_right		:	INPUT = GND;
	signa		:	INPUT = GND;
	signb		:	INPUT = GND;
	sourcea[NUMBER_OF_MULTIPLIERS-1..0]		:	INPUT = GND;
	sourceb[NUMBER_OF_MULTIPLIERS-1..0]		:	INPUT = GND;
	zero_chainout		:	INPUT = GND;
	zero_loopback		:	INPUT = GND;
)


VARIABLE
	IF CBXI_PARAMETER == "NOTHING" & CBX_ONLY_FAMILY() == 0 GENERATE
		IF !BIG_MULT() GENERATE
			-- convert the 1D bus into a 2D bus
			dataa_bus[NUMBER_OF_MULTIPLIERS - 1..0][WIDTH_A - 1..0] : NODE;
			datab_bus[NUMBER_OF_MULTIPLIERS - 1..0][WIDTH_B - 1..0] : NODE;

			IF ONE_ATOM_CASE() GENERATE
				mult_atom[NUMBER_OF_MULTIPLIERS - 1..0] :
					FOR i IN NUMBER_OF_MULTIPLIERS - 1 TO 0 GENERATE
						stratix_mac_mult WITH
						(
							DATAA_WIDTH = WYS_DATAA_WIDTH,
							DATAB_WIDTH = WYS_DATAB_WIDTH,
							DATAA_CLOCK = WYS_DATAA_CLOCK(i),
							DATAB_CLOCK = WYS_DATAB_CLOCK(i),
							SIGNA_CLOCK = WYS_SIGNA_CLOCK(),
							SIGNB_CLOCK = WYS_SIGNB_CLOCK(),
							OUTPUT_CLOCK = WYS_OUTPUT_CLOCK(i),
							DATAA_CLEAR = WYS_DATAA_CLEAR(i),
							DATAB_CLEAR = WYS_DATAB_CLEAR(i),
							SIGNA_CLEAR = WYS_SIGNA_CLEAR(),
							SIGNB_CLEAR = WYS_SIGNB_CLEAR(),
							OUTPUT_CLEAR = WYS_OUTPUT_CLEAR(i)
						)
					END GENERATE;
				-- For the case of NUMBER_OF_MULTIPLIERS MOD 4 == 3, we need to add a dummy multiplier and tie it to 0*0
				-- since we are handcuffed into 2 level adder mode
				IF ADD_DUMMY_MULT() GENERATE
					dummy_mult :	stratix_mac_mult WITH
									(
										DATAA_WIDTH = WYS_DATAA_WIDTH,
										DATAB_WIDTH = WYS_DATAB_WIDTH,
										DATAA_CLOCK = "NONE",
										DATAB_CLOCK = "NONE",
										SIGNA_CLOCK = WYS_SIGNA_CLOCK(),
										SIGNB_CLOCK = WYS_SIGNB_CLOCK(),
										SIGNA_CLEAR = WYS_SIGNA_CLEAR(),
										SIGNB_CLEAR = WYS_SIGNB_CLEAR(),
										OUTPUT_CLOCK = "NONE"
									);
				END GENERATE;

				multout_atom : stratix_mac_out WITH
				(
					OPERATION_MODE = WYS_OPERATION_MODE,
					DATAA_WIDTH = WYS_DATAA_WIDTH_MULTOUT,
					DATAB_WIDTH = WYS_DATAB_WIDTH_MULTOUT,
					DATAC_WIDTH = WYS_DATAC_WIDTH_MULTOUT,
					DATAD_WIDTH = WYS_DATAD_WIDTH_MULTOUT,
					ADDNSUB0_CLOCK = WYS_ADDNSUB0_CLOCK_MULTOUT(),
					ADDNSUB1_CLOCK = WYS_ADDNSUB1_CLOCK_MULTOUT(),
					SIGNA_CLOCK = WYS_SIGNA_CLOCK_MULTOUT(),
					SIGNB_CLOCK = WYS_SIGNB_CLOCK_MULTOUT(),
					OUTPUT_CLOCK = WYS_OUTPUT_CLOCK_MULTOUT,
					ADDNSUB0_CLEAR = WYS_ADDNSUB0_CLEAR_MULTOUT(),
					ADDNSUB1_CLEAR = WYS_ADDNSUB1_CLEAR_MULTOUT(),
					SIGNA_CLEAR = WYS_SIGNA_CLEAR_MULTOUT(),
					SIGNB_CLEAR = WYS_SIGNB_CLEAR_MULTOUT(),
					OUTPUT_CLEAR = WYS_OUTPUT_CLEAR_MULTOUT,
					ADDNSUB0_PIPELINE_CLOCK = WYS_ADDNSUB0_PIPELINE_CLOCK(),
					ADDNSUB1_PIPELINE_CLOCK = WYS_ADDNSUB1_PIPELINE_CLOCK(),
					SIGNA_PIPELINE_CLOCK = WYS_SIGNA_PIPELINE_CLOCK(),
					SIGNB_PIPELINE_CLOCK = WYS_SIGNB_PIPELINE_CLOCK(),
					ADDNSUB0_PIPELINE_CLEAR = WYS_ADDNSUB0_PIPELINE_CLEAR(),
					ADDNSUB1_PIPELINE_CLEAR = WYS_ADDNSUB1_PIPELINE_CLEAR(),
					SIGNA_PIPELINE_CLEAR = WYS_SIGNA_PIPELINE_CLEAR(),
					SIGNB_PIPELINE_CLEAR = WYS_SIGNB_PIPELINE_CLEAR()
				);
			END GENERATE;
		ELSE GENERATE
			-- This is going to be the 36 bit mode
			mult_atom[3..0]	:	stratix_mac_mult WITH	(
															DATAA_WIDTH		= MAXIMUM_ONE_LEVEL_MULT_WIDTH,
															DATAB_WIDTH		= MAXIMUM_ONE_LEVEL_MULT_WIDTH,
															DATAA_CLOCK		= WYS_DATAA_CLOCK(0),
															DATAB_CLOCK		= WYS_DATAB_CLOCK(0),
															SIGNA_CLOCK		= WYS_SIGNA_CLOCK(),
															SIGNB_CLOCK		= WYS_SIGNB_CLOCK(),
															OUTPUT_CLOCK	= WYS_OUTPUT_CLOCK(0),
															DATAA_CLEAR		= WYS_DATAA_CLEAR(0),
															DATAB_CLEAR		= WYS_DATAB_CLEAR(0),
															SIGNA_CLEAR		= WYS_SIGNA_CLEAR(),
															SIGNB_CLEAR		= WYS_SIGNB_CLEAR(),
															OUTPUT_CLEAR	= WYS_OUTPUT_CLEAR(0)
														);
			multout_atom : stratix_mac_out WITH	(
													OPERATION_MODE			= "36_BIT_MULTIPLY",
													DATAA_WIDTH				= MAXIMUM_MULT_WIDTH,
													DATAB_WIDTH				= MAXIMUM_MULT_WIDTH,
													DATAC_WIDTH				= MAXIMUM_MULT_WIDTH,
													DATAD_WIDTH				= MAXIMUM_MULT_WIDTH,
													SIGNA_CLOCK				= WYS_SIGNA_CLOCK_MULTOUT(),
													SIGNB_CLOCK				= WYS_SIGNB_CLOCK_MULTOUT(),
													OUTPUT_CLOCK			= WYS_OUTPUT_CLOCK_MULTOUT,
													SIGNA_CLEAR				= WYS_SIGNA_CLEAR_MULTOUT(),
													SIGNB_CLEAR				= WYS_SIGNB_CLEAR_MULTOUT(),
													OUTPUT_CLEAR			= WYS_OUTPUT_CLEAR_MULTOUT,
													SIGNA_PIPELINE_CLOCK	= WYS_SIGNA_PIPELINE_CLOCK(),
													SIGNB_PIPELINE_CLOCK	= WYS_SIGNB_PIPELINE_CLOCK(),
													SIGNA_PIPELINE_CLEAR	= WYS_SIGNA_PIPELINE_CLEAR(),
													SIGNB_PIPELINE_CLEAR	= WYS_SIGNB_PIPELINE_CLEAR()
												);
			
			-- For preparing the inputs to the multiplier
			a_input[MAXIMUM_MULT_WIDTH - 1..0] : NODE;
			b_input[MAXIMUM_MULT_WIDTH - 1..0] : NODE;

			-- Need to make external scan chains since the MAC can't handle them for 36-bit mode
			IF INPUT_REGISTER_A0 != NO_CLOCK GENERATE
				a_scan_chain[WIDTH_A - 1..0] : DFFE;
			ELSE GENERATE
				a_scan_chain[WIDTH_A - 1..0] : NODE;
			END GENERATE;

			IF INPUT_REGISTER_B0 != NO_CLOCK GENERATE
				b_scan_chain[WIDTH_B - 1..0] : DFFE;
			ELSE GENERATE
				b_scan_chain[WIDTH_B - 1..0] : NODE;
			END GENERATE;
		END GENERATE;
	ELSE GENERATE
		IF (CBXI_PARAMETER != "NOTHING") GENERATE
			auto_generated : @CBXI_PARAMETER WITH (CBXI_PARAMETER = "NOTHING");
		END GENERATE;
	END GENERATE;
BEGIN
	IF CBXI_PARAMETER == "NOTHING" & CBX_ONLY_FAMILY() == 0 GENERATE
		ASSERT NUMBER_OF_MULTIPLIERS <= 4
			REPORT "Altmult_add does not currently support NUMBER_OF_MULTIPLIERS(%) > 4" NUMBER_OF_MULTIPLIERS
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_NUMBER_OF_MULTIPLIERS_UNSUPPORTED;

		ASSERT !((NUMBER_OF_MULTIPLIERS == 3) & (USED(scanouta) # USED(scanoutb)))
			REPORT "Altmult_add does not support using scanouta or scanoutb when NUMBER_OF_MULTIPLIERS is equal to 3."
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_UNSUPPORTED_SCAN_FOR_THREE;

		-- Cause: WIDTH_A is greater than 36
		-- Action: Set the WIDTH_A parameter less than or equal to36 
		ASSERT (WIDTH_A <= 36) # (NUMBER_OF_MULTIPLIERS > 1)
			REPORT "Altmult_add does not support WIDTH_A(%) greater than 36 if NUMBER_OF_MULTIPLIERS is equal to one." WIDTH_A
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_UNSUPPORTED_WIDTH;

		ASSERT (WIDTH_B <= 36) # (NUMBER_OF_MULTIPLIERS > 1)
			REPORT "Altmult_add does not support WIDTH_B(%) greater than 36 if NUMBER_OF_MULTIPLIERS is equal to one." WIDTH_B
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_UNSUPPORTED_WIDTH;

		-- Cause: NUMBER_OF_MULTIPLIERS is equal to 1 but, WIDTH_A is greater than 36
		-- Action: Set WIDTH_A to a value that is less than or equal to 36
		ASSERT !(BIG_MULT() & (WIDTH_A > MAXIMUM_MULT_WIDTH))
			REPORT "ALtmult_add does not allow WIDTH_A(%) to be greater than % when NUMBER_OF_MULTIPLIERS is equal to one." WIDTH_A,MAXIMUM_MULT_WIDTH 
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_BIG_MULT_TOO_BIG;

		ASSERT !(BIG_MULT() & (WIDTH_B > MAXIMUM_MULT_WIDTH))
			REPORT "Altmult_add does not allow WIDTH_B(%) to be greater than % when NUMBER_OF_MULTIPLIERS is equal to one." WIDTH_B,MAXIMUM_MULT_WIDTH 
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_BIG_MULT_TOO_BIG;
		-- Cause: The specified parameter has a value less than or equal to 0.
		-- Action: Set the parameter to a value which is greater than 0.
		ASSERT NUMBER_OF_MULTIPLIERS > 0
			REPORT "NUMBER_OF_MULTIPLIERS(%) must be greater than 0." NUMBER_OF_MULTIPLIERS
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_NATURAL_PARAMETER;

		ASSERT WIDTH_A > 0
			REPORT "Value of WIDTH_A(%) parameter must be greater than 0." WIDTH_A
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_NATURAL_PARAMETER;
		
		ASSERT WIDTH_B > 0
			REPORT "Value of WIDTH_B(%) parameter must be greater than 0." WIDTH_B
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_NATURAL_PARAMETER;
		
		ASSERT WIDTH_RESULT > 0
			REPORT "Value of WIDTH_RESULT(%) parameter must be greater than 0." WIDTH_RESULT
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_NATURAL_PARAMETER;
		
		-- Cause: The specified parameter has an illegal clock source.
		-- Action: Set the value of the specified parameter to opne of the legal values: "CLOCK0", "CLOCK1",
		--			"CLOCK2", "CLOCK3", and "UNREGISTERED"
		ASSERT LEGAL_CLOCK_SOURCE(INPUT_REGISTER_A0)
			REPORT "INPUT_REGISTER_A0(%) has an illegal clock source" INPUT_REGISTER_A0
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLOCK_SOURCE;
		
		ASSERT LEGAL_CLOCK_SOURCE(INPUT_REGISTER_A1)
			REPORT "INPUT_REGISTER_A1(%) has an illegal clock source" INPUT_REGISTER_A1
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLOCK_SOURCE;

		ASSERT LEGAL_CLOCK_SOURCE(INPUT_REGISTER_A2)
			REPORT "INPUT_REGISTER_A2(%) has an illegal clock source." INPUT_REGISTER_A2
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLOCK_SOURCE;
			
		ASSERT LEGAL_CLOCK_SOURCE(INPUT_REGISTER_A3)
			REPORT "INPUT_REGISTER_A3(%) has an illegal clock source." INPUT_REGISTER_A3
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLOCK_SOURCE;

		ASSERT LEGAL_CLOCK_SOURCE(SIGNED_REGISTER_A)
			REPORT "SIGNED_REGISTER_A(%) has an illegal clock source." SIGNED_REGISTER_A
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLOCK_SOURCE;

		ASSERT LEGAL_CLOCK_SOURCE(SIGNED_PIPELINE_REGISTER_A)
			REPORT "SIGNED_PIPELINE_REGISTER_A(%) has an illegal clock source." SIGNED_PIPELINE_REGISTER_A
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLOCK_SOURCE;

		ASSERT LEGAL_CLOCK_SOURCE(INPUT_REGISTER_B0)
			REPORT "INPUT_REGISTER_B0(%) has an illegal clock source." INPUT_REGISTER_B0
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLOCK_SOURCE;

		ASSERT LEGAL_CLOCK_SOURCE(INPUT_REGISTER_B1)
			REPORT "INPUT_REGISTER_B1(%) has an illegal clock source." INPUT_REGISTER_B1
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLOCK_SOURCE;
		
		ASSERT LEGAL_CLOCK_SOURCE(INPUT_REGISTER_B2)
			REPORT "INPUT_REGISTER_B2(%) has an illegal clock source." INPUT_REGISTER_B2
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLOCK_SOURCE;

		ASSERT LEGAL_CLOCK_SOURCE(INPUT_REGISTER_B3)
			REPORT "INPUT_REGISTER_B3(%) has an illegal clock source." INPUT_REGISTER_B3
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLOCK_SOURCE;

		ASSERT LEGAL_CLOCK_SOURCE(SIGNED_REGISTER_B)
			REPORT "SIGNED_REGISTER_B(%) has an illegal clock source." SIGNED_REGISTER_B
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLOCK_SOURCE;
			
		ASSERT LEGAL_CLOCK_SOURCE(SIGNED_PIPELINE_REGISTER_B)
			REPORT "SIGNED_PIPELINE_REGISTER_B(%) has an illegal clock source." SIGNED_PIPELINE_REGISTER_B
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLOCK_SOURCE;

		ASSERT LEGAL_CLOCK_SOURCE(MULTIPLIER_REGISTER0)
			REPORT "MULTIPLIER_REGISTER0(%) has an illegal clock source." MULTIPLIER_REGISTER0
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLOCK_SOURCE;

		ASSERT LEGAL_CLOCK_SOURCE(MULTIPLIER_REGISTER1)
			REPORT "MULTIPLIER_REGISTER1(%) has an illegal clock source." MULTIPLIER_REGISTER1
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLOCK_SOURCE;

		ASSERT LEGAL_CLOCK_SOURCE(MULTIPLIER_REGISTER2)
			REPORT "MULTIPLIER_REGISTER2(%) has an illegal clock source." MULTIPLIER_REGISTER2
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLOCK_SOURCE;
		
		ASSERT LEGAL_CLOCK_SOURCE(MULTIPLIER_REGISTER3)
			REPORT "MULTIPLIER_REGISTER3(%) has an illegal clock source." MULTIPLIER_REGISTER3
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLOCK_SOURCE;
		
		ASSERT LEGAL_CLOCK_SOURCE(ADDNSUB_MULTIPLIER_REGISTER1)
			REPORT "ADDNSUB_MULTIPLIER_REGISTER1(%) has an illegal clock source." ADDNSUB_MULTIPLIER_REGISTER1
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLOCK_SOURCE;

		ASSERT LEGAL_CLOCK_SOURCE(ADDNSUB_MULTIPLIER_PIPELINE_REGISTER1)
			REPORT "ADDNSUB_MULTIPLIER_PIPELINE_REGISTER1(%) has an illegal clock source." ADDNSUB_MULTIPLIER_PIPELINE_REGISTER1
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLOCK_SOURCE;
			
		ASSERT LEGAL_CLOCK_SOURCE(ADDNSUB_MULTIPLIER_REGISTER3)
			REPORT "ADDNSUB_MULTIPLIER_REGISTER1(%) has an illegal clock source." ADDNSUB_MULTIPLIER_REGISTER3
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLOCK_SOURCE;

		ASSERT LEGAL_CLOCK_SOURCE(ADDNSUB_MULTIPLIER_PIPELINE_REGISTER3)
			REPORT "ADDNSUB_MULTIPLIER_PIPELINE_REGISTER3(%) has an illegal clock source." ADDNSUB_MULTIPLIER_PIPELINE_REGISTER3
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLOCK_SOURCE;

		ASSERT LEGAL_CLOCK_SOURCE(OUTPUT_REGISTER)
			REPORT "OUTPUT_REGISTER(%) has an illegal clock source" OUTPUT_REGISTER
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLOCK_SOURCE;

		-- Cause:  The specified parameter is set to an illegal asynchronous clear source
		-- Action: Set the parameter to "ACLR0", "ACLR1", "ACLR2", or "ACLR3"
		ASSERT LEGAL_CLEAR_SOURCE(INPUT_ACLR_A0)
			REPORT "INPUT_ACLR_A0(%) has an illegal clear source." INPUT_ACLR_A0
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLEAR_SOURCE;
		
		ASSERT LEGAL_CLEAR_SOURCE(INPUT_ACLR_A1)
			REPORT "INPUT_ACLR_A1(%) has an illegal clear source." INPUT_ACLR_A1
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLEAR_SOURCE;
		
		ASSERT LEGAL_CLEAR_SOURCE(INPUT_ACLR_A2)
			REPORT "INPUT_ACLR_A2(%) has an illegal clear source." INPUT_ACLR_A2
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLEAR_SOURCE;

		ASSERT LEGAL_CLEAR_SOURCE(INPUT_ACLR_A3)
			REPORT "INPUT_ACLR_A3(%) has an illegal clear source." INPUT_ACLR_A3
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLEAR_SOURCE;

		ASSERT LEGAL_CLEAR_SOURCE(SIGNED_ACLR_A)
			REPORT "SIGNED_ACLR_A(%) has an illegal clear source." SIGNED_ACLR_A
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLEAR_SOURCE;
		
		ASSERT LEGAL_CLEAR_SOURCE(SIGNED_PIPELINE_ACLR_A)
			REPORT "SIGNED_PIPELINE_ACLR_A(%) has an illegal clear source." SIGNED_PIPELINE_ACLR_A
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLEAR_SOURCE;
			
		ASSERT LEGAL_CLEAR_SOURCE(INPUT_ACLR_B0)
			REPORT "INPUT_ACLR_B0(%) has an illegal clear source." INPUT_ACLR_B0
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLEAR_SOURCE;
			
		ASSERT LEGAL_CLEAR_SOURCE(INPUT_ACLR_B1)
			REPORT "INPUT_ACLR_B1(%) has an illegal clear source." INPUT_ACLR_B1
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLEAR_SOURCE;
		
		ASSERT LEGAL_CLEAR_SOURCE(INPUT_ACLR_B2)
			REPORT "INPUT_ACLR_B2(%) has an illegal clear source." INPUT_ACLR_B2
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLEAR_SOURCE;

		ASSERT LEGAL_CLEAR_SOURCE(INPUT_ACLR_B3)
			REPORT "INPUT_ACLR_B3(%) has an illegal clear source." INPUT_ACLR_B3
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLEAR_SOURCE;
		
		ASSERT LEGAL_CLEAR_SOURCE(SIGNED_ACLR_B)
			REPORT "SIGNED_ACLR_B(%) has an illegal clear source." SIGNED_ACLR_B
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLEAR_SOURCE;

		ASSERT LEGAL_CLEAR_SOURCE(SIGNED_PIPELINE_ACLR_B)
			REPORT "SIGNED_PIPELINE_ACLR_B(%) has an illegal clear source." SIGNED_PIPELINE_ACLR_B
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLEAR_SOURCE;

		ASSERT LEGAL_CLEAR_SOURCE(MULTIPLIER_ACLR0)
			REPORT "MULTIPLIER_ACLR0(%) has an illegal clear source." MULTIPLIER_ACLR0
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLEAR_SOURCE;

		ASSERT LEGAL_CLEAR_SOURCE(MULTIPLIER_ACLR1)
			REPORT "MULTIPLIER_ACLR1(%) has an illegal clear source." MULTIPLIER_ACLR1
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLEAR_SOURCE;

		ASSERT LEGAL_CLEAR_SOURCE(MULTIPLIER_ACLR2)
			REPORT "MULTIPLIER_ACLR2(%) has an illegal clear source." MULTIPLIER_ACLR2
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLEAR_SOURCE;

		ASSERT LEGAL_CLEAR_SOURCE(MULTIPLIER_ACLR3)
			REPORT "MULTIPLIER_ACLR3(%) has an illegal clear source." MULTIPLIER_ACLR3
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLEAR_SOURCE;

		ASSERT LEGAL_CLEAR_SOURCE(ADDNSUB_MULTIPLIER_ACLR1)
			REPORT "ADDNSUB_MULTIPLIER_ACLR1(%) has an illegal clear source." ADDNSUB_MULTIPLIER_ACLR1
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLEAR_SOURCE;
		
		ASSERT LEGAL_CLEAR_SOURCE(ADDNSUB_MULTIPLIER_PIPELINE_ACLR1)
			REPORT "ADDNSUB_MULTIPLIER_PIPELINE_ACLR1(%) has an illegal clear source." ADDNSUB_MULTIPLIER_PIPELINE_ACLR1
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLEAR_SOURCE;
		
		ASSERT LEGAL_CLEAR_SOURCE(ADDNSUB_MULTIPLIER_ACLR3)
			REPORT "ADDNSUB_MULTIPLIER_ACLR3(%) has an illegal clear source." ADDNSUB_MULTIPLIER_ACLR3
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLEAR_SOURCE;

		ASSERT LEGAL_CLEAR_SOURCE(ADDNSUB_MULTIPLIER_PIPELINE_ACLR3)
			REPORT "ADDNSUB_MULTIPLIER_PIPELINE_ACLR3(%) has an illegal clear source." ADDNSUB_MULTIPLIER_PIPELINE_ACLR3
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLEAR_SOURCE;

		ASSERT LEGAL_CLEAR_SOURCE(OUTPUT_ACLR)
			REPORT "OUTPUT_ACLR(%) has an illegal clear source." OUTPUT_ACLR
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLEAR_SOURCE;

		-- Cause: The input source is illegal.
		-- Action: Change the value to one of the legal values: "DATAA" or "SCANA"
		ASSERT LEGAL_INPUT_SOURCE_A(INPUT_SOURCE_A0)
			REPORT "INPUT_SOURCE_A0(%) has an illegal input source." INPUT_SOURCE_A0
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLEAR_SOURCE;

		ASSERT LEGAL_INPUT_SOURCE_A(INPUT_SOURCE_A1)
			REPORT "INPUT_SOURCE_A1(%) has an illegal input source." INPUT_SOURCE_A1
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLEAR_SOURCE;

		ASSERT LEGAL_INPUT_SOURCE_A(INPUT_SOURCE_A2)
			REPORT "INPUT_SOURCE_A2(%) has an illegal input source." INPUT_SOURCE_A2
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLEAR_SOURCE;
		
		ASSERT LEGAL_INPUT_SOURCE_A(INPUT_SOURCE_A3)
			REPORT "INPUT_SOURCE_A3(%) has an illegal input source." INPUT_SOURCE_A3
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLEAR_SOURCE;
		
		-- Cause: The input source is illegal.
		-- Action: Change the value to one of the legal values: "DATAB" or "SCANB"
		ASSERT LEGAL_INPUT_SOURCE_B(INPUT_SOURCE_B0)
			REPORT "INPUT_SOURCE_B0(%) has an illegal input source." INPUT_SOURCE_B0
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLEAR_SOURCE;

		ASSERT LEGAL_INPUT_SOURCE_B(INPUT_SOURCE_B1)
			REPORT "INPUT_SOURCE_B1(%) has an illegal input source." INPUT_SOURCE_B1
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLEAR_SOURCE;

		ASSERT LEGAL_INPUT_SOURCE_B(INPUT_SOURCE_B2)
			REPORT "INPUT_SOURCE_B2(%) has an illegal input source." INPUT_SOURCE_B2
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLEAR_SOURCE;

		ASSERT LEGAL_INPUT_SOURCE_B(INPUT_SOURCE_B3)
			REPORT "INPUT_SOURCE_B3(%) has an illegal input source." INPUT_SOURCE_B3
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_CLEAR_SOURCE;
		
		-- Cause: The parameter is set to an illegal value.
		-- Action: Set the value to one of he legal values: "UNSIGNED" or "SIGNED"
		ASSERT LEGAL_REPRESENTATION(REPRESENTATION_A)
			REPORT "REPRESENTATION_A(%) is set to an illegal number representation." REPRESENTATION_A
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_NUMBER_REPRESENTATION;

		ASSERT LEGAL_REPRESENTATION(REPRESENTATION_B)
			REPORT "REPRESENTATION_B(%) is set to an illegal number representation." REPRESENTATION_B
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_NUMBER_REPRESENTATION;
		
		-- Cause: The direction of the adder is set to an illegal value.
		-- Action: Set the value to one of the legl values: "ADD" or "SUB"
		ASSERT LEGAL_DIRECTION(MULTIPLIER1_DIRECTION)
			REPORT "MULTIPLIER1_DIRECTION(%) is set to an illegal value." MULTIPLIER1_DIRECTION
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_DIRECTION;

		ASSERT LEGAL_DIRECTION(MULTIPLIER3_DIRECTION)
			REPORT "MULTIPLIER3_DIRECTION(%) is set to an illegal value." MULTIPLIER3_DIRECTION
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ILLEGAL_DIRECTION;
		
		-- Cause: The USE_DEDICATED_CIRCUITRY parameter is set to an illegal value
		-- Action: Set the value to one of the legal values: "ON" or "OFF"
		ASSERT (DEDICATED_MULTIPLIER_CIRCUITRY == "YES") # (DEDICATED_MULTIPLIER_CIRCUITRY == "NO") # (DEDICATED_MULTIPLIER_CIRCUITRY == "AUTO")
			REPORT "DEDICATED_MULTIPLIER_CIRCUITRY(%) is set to an illegal value." DEDICATED_MULTIPLIER_CIRCUITRY
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_DEDICATED_CIRCUITRY_ILLEGAL;

		ASSERT !USED(addnsub1) # (NUMBER_OF_MULTIPLIERS >= 2)
			REPORT "Cannot connect the 'addnsub1' port unless NUMBER_OF_MULTIPLIERS(%) >= 2" NUMBER_OF_MULTIPLIERS
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ADDNSUB1;

		ASSERT !USED(addnsub3) # (NUMBER_OF_MULTIPLIERS >= 4)
			REPORT "Cannot connect the 'addnsub3' port unless NUMBER_OF_MULTIPLIERS(%) == 4" NUMBER_OF_MULTIPLIERS
			SEVERITY ERROR
			HELP_ID ALTMULT_ADD_ADDNSUB3;

		----------------
		-- Code Block --
		----------------
		IF !BIG_MULT() GENERATE
			-- Convert the 1D buses into 2D buses to make them easier to work with
			FOR i IN NUMBER_OF_MULTIPLIERS - 1 TO 0 GENERATE
				dataa_bus[i][] = dataa[(i + 1) * WIDTH_A - 1..i * WIDTH_A];
				datab_bus[i][] = datab[(I + 1) * WIDTH_B - 1..i * WIDTH_B];
			END GENERATE;
			-----------------
			-- data inputs --
			-----------------

			mult_atom[0].dataa[] = dataa_bus[0][];
			mult_atom[0].datab[] = datab_bus[0][];
			IF NUMBER_OF_MULTIPLIERS > 1 GENERATE
				IF INPUT_SOURCE_A1 == DATAA_SOURCE GENERATE
					mult_atom[1].dataa[] = dataa_bus[1][];
				ELSE GENERATE
					mult_atom[1].dataa[] = mult_atom[0].scanouta[];
				END GENERATE;
				IF INPUT_SOURCE_B1 == DATAB_SOURCE GENERATE
					mult_atom[1].datab[] = datab_bus[1][];
				ELSE GENERATE
					mult_atom[1].datab[] = mult_atom[0].scanoutb[];
				END GENERATE;
			END GENERATE;
			IF NUMBER_OF_MULTIPLIERS > 2 GENERATE
				IF INPUT_SOURCE_A2 == DATAA_SOURCE GENERATE
					mult_atom[2].dataa[] = dataa_bus[2][];
				ELSE GENERATE
					mult_atom[2].dataa[] = mult_atom[1].scanouta[];
				END GENERATE;
				IF INPUT_SOURCE_B2 == DATAB_SOURCE GENERATE
					mult_atom[2].datab[] = datab_bus[2][];
				ELSE GENERATE
					mult_atom[2].datab[] = mult_atom[1].scanoutb[];
				END GENERATE;
			END GENERATE;
			IF NUMBER_OF_MULTIPLIERS > 3 GENERATE
				IF INPUT_SOURCE_A3 == DATAA_SOURCE GENERATE
					mult_atom[3].dataa[] = dataa_bus[3][];
				ELSE GENERATE
					mult_atom[3].dataa[] = mult_atom[2].scanouta[];
				END GENERATE;
				IF INPUT_SOURCE_B3 == DATAB_SOURCE GENERATE
					mult_atom[3].datab[] = datab_bus[3][];
				ELSE GENERATE
					mult_atom[3].datab[] = mult_atom[2].scanoutb[];
				END GENERATE;
			END GENERATE;

			FOR i IN NUMBER_OF_MULTIPLIERS - 1 TO 0 GENERATE
				------------------------
				-- clocks  and clears --
				------------------------
				IF MULT_USING_CLOCK(i, "0") GENERATE
					mult_atom[i].clk[0] = clock0;
					mult_atom[i].ena[0] = ena0;
				END GENERATE;
				IF MULT_USING_CLOCK(i, "1") GENERATE
					mult_atom[i].clk[1] = clock1;
					mult_atom[i].ena[1] = ena1;
				END GENERATE;
				IF MULT_USING_CLOCK(i, "2") GENERATE
					mult_atom[i].clk[2] = clock2;
					mult_atom[i].ena[2] = ena2;
				END GENERATE;
				IF MULT_USING_CLOCK(i, "3") GENERATE
					mult_atom[i].clk[3] = clock3;
					mult_atom[i].ena[3] = ena3;
				END GENERATE;
				IF MULT_USING_CLEAR(i, "0") GENERATE
					mult_atom[i].aclr[0] = aclr0;
				END GENERATE;
				IF MULT_USING_CLEAR(i, "1") GENERATE
					mult_atom[i].aclr[1] = aclr1;
				END GENERATE;
				IF MULT_USING_CLEAR(i, "2") GENERATE
					mult_atom[i].aclr[2] = aclr2;
				END GENERATE;
				IF MULT_USING_CLEAR(i, "3") GENERATE
					mult_atom[i].aclr[3] = aclr3;
				END GENERATE;
			END GENERATE;

			-------------------------------------------------
			-- add the dummy multiplier if it is necessary --
			-------------------------------------------------
			IF ADD_DUMMY_MULT() GENERATE
				dummy_mult.dataa[] = GND;
				dummy_mult.datab[] = GND;

				IF USED(signa) GENERATE
					dummy_mult.signa = signa;

					IF SIGNED_REGISTER_A == CLK0 GENERATE
						dummy_mult.clk[0] = clock0;
						dummy_mult.ena[0] = ena0;
					END GENERATE;
					IF SIGNED_REGISTER_A == CLK1 GENERATE
						dummy_mult.clk[1] = clock1;
						dummy_mult.ena[1] = ena1;
					END GENERATE;
					IF SIGNED_REGISTER_A == CLK2 GENERATE
						dummy_mult.clk[2] = clock2;
						dummy_mult.ena[2] = ena2;
					END GENERATE;
					IF SIGNED_REGISTER_A == CLK3 GENERATE
						dummy_mult.clk[3] = clock3;
						dummy_mult.ena[3] = ena3;
					END GENERATE;
					IF SIGNED_REGISTER_A != NO_CLOCK GENERATE
						-- it is registered so its got to have a clear
						IF SIGNED_ACLR_A == CLEAR0 GENERATE
							dummy_mult.aclr[0] = aclr0;
						END GENERATE;
						IF SIGNED_ACLR_A == CLEAR1 GENERATE
							dummy_mult.aclr[1] = aclr1;
						END GENERATE;
						IF SIGNED_ACLR_A == CLEAR2 GENERATE
							dummy_mult.aclr[2] = aclr2;
						END GENERATE;
						IF SIGNED_ACLR_A == CLEAR3 GENERATE
							dummy_mult.aclr[3] = aclr3;
						END GENERATE;
					END GENERATE;
				ELSE GENERATE
					IF REPRESENTATION_A == SIGNED_REPRESENTATION GENERATE
						dummy_mult.signa = VCC;
					ELSE GENERATE
						dummy_mult.signa = GND;
					END GENERATE;
				END GENERATE;
				IF USED(signb) GENERATE
					dummy_mult.signb = signb;

					IF SIGNED_REGISTER_B == CLK0 GENERATE
						dummy_mult.clk[0] = clock0;
						dummy_mult.ena[0] = ena0;
					END GENERATE;
					IF SIGNED_REGISTER_B == CLK1 GENERATE
						dummy_mult.clk[1] = clock1;
						dummy_mult.ena[1] = ena1;
					END GENERATE;
					IF SIGNED_REGISTER_B == CLK2 GENERATE
						dummy_mult.clk[2] = clock2;
						dummy_mult.ena[2] = ena2;
					END GENERATE;
					IF SIGNED_REGISTER_B == CLK3 GENERATE
						dummy_mult.clk[3] = clock3;
						dummy_mult.ena[3] = ena3;
					END GENERATE;
					IF SIGNED_REGISTER_B != NO_CLOCK GENERATE
						-- it is registered so it has to have a clear
						IF SIGNED_ACLR_B == CLEAR0 GENERATE
							dummy_mult.aclr[0] = aclr0;
						END GENERATE;
						IF SIGNED_ACLR_B == CLEAR1 GENERATE
							dummy_mult.aclr[1] = aclr1;
						END GENERATE;
						IF SIGNED_ACLR_B == CLEAR2 GENERATE
							dummy_mult.aclr[2] = aclr2;
						END GENERATE;
						IF SIGNED_ACLR_B == CLEAR3 GENERATE
							dummy_mult.aclr[3] = aclr3;
						END GENERATE;
					END GENERATE;
				ELSE GENERATE
					IF REPRESENTATION_B == SIGNED_REPRESENTATION GENERATE
						dummy_mult.signb = VCC;
					ELSE GENERATE
						dummy_mult.signb = GND;
					END GENERATE;
				END GENERATE;
			END GENERATE;

			-----------------
			-- sign inputs --
			-----------------
			IF USED(signa) GENERATE
				mult_atom[].signa = signa;
				multout_atom.signa = signa;
			ELSE GENERATE
				IF REPRESENTATION_A == SIGNED_REPRESENTATION GENERATE
					mult_atom[].signa = VCC;
					multout_atom.signa = VCC;
				ELSE GENERATE
					mult_atom[].signa = GND;
					multout_atom.signa = GND;
				END GENERATE;
			END GENERATE;
			IF USED(signb) GENERATE
				mult_atom[].signb = signb;
				multout_atom.signb = signb;
			ELSE GENERATE
				IF REPRESENTATION_B == SIGNED_REPRESENTATION GENERATE
					mult_atom[].signb = VCC;
					multout_atom.signb = VCC;
				ELSE GENERATE
					mult_atom[].signb = GND;
					multout_atom.signb = GND;
				END GENERATE;
			END GENERATE;

			-----------------
			-- scan chains --
			-----------------
			scanouta[] = mult_atom[NUMBER_OF_MULTIPLIERS - 1].scanouta[];
			scanoutb[] = mult_atom[NUMBER_OF_MULTIPLIERS - 1].scanoutb[];

			-----------------------------------------
			-- Link to the multiplier output block --
			-----------------------------------------
			IF !ADD_DUMMY_MULT() GENERATE
				multout_atom.dataa[] = mult_atom[0].dataout[];
				IF NUMBER_OF_MULTIPLIERS > 1 GENERATE
					multout_atom.datab[] = mult_atom[1].dataout[];
				END GENERATE;
				IF NUMBER_OF_MULTIPLIERS > 2 GENERATE
					multout_atom.datac[] = mult_atom[2].dataout[];
				END GENERATE;
				IF NUMBER_OF_MULTIPLIERS > 3 GENERATE
					multout_atom.datad[] = mult_atom[3].dataout[];
				END GENERATE;
			ELSE GENERATE
				multout_atom.dataa[] = mult_atom[0].dataout[];
				multout_atom.datab[] = mult_atom[1].dataout[];
				multout_atom.datac[] = mult_atom[2].dataout[];
				multout_atom.datad[] = dummy_mult.dataout[];
			END GENERATE;
			-------------------------
			-- addnsub connections --
			-------------------------
			IF NUMBER_OF_MULTIPLIERS > 1 GENERATE
				IF USED(addnsub1) GENERATE
					multout_atom.addnsub0 = addnsub1;
				ELSE GENERATE
					IF MULTIPLIER1_DIRECTION == ADD_DIRECTION GENERATE
						multout_atom.addnsub0 = VCC;
					ELSE GENERATE
						multout_atom.addnsub0 = GND;
					END GENERATE;
				END GENERATE;
			END GENERATE;

			IF NUMBER_OF_MULTIPLIERS > 3 GENERATE
				IF USED(addnsub3) GENERATE
					multout_atom.addnsub1 = addnsub3;
				ELSE GENERATE
					IF MULTIPLIER3_DIRECTION == ADD_DIRECTION GENERATE
						multout_atom.addnsub1 = VCC;
					ELSE GENERATE
						multout_atom.addnsub1 = GND;
					END GENERATE;
				END GENERATE;
			END GENERATE;

			----------------------------
			-- clocks for the multout --
			----------------------------
			IF MULTOUT_USING_CLOCK("0") GENERATE
				multout_atom.clk[0] = clock0;
				multout_atom.ena[0] = ena0;
			END GENERATE;
			IF MULTOUT_USING_CLOCK("1") GENERATE
				multout_atom.clk[1] = clock1;
				multout_atom.ena[1] = ena1;
			END GENERATE;
			IF MULTOUT_USING_CLOCK("2") GENERATE
				multout_atom.clk[2] = clock2;
				multout_atom.ena[2] = ena2;
			END GENERATE;
			IF MULTOUT_USING_CLOCK("3") GENERATE
				multout_atom.clk[3] = clock3;
				multout_atom.ena[3] = ena3;
			END GENERATE;
			IF MULTOUT_USING_CLEAR("0") GENERATE
				multout_atom.aclr[0] = aclr0;
			END GENERATE;
			IF MULTOUT_USING_CLEAR("1") GENERATE
				multout_atom.aclr[1] = aclr1;
			END GENERATE;
			IF MULTOUT_USING_CLEAR("2") GENERATE
				multout_atom.aclr[2] = aclr2;
			END GENERATE;
			IF MULTOUT_USING_CLEAR("3") GENERATE
				multout_atom.aclr[3] = aclr3;
			END GENERATE;

			------------------------
			-- adjust the outputs --
			------------------------
			IF WIDTH_RESULT <= FULL_OUTPUT_WIDTH GENERATE
				result[] = multout_atom.dataout[WIDTH_RESULT - 1..0];
			ELSE GENERATE
				ASSERT REPORT "WIDTH_RESULT is too large.  Use a number that is less than or equal to %" FULL_OUTPUT_WIDTH SEVERITY ERROR;
			END GENERATE;
		ELSE GENERATE
			---------------------------------
			-- going for a 36 bit multiply --
			---------------------------------
			-- set unused bits to GND
			a_input[] = GND;
			b_input[] = GND;

			-- adjust the inputs so that their most significant bit is at the leftmost edge of the bus
			-- all other values will be set to GND to pad the multiplier inputs
			a_input[MAXIMUM_MULT_WIDTH - 1..MAXIMUM_MULT_WIDTH - WIDTH_A] = dataa[];
			b_input[MAXIMUM_MULT_WIDTH - 1..MAXIMUM_MULT_WIDTH - WIDTH_B] = datab[];

			mult_atom[0].dataa[] = a_input[MAXIMUM_ONE_LEVEL_MULT_WIDTH - 1..0];
			mult_atom[0].datab[] = b_input[MAXIMUM_ONE_LEVEL_MULT_WIDTH - 1..0];
			mult_atom[1].dataa[] = a_input[MAXIMUM_MULT_WIDTH - 1..MAXIMUM_ONE_LEVEL_MULT_WIDTH];
			mult_atom[1].datab[] = b_input[MAXIMUM_MULT_WIDTH - 1..MAXIMUM_ONE_LEVEL_MULT_WIDTH];
			mult_atom[2].dataa[] = a_input[MAXIMUM_MULT_WIDTH - 1..MAXIMUM_ONE_LEVEL_MULT_WIDTH];
			mult_atom[2].datab[] = b_input[MAXIMUM_ONE_LEVEL_MULT_WIDTH - 1..0];
			mult_atom[3].dataa[] = a_input[MAXIMUM_ONE_LEVEL_MULT_WIDTH - 1..0];
			mult_atom[3].datab[] = b_input[MAXIMUM_MULT_WIDTH - 1..MAXIMUM_ONE_LEVEL_MULT_WIDTH];

			-- register connections
			IF MULT_USING_CLOCK(0, "0") GENERATE
				mult_atom[].clk[0] = clock0;
				mult_atom[].ena[0] = ena0;
			END GENERATE;
			IF MULT_USING_CLOCK(0, "1") GENERATE
				mult_atom[].clk[1] = clock1;
				mult_atom[].ena[1] = ena1;
			END GENERATE;
			IF MULT_USING_CLOCK(0, "2") GENERATE
				mult_atom[].clk[2] = clock2;
				mult_atom[].ena[2] = ena2;
			END GENERATE;
			IF MULT_USING_CLOCK(0, "3") GENERATE
				mult_atom[].clk[3] = clock3;
				mult_atom[].ena[3] = ena3;
			END GENERATE;
			IF MULT_USING_CLEAR(0, "0") GENERATE
				mult_atom[].aclr[0] = aclr0;
			END GENERATE;
			IF MULT_USING_CLEAR(0, "1") GENERATE
				mult_atom[].aclr[1] = aclr1;
			END GENERATE;
			IF MULT_USING_CLEAR(0, "2") GENERATE
				mult_atom[].aclr[2] = aclr2;
			END GENERATE;
			IF MULT_USING_CLEAR(0, "3") GENERATE
				mult_atom[].aclr[3] = aclr3;
			END GENERATE;

			-- connect the multiplier atoms to the multipleir output atom
			multout_atom.dataa[] = mult_atom[0].dataout[];
			multout_atom.datab[] = mult_atom[1].dataout[];
			multout_atom.datac[] = mult_atom[2].dataout[];
			multout_atom.datad[] = mult_atom[3].dataout[];

			-- register connections
			IF BIG_MULTOUT_USING_CLOCK("0") GENERATE
				multout_atom.clk[0] = clock0;
				multout_atom.ena[0] = ena0;
			END GENERATE;
			IF BIG_MULTOUT_USING_CLOCK("1") GENERATE
				multout_atom.clk[1] = clock1;
				multout_atom.ena[1] = ena1;
			END GENERATE;
			IF BIG_MULTOUT_USING_CLOCK("2") GENERATE
				multout_atom.clk[2] = clock2;
				multout_atom.ena[2] = ena2;
			END GENERATE;
			IF BIG_MULTOUT_USING_CLOCK("3") GENERATE
				multout_atom.clk[3] = clock3;
				multout_atom.ena[3] = ena3;
			END GENERATE;
			IF BIG_MULTOUT_USING_CLEAR("0") GENERATE
				multout_atom.aclr[0] = aclr0;
			END GENERATE;
			IF BIG_MULTOUT_USING_CLEAR("1") GENERATE
				multout_atom.aclr[1] = aclr1;
			END GENERATE;
			IF BIG_MULTOUT_USING_CLEAR("2") GENERATE
				multout_atom.aclr[2] = aclr2;
			END GENERATE;
			IF BIG_MULTOUT_USING_CLEAR("3") GENERATE
				multout_atom.aclr[3] = aclr3;
			END GENERATE;

			-- control signals
			IF USED(signa) GENERATE
				mult_atom[].signa = signa;
				multout_atom.signa = signa;
			ELSE GENERATE
				IF REPRESENTATION_A == SIGNED_REPRESENTATION GENERATE
					mult_atom[].signa = VCC;
					multout_atom.signa = VCC;
				ELSE GENERATE
					mult_atom[].signa = GND;
					multout_atom.signa = GND;
				END GENERATE;
			END GENERATE;
			
			IF USED(signb) GENERATE
				mult_atom[].signb = signb;
				multout_atom.signb = signb;
			ELSE GENERATE
				IF REPRESENTATION_B == SIGNED_REPRESENTATION GENERATE
					mult_atom[].signb = VCC;
					multout_atom.signb = VCC;
				ELSE GENERATE
					mult_atom[].signb = GND;
					multout_atom.signb = GND;
				END GENERATE;
			END GENERATE;

			-- Make the external scan chains
			IF INPUT_REGISTER_A0 != NO_CLOCK GENERATE
				a_scan_chain[].d = dataa[];
				IF INPUT_REGISTER_A0 == CLK0 GENERATE
					a_scan_chain[].clk = clock0;
					a_scan_chain[].ena = ena0;
				ELSE GENERATE IF INPUT_REGISTER_A0 == CLK1 GENERATE
					a_scan_chain[].clk = clock1;
					a_scan_chain[].ena = ena1;
				ELSE GENERATE IF INPUT_REGISTER_A0 == CLK2 GENERATE
					a_scan_chain[].clk = clock2;
					a_scan_chain[].ena = ena2;
				ELSE GENERATE
					a_scan_chain[].clk = clock3;
					a_scan_chain[].ena = ena3;
				END GENERATE; END GENERATE; END GENERATE;
				-- set the asynchronous clear
				IF INPUT_ACLR_A0 == CLEAR0 GENERATE
					a_scan_chain[].clrn = !aclr0;
				ELSE GENERATE IF INPUT_ACLR_A0 == CLEAR1 GENERATE
					a_scan_chain[].clrn = !aclr1;
				ELSE GENERATE IF INPUT_ACLR_A0 == CLEAR2 GENERATE
					a_scan_chain[].clrn = !aclr2;
				ELSE GENERATE
					a_scan_chain[].clrn = !aclr3;
				END GENERATE; END GENERATE; END GENERATE;
			ELSE GENERATE
				a_scan_chain[] = dataa[];
			END GENERATE;

			IF INPUT_REGISTER_B0 != NO_CLOCK GENERATE
				b_scan_chain[].d = datab[];
				IF INPUT_REGISTER_B0 == CLK0 GENERATE
					b_scan_chain[].clk = clock0;
					b_scan_chain[].ena = ena0;
				ELSE GENERATE IF INPUT_REGISTER_B0 == CLK1 GENERATE
					b_scan_chain[].clk = clock1;
					b_scan_chain[].ena = ena1;
				ELSE GENERATE IF INPUT_REGISTER_B0 == CLK2 GENERATE
					b_scan_chain[].clk = clock2;
					b_scan_chain[].ena = ena2;
				ELSE GENERATE
					b_scan_chain[].clk = clock3;
					b_scan_chain[].ena = ena3;
				END GENERATE; END GENERATE; END GENERATE;
				-- set the asynchronous clear
				IF INPUT_ACLR_B0 == CLEAR0 GENERATE
					b_scan_chain[].clrn = !aclr0;
				ELSE GENERATE IF INPUT_ACLR_B0 == CLEAR1 GENERATE
					b_scan_chain[].clrn = !aclr1;
				ELSE GENERATE IF INPUT_ACLR_B0 == CLEAR2 GENERATE
					b_scan_chain[].clrn = !aclr2;
				ELSE GENERATE
					b_scan_chain[].clrn = !aclr3;
				END GENERATE; END GENERATE; END GENERATE;
			ELSE GENERATE
				b_scan_chain[] = datab[];
			END GENERATE;

			-- connect the scan chains to the output now that they are formed
			scanouta[] = a_scan_chain[];
			scanoutb[] = b_scan_chain[];

			-- Trim the output to the user requested size
			IF WIDTH_RESULT <= FULL_OUTPUT_WIDTH GENERATE
				result[] = multout_atom.dataout[2*MAXIMUM_MULT_WIDTH - 1 - (WIDTH_A + WIDTH_B - WIDTH_RESULT)..2*MAXIMUM_MULT_WIDTH - WIDTH_A - WIDTH_B];
			ELSE GENERATE
				ASSERT REPORT "WIDTH_RESULT is too large.  Use a number that is less than or equal to %" FULL_OUTPUT_WIDTH SEVERITY ERROR;
			END GENERATE;
		END GENERATE;
	ELSE GENERATE
		IF (CBXI_PARAMETER != "NOTHING") GENERATE
		IF USED(accum_sload) GENERATE
			auto_generated.accum_sload = accum_sload;
		END GENERATE;
		IF USED(aclr0) GENERATE
			auto_generated.aclr0 = aclr0;
		END GENERATE;
		IF USED(aclr1) GENERATE
			auto_generated.aclr1 = aclr1;
		END GENERATE;
		IF USED(aclr2) GENERATE
			auto_generated.aclr2 = aclr2;
		END GENERATE;
		IF USED(aclr3) GENERATE
			auto_generated.aclr3 = aclr3;
		END GENERATE;
		IF USED(addnsub1) GENERATE
			auto_generated.addnsub1 = addnsub1;
		END GENERATE;
		IF USED(addnsub1_round) GENERATE
			auto_generated.addnsub1_round = addnsub1_round;
		END GENERATE;
		IF USED(addnsub3) GENERATE
			auto_generated.addnsub3 = addnsub3;
		END GENERATE;
		IF USED(addnsub3_round) GENERATE
			auto_generated.addnsub3_round = addnsub3_round;
		END GENERATE;
		IF USED(chainin) GENERATE
			auto_generated.chainin[] = chainin[];
		END GENERATE;
		IF USED(chainout_round) GENERATE
			auto_generated.chainout_round = chainout_round;
		END GENERATE;
		IF USED(chainout_sat_overflow) GENERATE
			chainout_sat_overflow = auto_generated.chainout_sat_overflow;
		ELSE GENERATE
			chainout_sat_overflow = GND;
		END GENERATE;
		IF USED(chainout_saturate) GENERATE
			auto_generated.chainout_saturate = chainout_saturate;
		END GENERATE;
		IF USED(clock0) GENERATE
			auto_generated.clock0 = clock0;
		END GENERATE;
		IF USED(clock1) GENERATE
			auto_generated.clock1 = clock1;
		END GENERATE;
		IF USED(clock2) GENERATE
			auto_generated.clock2 = clock2;
		END GENERATE;
		IF USED(clock3) GENERATE
			auto_generated.clock3 = clock3;
		END GENERATE;
		IF USED(dataa) GENERATE
			auto_generated.dataa[] = dataa[];
		END GENERATE;
		IF USED(datab) GENERATE
			auto_generated.datab[] = datab[];
		END GENERATE;
		IF USED(ena0) GENERATE
			auto_generated.ena0 = ena0;
		END GENERATE;
		IF USED(ena1) GENERATE
			auto_generated.ena1 = ena1;
		END GENERATE;
		IF USED(ena2) GENERATE
			auto_generated.ena2 = ena2;
		END GENERATE;
		IF USED(ena3) GENERATE
			auto_generated.ena3 = ena3;
		END GENERATE;
		IF USED(mult01_round) GENERATE
			auto_generated.mult01_round = mult01_round;
		END GENERATE;
		IF USED(mult01_saturation) GENERATE
			auto_generated.mult01_saturation = mult01_saturation;
		END GENERATE;
		IF USED(mult0_is_saturated) GENERATE
			mult0_is_saturated = auto_generated.mult0_is_saturated;
		ELSE GENERATE
			mult0_is_saturated = GND;
		END GENERATE;
		IF USED(mult1_is_saturated) GENERATE
			mult1_is_saturated = auto_generated.mult1_is_saturated;
		ELSE GENERATE
			mult1_is_saturated = GND;
		END GENERATE;
		IF USED(mult23_round) GENERATE
			auto_generated.mult23_round = mult23_round;
		END GENERATE;
		IF USED(mult23_saturation) GENERATE
			auto_generated.mult23_saturation = mult23_saturation;
		END GENERATE;
		IF USED(mult2_is_saturated) GENERATE
			mult2_is_saturated = auto_generated.mult2_is_saturated;
		ELSE GENERATE
			mult2_is_saturated = GND;
		END GENERATE;
		IF USED(mult3_is_saturated) GENERATE
			mult3_is_saturated = auto_generated.mult3_is_saturated;
		ELSE GENERATE
			mult3_is_saturated = GND;
		END GENERATE;
		IF USED(output_round) GENERATE
			auto_generated.output_round = output_round;
		END GENERATE;
		IF USED(output_saturate) GENERATE
			auto_generated.output_saturate = output_saturate;
		END GENERATE;
		IF USED(overflow) GENERATE
			overflow = auto_generated.overflow;
		ELSE GENERATE
			overflow = GND;
		END GENERATE;
		IF USED(result) GENERATE
			result[] = auto_generated.result[];
		ELSE GENERATE
			result[] = GND;
		END GENERATE;
		IF USED(rotate) GENERATE
			auto_generated.rotate = rotate;
		END GENERATE;
		IF USED(scanina) GENERATE
			auto_generated.scanina[] = scanina[];
		END GENERATE;
		IF USED(scaninb) GENERATE
			auto_generated.scaninb[] = scaninb[];
		END GENERATE;
		IF USED(scanouta) GENERATE
			scanouta[] = auto_generated.scanouta[];
		ELSE GENERATE
			scanouta[] = GND;
		END GENERATE;
		IF USED(scanoutb) GENERATE
			scanoutb[] = auto_generated.scanoutb[];
		ELSE GENERATE
			scanoutb[] = GND;
		END GENERATE;
		IF USED(shift_right) GENERATE
			auto_generated.shift_right = shift_right;
		END GENERATE;
		IF USED(signa) GENERATE
			auto_generated.signa = signa;
		END GENERATE;
		IF USED(signb) GENERATE
			auto_generated.signb = signb;
		END GENERATE;
		IF USED(sourcea) GENERATE
			auto_generated.sourcea[] = sourcea[];
		END GENERATE;
		IF USED(sourceb) GENERATE
			auto_generated.sourceb[] = sourceb[];
		END GENERATE;
		IF USED(zero_chainout) GENERATE
			auto_generated.zero_chainout = zero_chainout;
		END GENERATE;
		IF USED(zero_loopback) GENERATE
			auto_generated.zero_loopback = zero_loopback;
		END GENERATE;
		ELSE GENERATE
			ASSERT (0)
			REPORT "The current megafunction is configured for use with the clear box feature and cannot be used when the clear box feature is disabled"
			SEVERITY ERROR
			HELP_ID MF_CBX_ONLY_SUPPORT;
		END GENERATE;
	END GENERATE;
	IF !USED(mult2_is_saturated) GENERATE
		mult2_is_saturated = GND;
	END GENERATE;
	IF !USED(scanouta) GENERATE
		scanouta[] = GND;
	END GENERATE;
	IF !USED(chainout_sat_overflow) GENERATE
		chainout_sat_overflow = GND;
	END GENERATE;
	IF !USED(scanoutb) GENERATE
		scanoutb[] = GND;
	END GENERATE;
	IF !USED(mult0_is_saturated) GENERATE
		mult0_is_saturated = GND;
	END GENERATE;
	IF !USED(mult1_is_saturated) GENERATE
		mult1_is_saturated = GND;
	END GENERATE;
	IF !USED(mult3_is_saturated) GENERATE
		mult3_is_saturated = GND;
	END GENERATE;
	IF !USED(overflow) GENERATE
		overflow = GND;
	END GENERATE;
	IF !USED(result) GENERATE
		result[] = GND;
	END GENERATE;
END;
